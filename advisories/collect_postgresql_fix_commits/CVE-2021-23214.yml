advisory_id: CVE-2021-23214
datasource_id: collect_postgresql_fix_commits/CVE-2021-23214
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  cace98d76cab8882125f6fbbe919f789fe2b9ee3:Last-minute updates for release notes.

  Security: CVE-2021-23214, CVE-2021-23222
  3eadebaa975d8a0af444b8ecc4a84854cdd7920a:Last-minute updates for release notes.

  Security: CVE-2021-23214, CVE-2021-23222
  965e7b1e8531341fed3ade7d03d9ee85fa7793d4:Last-minute updates for release notes.

  Security: CVE-2021-23214, CVE-2021-23222
  9f06c0755e8f9dc8d196b3dc8722138bf04d5d59:Last-minute updates for release notes.

  Security: CVE-2021-23214, CVE-2021-23222
  402c3ba3954d81531b6c9ff9b5d554552a85c6a7:Last-minute updates for release notes.

  Security: CVE-2021-23214, CVE-2021-23222
  ddc6917c314ddcf16f56dd2cfd52fbc721760b07:Last-minute updates for release notes.

  Security: CVE-2021-23214, CVE-2021-23222
  d83cdfdca9d918bbbd6bb209139b94c954da7228:libpq: reject extraneous data after SSL or GSS encryption handshake.

  libpq collects up to a bufferload of data whenever it reads data from
  the socket.  When SSL or GSS encryption is requested during startup,
  any additional data received with the server's yes-or-no reply
  remained in the buffer, and would be treated as already-decrypted data
  once the encryption handshake completed.  Thus, a man-in-the-middle
  with the ability to inject data into the TCP connection could stuff
  some cleartext data into the start of a supposedly encryption-protected
  database session.

  This could probably be abused to inject faked responses to the
  client's first few queries, although other details of libpq's behavior
  make that harder than it sounds.  A different line of attack is to
  exfiltrate the client's password, or other sensitive data that might
  be sent early in the session.  That has been shown to be possible with
  a server vulnerable to CVE-2021-23214.

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23222
  160c0258802d10b0600d7671b1bbea55d8e17d45:libpq: reject extraneous data after SSL or GSS encryption handshake.

  libpq collects up to a bufferload of data whenever it reads data from
  the socket.  When SSL or GSS encryption is requested during startup,
  any additional data received with the server's yes-or-no reply
  remained in the buffer, and would be treated as already-decrypted data
  once the encryption handshake completed.  Thus, a man-in-the-middle
  with the ability to inject data into the TCP connection could stuff
  some cleartext data into the start of a supposedly encryption-protected
  database session.

  This could probably be abused to inject faked responses to the
  client's first few queries, although other details of libpq's behavior
  make that harder than it sounds.  A different line of attack is to
  exfiltrate the client's password, or other sensitive data that might
  be sent early in the session.  That has been shown to be possible with
  a server vulnerable to CVE-2021-23214.

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23222
  e65d9c8cd15a86207f1da387a9c917c93c14ea11:libpq: reject extraneous data after SSL or GSS encryption handshake.

  libpq collects up to a bufferload of data whenever it reads data from
  the socket.  When SSL or GSS encryption is requested during startup,
  any additional data received with the server's yes-or-no reply
  remained in the buffer, and would be treated as already-decrypted data
  once the encryption handshake completed.  Thus, a man-in-the-middle
  with the ability to inject data into the TCP connection could stuff
  some cleartext data into the start of a supposedly encryption-protected
  database session.

  This could probably be abused to inject faked responses to the
  client's first few queries, although other details of libpq's behavior
  make that harder than it sounds.  A different line of attack is to
  exfiltrate the client's password, or other sensitive data that might
  be sent early in the session.  That has been shown to be possible with
  a server vulnerable to CVE-2021-23214.

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23222
  a021a1d2aeba8ce3391f56a070f01db00468da27:libpq: reject extraneous data after SSL or GSS encryption handshake.

  libpq collects up to a bufferload of data whenever it reads data from
  the socket.  When SSL or GSS encryption is requested during startup,
  any additional data received with the server's yes-or-no reply
  remained in the buffer, and would be treated as already-decrypted data
  once the encryption handshake completed.  Thus, a man-in-the-middle
  with the ability to inject data into the TCP connection could stuff
  some cleartext data into the start of a supposedly encryption-protected
  database session.

  This could probably be abused to inject faked responses to the
  client's first few queries, although other details of libpq's behavior
  make that harder than it sounds.  A different line of attack is to
  exfiltrate the client's password, or other sensitive data that might
  be sent early in the session.  That has been shown to be possible with
  a server vulnerable to CVE-2021-23214.

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23222
  36bb95ef2b5fdefaa99afbd859889a360e3c7763:libpq: reject extraneous data after SSL or GSS encryption handshake.

  libpq collects up to a bufferload of data whenever it reads data from
  the socket.  When SSL or GSS encryption is requested during startup,
  any additional data received with the server's yes-or-no reply
  remained in the buffer, and would be treated as already-decrypted data
  once the encryption handshake completed.  Thus, a man-in-the-middle
  with the ability to inject data into the TCP connection could stuff
  some cleartext data into the start of a supposedly encryption-protected
  database session.

  This could probably be abused to inject faked responses to the
  client's first few queries, although other details of libpq's behavior
  make that harder than it sounds.  A different line of attack is to
  exfiltrate the client's password, or other sensitive data that might
  be sent early in the session.  That has been shown to be possible with
  a server vulnerable to CVE-2021-23214.

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23222
  844b3169204c28cd086c1b4fae4a2cbdd0540640:libpq: reject extraneous data after SSL or GSS encryption handshake.

  libpq collects up to a bufferload of data whenever it reads data from
  the socket.  When SSL or GSS encryption is requested during startup,
  any additional data received with the server's yes-or-no reply
  remained in the buffer, and would be treated as already-decrypted data
  once the encryption handshake completed.  Thus, a man-in-the-middle
  with the ability to inject data into the TCP connection could stuff
  some cleartext data into the start of a supposedly encryption-protected
  database session.

  This could probably be abused to inject faked responses to the
  client's first few queries, although other details of libpq's behavior
  make that harder than it sounds.  A different line of attack is to
  exfiltrate the client's password, or other sensitive data that might
  be sent early in the session.  That has been shown to be possible with
  a server vulnerable to CVE-2021-23214.

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23222
  30547d7913098502cdc93c06f77c3629af51b24c:libpq: reject extraneous data after SSL or GSS encryption handshake.

  libpq collects up to a bufferload of data whenever it reads data from
  the socket.  When SSL or GSS encryption is requested during startup,
  any additional data received with the server's yes-or-no reply
  remained in the buffer, and would be treated as already-decrypted data
  once the encryption handshake completed.  Thus, a man-in-the-middle
  with the ability to inject data into the TCP connection could stuff
  some cleartext data into the start of a supposedly encryption-protected
  database session.

  This could probably be abused to inject faked responses to the
  client's first few queries, although other details of libpq's behavior
  make that harder than it sounds.  A different line of attack is to
  exfiltrate the client's password, or other sensitive data that might
  be sent early in the session.  That has been shown to be possible with
  a server vulnerable to CVE-2021-23214.

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23222
  046c2c846b741a12e7fd61d8d86bf324a20e3dfc:Reject extraneous data after SSL or GSS encryption handshake.

  The server collects up to a bufferload of data whenever it reads data
  from the client socket.  When SSL or GSS encryption is requested
  during startup, any additional data received with the initial
  request message remained in the buffer, and would be treated as
  already-decrypted data once the encryption handshake completed.
  Thus, a man-in-the-middle with the ability to inject data into the
  TCP connection could stuff some cleartext data into the start of
  a supposedly encryption-protected database session.

  This could be abused to send faked SQL commands to the server,
  although that would only work if the server did not demand any
  authentication data.  (However, a server relying on SSL certificate
  authentication might well not do so.)

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23214
  28e24125541545483093819efae9bca603441951:Reject extraneous data after SSL or GSS encryption handshake.

  The server collects up to a bufferload of data whenever it reads data
  from the client socket.  When SSL or GSS encryption is requested
  during startup, any additional data received with the initial
  request message remained in the buffer, and would be treated as
  already-decrypted data once the encryption handshake completed.
  Thus, a man-in-the-middle with the ability to inject data into the
  TCP connection could stuff some cleartext data into the start of
  a supposedly encryption-protected database session.

  This could be abused to send faked SQL commands to the server,
  although that would only work if the server did not demand any
  authentication data.  (However, a server relying on SSL certificate
  authentication might well not do so.)

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23214
  9ae0f1112954989e955b4b29e4580216eccfcee4:Reject extraneous data after SSL or GSS encryption handshake.

  The server collects up to a bufferload of data whenever it reads data
  from the client socket.  When SSL or GSS encryption is requested
  during startup, any additional data received with the initial
  request message remained in the buffer, and would be treated as
  already-decrypted data once the encryption handshake completed.
  Thus, a man-in-the-middle with the ability to inject data into the
  TCP connection could stuff some cleartext data into the start of
  a supposedly encryption-protected database session.

  This could be abused to send faked SQL commands to the server,
  although that would only work if the server did not demand any
  authentication data.  (However, a server relying on SSL certificate
  authentication might well not do so.)

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23214
  9394fb828998b4e71e4ef95eac6b80acac742835:Reject extraneous data after SSL or GSS encryption handshake.

  The server collects up to a bufferload of data whenever it reads data
  from the client socket.  When SSL or GSS encryption is requested
  during startup, any additional data received with the initial
  request message remained in the buffer, and would be treated as
  already-decrypted data once the encryption handshake completed.
  Thus, a man-in-the-middle with the ability to inject data into the
  TCP connection could stuff some cleartext data into the start of
  a supposedly encryption-protected database session.

  This could be abused to send faked SQL commands to the server,
  although that would only work if the server did not demand any
  authentication data.  (However, a server relying on SSL certificate
  authentication might well not do so.)

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23214
  d1bd26740a62b979e9aacb6507593946a402e39c:Reject extraneous data after SSL or GSS encryption handshake.

  The server collects up to a bufferload of data whenever it reads data
  from the client socket.  When SSL or GSS encryption is requested
  during startup, any additional data received with the initial
  request message remained in the buffer, and would be treated as
  already-decrypted data once the encryption handshake completed.
  Thus, a man-in-the-middle with the ability to inject data into the
  TCP connection could stuff some cleartext data into the start of
  a supposedly encryption-protected database session.

  This could be abused to send faked SQL commands to the server,
  although that would only work if the server did not demand any
  authentication data.  (However, a server relying on SSL certificate
  authentication might well not do so.)

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23214
  e92ed93e8eb76ee0701b42d4f0ce94e6af3fc741:Reject extraneous data after SSL or GSS encryption handshake.

  The server collects up to a bufferload of data whenever it reads data
  from the client socket.  When SSL or GSS encryption is requested
  during startup, any additional data received with the initial
  request message remained in the buffer, and would be treated as
  already-decrypted data once the encryption handshake completed.
  Thus, a man-in-the-middle with the ability to inject data into the
  TCP connection could stuff some cleartext data into the start of
  a supposedly encryption-protected database session.

  This could be abused to send faked SQL commands to the server,
  although that would only work if the server did not demand any
  authentication data.  (However, a server relying on SSL certificate
  authentication might well not do so.)

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23214
  9d5a76b8d18d6584341f754090c3007a54215f45:Reject extraneous data after SSL or GSS encryption handshake.

  The server collects up to a bufferload of data whenever it reads data
  from the client socket.  When SSL or GSS encryption is requested
  during startup, any additional data received with the initial
  request message remained in the buffer, and would be treated as
  already-decrypted data once the encryption handshake completed.
  Thus, a man-in-the-middle with the ability to inject data into the
  TCP connection could stuff some cleartext data into the start of
  a supposedly encryption-protected database session.

  This could be abused to send faked SQL commands to the server,
  although that would only work if the server did not demand any
  authentication data.  (However, a server relying on SSL certificate
  authentication might well not do so.)

  To fix, throw a protocol-violation error if the internal buffer
  is not empty after the encryption handshake.

  Our thanks to Jacob Champion for reporting this problem.

  Security: CVE-2021-23214
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 965e7b1e8531341fed3ade7d03d9ee85fa7793d4
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a021a1d2aeba8ce3391f56a070f01db00468da27
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 160c0258802d10b0600d7671b1bbea55d8e17d45
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 046c2c846b741a12e7fd61d8d86bf324a20e3dfc
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 3eadebaa975d8a0af444b8ecc4a84854cdd7920a
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 36bb95ef2b5fdefaa99afbd859889a360e3c7763
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 844b3169204c28cd086c1b4fae4a2cbdd0540640
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 30547d7913098502cdc93c06f77c3629af51b24c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e65d9c8cd15a86207f1da387a9c917c93c14ea11
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9f06c0755e8f9dc8d196b3dc8722138bf04d5d59
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e92ed93e8eb76ee0701b42d4f0ce94e6af3fc741
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d83cdfdca9d918bbbd6bb209139b94c954da7228
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: cace98d76cab8882125f6fbbe919f789fe2b9ee3
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 28e24125541545483093819efae9bca603441951
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 402c3ba3954d81531b6c9ff9b5d554552a85c6a7
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9ae0f1112954989e955b4b29e4580216eccfcee4
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: ddc6917c314ddcf16f56dd2cfd52fbc721760b07
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9394fb828998b4e71e4ef95eac6b80acac742835
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d1bd26740a62b979e9aacb6507593946a402e39c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9d5a76b8d18d6584341f754090c3007a54215f45
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/046c2c846b741a12e7fd61d8d86bf324a20e3dfc
    reference_type: commit
    reference_id: 046c2c846b741a12e7fd61d8d86bf324a20e3dfc
  - url: https://github.com/postgres/postgres/tree/160c0258802d10b0600d7671b1bbea55d8e17d45
    reference_type: commit
    reference_id: 160c0258802d10b0600d7671b1bbea55d8e17d45
  - url: https://github.com/postgres/postgres/tree/28e24125541545483093819efae9bca603441951
    reference_type: commit
    reference_id: 28e24125541545483093819efae9bca603441951
  - url: https://github.com/postgres/postgres/tree/30547d7913098502cdc93c06f77c3629af51b24c
    reference_type: commit
    reference_id: 30547d7913098502cdc93c06f77c3629af51b24c
  - url: https://github.com/postgres/postgres/tree/36bb95ef2b5fdefaa99afbd859889a360e3c7763
    reference_type: commit
    reference_id: 36bb95ef2b5fdefaa99afbd859889a360e3c7763
  - url: https://github.com/postgres/postgres/tree/3eadebaa975d8a0af444b8ecc4a84854cdd7920a
    reference_type: commit
    reference_id: 3eadebaa975d8a0af444b8ecc4a84854cdd7920a
  - url: https://github.com/postgres/postgres/tree/402c3ba3954d81531b6c9ff9b5d554552a85c6a7
    reference_type: commit
    reference_id: 402c3ba3954d81531b6c9ff9b5d554552a85c6a7
  - url: https://github.com/postgres/postgres/tree/844b3169204c28cd086c1b4fae4a2cbdd0540640
    reference_type: commit
    reference_id: 844b3169204c28cd086c1b4fae4a2cbdd0540640
  - url: https://github.com/postgres/postgres/tree/9394fb828998b4e71e4ef95eac6b80acac742835
    reference_type: commit
    reference_id: 9394fb828998b4e71e4ef95eac6b80acac742835
  - url: https://github.com/postgres/postgres/tree/965e7b1e8531341fed3ade7d03d9ee85fa7793d4
    reference_type: commit
    reference_id: 965e7b1e8531341fed3ade7d03d9ee85fa7793d4
  - url: https://github.com/postgres/postgres/tree/9ae0f1112954989e955b4b29e4580216eccfcee4
    reference_type: commit
    reference_id: 9ae0f1112954989e955b4b29e4580216eccfcee4
  - url: https://github.com/postgres/postgres/tree/9d5a76b8d18d6584341f754090c3007a54215f45
    reference_type: commit
    reference_id: 9d5a76b8d18d6584341f754090c3007a54215f45
  - url: https://github.com/postgres/postgres/tree/9f06c0755e8f9dc8d196b3dc8722138bf04d5d59
    reference_type: commit
    reference_id: 9f06c0755e8f9dc8d196b3dc8722138bf04d5d59
  - url: https://github.com/postgres/postgres/tree/a021a1d2aeba8ce3391f56a070f01db00468da27
    reference_type: commit
    reference_id: a021a1d2aeba8ce3391f56a070f01db00468da27
  - url: https://github.com/postgres/postgres/tree/cace98d76cab8882125f6fbbe919f789fe2b9ee3
    reference_type: commit
    reference_id: cace98d76cab8882125f6fbbe919f789fe2b9ee3
  - url: https://github.com/postgres/postgres/tree/d1bd26740a62b979e9aacb6507593946a402e39c
    reference_type: commit
    reference_id: d1bd26740a62b979e9aacb6507593946a402e39c
  - url: https://github.com/postgres/postgres/tree/d83cdfdca9d918bbbd6bb209139b94c954da7228
    reference_type: commit
    reference_id: d83cdfdca9d918bbbd6bb209139b94c954da7228
  - url: https://github.com/postgres/postgres/tree/ddc6917c314ddcf16f56dd2cfd52fbc721760b07
    reference_type: commit
    reference_id: ddc6917c314ddcf16f56dd2cfd52fbc721760b07
  - url: https://github.com/postgres/postgres/tree/e65d9c8cd15a86207f1da387a9c917c93c14ea11
    reference_type: commit
    reference_id: e65d9c8cd15a86207f1da387a9c917c93c14ea11
  - url: https://github.com/postgres/postgres/tree/e92ed93e8eb76ee0701b42d4f0ce94e6af3fc741
    reference_type: commit
    reference_id: e92ed93e8eb76ee0701b42d4f0ce94e6af3fc741
