advisory_id: CVE-2016-5423
datasource_id: collect_postgresql_fix_commits/CVE-2016-5423
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  6bb96c0a0699444ead4746e483fd56de3be5539c:Last-minute updates for release notes.

  Security: CVE-2016-5423, CVE-2016-5424
  c5081941f921bd342529b255ed2af1adccc253ed:Last-minute updates for release notes.

  Security: CVE-2016-5423, CVE-2016-5424
  43957e873d22ce5d279a91d3acda6fc9e848fda7:Last-minute updates for release notes.

  Security: CVE-2016-5423, CVE-2016-5424
  cf21e6f7e9448b9f0964e9864f570ade9d672496:Last-minute updates for release notes.

  Security: CVE-2016-5423, CVE-2016-5424
  2183966c6d00a16cc307f8563da469b14ed07b6f:Last-minute updates for release notes.

  Security: CVE-2016-5423, CVE-2016-5424
  9b8271c5a655ef1c35141b266d5039da8d3b2337:Last-minute updates for release notes.

  Security: CVE-2016-5423, CVE-2016-5424
  f40618092ffd5e1049c1d1cf967179cf1d4b6948:Fix two errors with nested CASE/WHEN constructs.

  ExecEvalCase() tried to save a cycle or two by passing
  &econtext->caseValue_isNull as the isNull argument to its sub-evaluation of
  the CASE value expression.  If that subexpression itself contained a CASE,
  then *isNull was an alias for econtext->caseValue_isNull within the
  recursive call of ExecEvalCase(), leading to confusion about whether the
  inner call's caseValue was null or not.  In the worst case this could lead
  to a core dump due to dereferencing a null pointer.  Fix by not assigning
  to the global variable until control comes back from the subexpression.
  Also, avoid using the passed-in isNull pointer transiently for evaluation
  of WHEN expressions.  (Either one of these changes would have been
  sufficient to fix the known misbehavior, but it's clear now that each of
  these choices was in itself dangerous coding practice and best avoided.
  There do not seem to be any similar hazards elsewhere in execQual.c.)

  Also, it was possible for inlining of a SQL function that implements the
  equality operator used for a CASE comparison to result in one CASE
  expression's CaseTestExpr node being inserted inside another CASE
  expression.  This would certainly result in wrong answers since the
  improperly nested CaseTestExpr would be caused to return the inner CASE's
  comparison value not the outer's.  If the CASE values were of different
  data types, a crash might result; moreover such situations could be abused
  to allow disclosure of portions of server memory.  To fix, teach
  inline_function to check for "bare" CaseTestExpr nodes in the arguments of
  a function to be inlined, and avoid inlining if there are any.

  Heikki Linnakangas, Michael Paquier, Tom Lane

  Report: https://github.com/greenplum-db/gpdb/pull/327
  Report: <4DDCEEB8.50602@enterprisedb.com>
  Security: CVE-2016-5423
  6c954a6a5f52cf04c6a99134331b42fa94cee606:Fix two errors with nested CASE/WHEN constructs.

  ExecEvalCase() tried to save a cycle or two by passing
  &econtext->caseValue_isNull as the isNull argument to its sub-evaluation of
  the CASE value expression.  If that subexpression itself contained a CASE,
  then *isNull was an alias for econtext->caseValue_isNull within the
  recursive call of ExecEvalCase(), leading to confusion about whether the
  inner call's caseValue was null or not.  In the worst case this could lead
  to a core dump due to dereferencing a null pointer.  Fix by not assigning
  to the global variable until control comes back from the subexpression.
  Also, avoid using the passed-in isNull pointer transiently for evaluation
  of WHEN expressions.  (Either one of these changes would have been
  sufficient to fix the known misbehavior, but it's clear now that each of
  these choices was in itself dangerous coding practice and best avoided.
  There do not seem to be any similar hazards elsewhere in execQual.c.)

  Also, it was possible for inlining of a SQL function that implements the
  equality operator used for a CASE comparison to result in one CASE
  expression's CaseTestExpr node being inserted inside another CASE
  expression.  This would certainly result in wrong answers since the
  improperly nested CaseTestExpr would be caused to return the inner CASE's
  comparison value not the outer's.  If the CASE values were of different
  data types, a crash might result; moreover such situations could be abused
  to allow disclosure of portions of server memory.  To fix, teach
  inline_function to check for "bare" CaseTestExpr nodes in the arguments of
  a function to be inlined, and avoid inlining if there are any.

  Heikki Linnakangas, Michael Paquier, Tom Lane

  Report: https://github.com/greenplum-db/gpdb/pull/327
  Report: <4DDCEEB8.50602@enterprisedb.com>
  Security: CVE-2016-5423
  8b32516db20c836d6e3c31d81adf75b3a297663d:Fix two errors with nested CASE/WHEN constructs.

  ExecEvalCase() tried to save a cycle or two by passing
  &econtext->caseValue_isNull as the isNull argument to its sub-evaluation of
  the CASE value expression.  If that subexpression itself contained a CASE,
  then *isNull was an alias for econtext->caseValue_isNull within the
  recursive call of ExecEvalCase(), leading to confusion about whether the
  inner call's caseValue was null or not.  In the worst case this could lead
  to a core dump due to dereferencing a null pointer.  Fix by not assigning
  to the global variable until control comes back from the subexpression.
  Also, avoid using the passed-in isNull pointer transiently for evaluation
  of WHEN expressions.  (Either one of these changes would have been
  sufficient to fix the known misbehavior, but it's clear now that each of
  these choices was in itself dangerous coding practice and best avoided.
  There do not seem to be any similar hazards elsewhere in execQual.c.)

  Also, it was possible for inlining of a SQL function that implements the
  equality operator used for a CASE comparison to result in one CASE
  expression's CaseTestExpr node being inserted inside another CASE
  expression.  This would certainly result in wrong answers since the
  improperly nested CaseTestExpr would be caused to return the inner CASE's
  comparison value not the outer's.  If the CASE values were of different
  data types, a crash might result; moreover such situations could be abused
  to allow disclosure of portions of server memory.  To fix, teach
  inline_function to check for "bare" CaseTestExpr nodes in the arguments of
  a function to be inlined, and avoid inlining if there are any.

  Heikki Linnakangas, Michael Paquier, Tom Lane

  Report: https://github.com/greenplum-db/gpdb/pull/327
  Report: <4DDCEEB8.50602@enterprisedb.com>
  Security: CVE-2016-5423
  5327b764a5ed98d290053a8cbc277b08fd55268a:Fix two errors with nested CASE/WHEN constructs.

  ExecEvalCase() tried to save a cycle or two by passing
  &econtext->caseValue_isNull as the isNull argument to its sub-evaluation of
  the CASE value expression.  If that subexpression itself contained a CASE,
  then *isNull was an alias for econtext->caseValue_isNull within the
  recursive call of ExecEvalCase(), leading to confusion about whether the
  inner call's caseValue was null or not.  In the worst case this could lead
  to a core dump due to dereferencing a null pointer.  Fix by not assigning
  to the global variable until control comes back from the subexpression.
  Also, avoid using the passed-in isNull pointer transiently for evaluation
  of WHEN expressions.  (Either one of these changes would have been
  sufficient to fix the known misbehavior, but it's clear now that each of
  these choices was in itself dangerous coding practice and best avoided.
  There do not seem to be any similar hazards elsewhere in execQual.c.)

  Also, it was possible for inlining of a SQL function that implements the
  equality operator used for a CASE comparison to result in one CASE
  expression's CaseTestExpr node being inserted inside another CASE
  expression.  This would certainly result in wrong answers since the
  improperly nested CaseTestExpr would be caused to return the inner CASE's
  comparison value not the outer's.  If the CASE values were of different
  data types, a crash might result; moreover such situations could be abused
  to allow disclosure of portions of server memory.  To fix, teach
  inline_function to check for "bare" CaseTestExpr nodes in the arguments of
  a function to be inlined, and avoid inlining if there are any.

  Heikki Linnakangas, Michael Paquier, Tom Lane

  Report: https://github.com/greenplum-db/gpdb/pull/327
  Report: <4DDCEEB8.50602@enterprisedb.com>
  Security: CVE-2016-5423
  f0c7b789ab12fbc8248b671c7882dd96ac932ef4:Fix two errors with nested CASE/WHEN constructs.

  ExecEvalCase() tried to save a cycle or two by passing
  &econtext->caseValue_isNull as the isNull argument to its sub-evaluation of
  the CASE value expression.  If that subexpression itself contained a CASE,
  then *isNull was an alias for econtext->caseValue_isNull within the
  recursive call of ExecEvalCase(), leading to confusion about whether the
  inner call's caseValue was null or not.  In the worst case this could lead
  to a core dump due to dereferencing a null pointer.  Fix by not assigning
  to the global variable until control comes back from the subexpression.
  Also, avoid using the passed-in isNull pointer transiently for evaluation
  of WHEN expressions.  (Either one of these changes would have been
  sufficient to fix the known misbehavior, but it's clear now that each of
  these choices was in itself dangerous coding practice and best avoided.
  There do not seem to be any similar hazards elsewhere in execQual.c.)

  Also, it was possible for inlining of a SQL function that implements the
  equality operator used for a CASE comparison to result in one CASE
  expression's CaseTestExpr node being inserted inside another CASE
  expression.  This would certainly result in wrong answers since the
  improperly nested CaseTestExpr would be caused to return the inner CASE's
  comparison value not the outer's.  If the CASE values were of different
  data types, a crash might result; moreover such situations could be abused
  to allow disclosure of portions of server memory.  To fix, teach
  inline_function to check for "bare" CaseTestExpr nodes in the arguments of
  a function to be inlined, and avoid inlining if there are any.

  Heikki Linnakangas, Michael Paquier, Tom Lane

  Report: https://github.com/greenplum-db/gpdb/pull/327
  Report: <4DDCEEB8.50602@enterprisedb.com>
  Security: CVE-2016-5423
  98b0c6280667ce1efae763340fb2c13c81e4d706:Fix two errors with nested CASE/WHEN constructs.

  ExecEvalCase() tried to save a cycle or two by passing
  &econtext->caseValue_isNull as the isNull argument to its sub-evaluation of
  the CASE value expression.  If that subexpression itself contained a CASE,
  then *isNull was an alias for econtext->caseValue_isNull within the
  recursive call of ExecEvalCase(), leading to confusion about whether the
  inner call's caseValue was null or not.  In the worst case this could lead
  to a core dump due to dereferencing a null pointer.  Fix by not assigning
  to the global variable until control comes back from the subexpression.
  Also, avoid using the passed-in isNull pointer transiently for evaluation
  of WHEN expressions.  (Either one of these changes would have been
  sufficient to fix the known misbehavior, but it's clear now that each of
  these choices was in itself dangerous coding practice and best avoided.
  There do not seem to be any similar hazards elsewhere in execQual.c.)

  Also, it was possible for inlining of a SQL function that implements the
  equality operator used for a CASE comparison to result in one CASE
  expression's CaseTestExpr node being inserted inside another CASE
  expression.  This would certainly result in wrong answers since the
  improperly nested CaseTestExpr would be caused to return the inner CASE's
  comparison value not the outer's.  If the CASE values were of different
  data types, a crash might result; moreover such situations could be abused
  to allow disclosure of portions of server memory.  To fix, teach
  inline_function to check for "bare" CaseTestExpr nodes in the arguments of
  a function to be inlined, and avoid inlining if there are any.

  Heikki Linnakangas, Michael Paquier, Tom Lane

  Report: https://github.com/greenplum-db/gpdb/pull/327
  Report: <4DDCEEB8.50602@enterprisedb.com>
  Security: CVE-2016-5423
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 5327b764a5ed98d290053a8cbc277b08fd55268a
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 98b0c6280667ce1efae763340fb2c13c81e4d706
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 6c954a6a5f52cf04c6a99134331b42fa94cee606
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: cf21e6f7e9448b9f0964e9864f570ade9d672496
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 6bb96c0a0699444ead4746e483fd56de3be5539c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9b8271c5a655ef1c35141b266d5039da8d3b2337
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: c5081941f921bd342529b255ed2af1adccc253ed
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 43957e873d22ce5d279a91d3acda6fc9e848fda7
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 2183966c6d00a16cc307f8563da469b14ed07b6f
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: f40618092ffd5e1049c1d1cf967179cf1d4b6948
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: f0c7b789ab12fbc8248b671c7882dd96ac932ef4
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 8b32516db20c836d6e3c31d81adf75b3a297663d
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/2183966c6d00a16cc307f8563da469b14ed07b6f
    reference_type: commit
    reference_id: 2183966c6d00a16cc307f8563da469b14ed07b6f
  - url: https://github.com/postgres/postgres/tree/43957e873d22ce5d279a91d3acda6fc9e848fda7
    reference_type: commit
    reference_id: 43957e873d22ce5d279a91d3acda6fc9e848fda7
  - url: https://github.com/postgres/postgres/tree/5327b764a5ed98d290053a8cbc277b08fd55268a
    reference_type: commit
    reference_id: 5327b764a5ed98d290053a8cbc277b08fd55268a
  - url: https://github.com/postgres/postgres/tree/6bb96c0a0699444ead4746e483fd56de3be5539c
    reference_type: commit
    reference_id: 6bb96c0a0699444ead4746e483fd56de3be5539c
  - url: https://github.com/postgres/postgres/tree/6c954a6a5f52cf04c6a99134331b42fa94cee606
    reference_type: commit
    reference_id: 6c954a6a5f52cf04c6a99134331b42fa94cee606
  - url: https://github.com/postgres/postgres/tree/8b32516db20c836d6e3c31d81adf75b3a297663d
    reference_type: commit
    reference_id: 8b32516db20c836d6e3c31d81adf75b3a297663d
  - url: https://github.com/postgres/postgres/tree/98b0c6280667ce1efae763340fb2c13c81e4d706
    reference_type: commit
    reference_id: 98b0c6280667ce1efae763340fb2c13c81e4d706
  - url: https://github.com/postgres/postgres/tree/9b8271c5a655ef1c35141b266d5039da8d3b2337
    reference_type: commit
    reference_id: 9b8271c5a655ef1c35141b266d5039da8d3b2337
  - url: https://github.com/postgres/postgres/tree/c5081941f921bd342529b255ed2af1adccc253ed
    reference_type: commit
    reference_id: c5081941f921bd342529b255ed2af1adccc253ed
  - url: https://github.com/postgres/postgres/tree/cf21e6f7e9448b9f0964e9864f570ade9d672496
    reference_type: commit
    reference_id: cf21e6f7e9448b9f0964e9864f570ade9d672496
  - url: https://github.com/postgres/postgres/tree/f0c7b789ab12fbc8248b671c7882dd96ac932ef4
    reference_type: commit
    reference_id: f0c7b789ab12fbc8248b671c7882dd96ac932ef4
  - url: https://github.com/postgres/postgres/tree/f40618092ffd5e1049c1d1cf967179cf1d4b6948
    reference_type: commit
    reference_id: f40618092ffd5e1049c1d1cf967179cf1d4b6948
