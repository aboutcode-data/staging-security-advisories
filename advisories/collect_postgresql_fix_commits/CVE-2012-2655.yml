advisory_id: CVE-2012-2655
datasource_id: collect_postgresql_fix_commits/CVE-2012-2655
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  ad0009e7be27489f5acc0a36217d9ea8f3db2b14:Force PL and range-type support functions to be owned by a superuser.

  We allow non-superusers to create procedural languages (with restrictions)
  and range datatypes.  Previously, the automatically-created support
  functions for these objects ended up owned by the creating user.  This
  represents a rather considerable security hazard, because the owning user
  might be able to alter a support function's definition in such a way as to
  crash the server, inject trojan-horse SQL code, or even execute arbitrary
  C code directly.  It appears that right now the only actually exploitable
  problem is the infinite-recursion bug fixed in the previous patch for
  CVE-2012-2655.  However, it's not hard to imagine that future additions of
  more ALTER FUNCTION capability might unintentionally open up new hazards.
  To forestall future problems, cause these support functions to be owned by
  the bootstrap superuser, not the user creating the parent object.
  8851d5e9bf1d02760d801c276f13114a2a8a7e2d:Ignore SECURITY DEFINER and SET attributes for a PL's call handler.

  It's not very sensible to set such attributes on a handler function;
  but if one were to do so, fmgr.c went into infinite recursion because
  it would call fmgr_security_definer instead of the handler function proper.
  There is no way for fmgr_security_definer to know that it ought to call the
  handler and not the original function referenced by the FmgrInfo's fn_oid,
  so it tries to do the latter, causing the whole process to start over
  again.

  Ordinarily such misconfiguration of a procedural language's handler could
  be written off as superuser error.  However, because we allow non-superuser
  database owners to create procedural languages and the handler for such a
  language becomes owned by the database owner, it is possible for a database
  owner to crash the backend, which ideally shouldn't be possible without
  superuser privileges.  In 9.2 and up we will adjust things so that the
  handler functions are always owned by superusers, but in existing branches
  this is a minor security fix.

  Problem noted by Noah Misch (after several of us had failed to detect
  it :-().  This is CVE-2012-2655.
  af6ee5e8d4d3b8623e1e8309d10d77d0dd8a5297:Ignore SECURITY DEFINER and SET attributes for a PL's call handler.

  It's not very sensible to set such attributes on a handler function;
  but if one were to do so, fmgr.c went into infinite recursion because
  it would call fmgr_security_definer instead of the handler function proper.
  There is no way for fmgr_security_definer to know that it ought to call the
  handler and not the original function referenced by the FmgrInfo's fn_oid,
  so it tries to do the latter, causing the whole process to start over
  again.

  Ordinarily such misconfiguration of a procedural language's handler could
  be written off as superuser error.  However, because we allow non-superuser
  database owners to create procedural languages and the handler for such a
  language becomes owned by the database owner, it is possible for a database
  owner to crash the backend, which ideally shouldn't be possible without
  superuser privileges.  In 9.2 and up we will adjust things so that the
  handler functions are always owned by superusers, but in existing branches
  this is a minor security fix.

  Problem noted by Noah Misch (after several of us had failed to detect
  it :-().  This is CVE-2012-2655.
  b53c7c3bc69658c31c5fd5fe7873cb85254e42f5:Ignore SECURITY DEFINER and SET attributes for a PL's call handler.

  It's not very sensible to set such attributes on a handler function;
  but if one were to do so, fmgr.c went into infinite recursion because
  it would call fmgr_security_definer instead of the handler function proper.
  There is no way for fmgr_security_definer to know that it ought to call the
  handler and not the original function referenced by the FmgrInfo's fn_oid,
  so it tries to do the latter, causing the whole process to start over
  again.

  Ordinarily such misconfiguration of a procedural language's handler could
  be written off as superuser error.  However, because we allow non-superuser
  database owners to create procedural languages and the handler for such a
  language becomes owned by the database owner, it is possible for a database
  owner to crash the backend, which ideally shouldn't be possible without
  superuser privileges.  In 9.2 and up we will adjust things so that the
  handler functions are always owned by superusers, but in existing branches
  this is a minor security fix.

  Problem noted by Noah Misch (after several of us had failed to detect
  it :-().  This is CVE-2012-2655.
  d72a3bd75813615898db27d4bbd2dca5cac9615a:Ignore SECURITY DEFINER and SET attributes for a PL's call handler.

  It's not very sensible to set such attributes on a handler function;
  but if one were to do so, fmgr.c went into infinite recursion because
  it would call fmgr_security_definer instead of the handler function proper.
  There is no way for fmgr_security_definer to know that it ought to call the
  handler and not the original function referenced by the FmgrInfo's fn_oid,
  so it tries to do the latter, causing the whole process to start over
  again.

  Ordinarily such misconfiguration of a procedural language's handler could
  be written off as superuser error.  However, because we allow non-superuser
  database owners to create procedural languages and the handler for such a
  language becomes owned by the database owner, it is possible for a database
  owner to crash the backend, which ideally shouldn't be possible without
  superuser privileges.  In 9.2 and up we will adjust things so that the
  handler functions are always owned by superusers, but in existing branches
  this is a minor security fix.

  Problem noted by Noah Misch (after several of us had failed to detect
  it :-().  This is CVE-2012-2655.
  33c6eaf78e692c0699e74a3883780d2edb68e4d7:Ignore SECURITY DEFINER and SET attributes for a PL's call handler.

  It's not very sensible to set such attributes on a handler function;
  but if one were to do so, fmgr.c went into infinite recursion because
  it would call fmgr_security_definer instead of the handler function proper.
  There is no way for fmgr_security_definer to know that it ought to call the
  handler and not the original function referenced by the FmgrInfo's fn_oid,
  so it tries to do the latter, causing the whole process to start over
  again.

  Ordinarily such misconfiguration of a procedural language's handler could
  be written off as superuser error.  However, because we allow non-superuser
  database owners to create procedural languages and the handler for such a
  language becomes owned by the database owner, it is possible for a database
  owner to crash the backend, which ideally shouldn't be possible without
  superuser privileges.  In 9.2 and up we will adjust things so that the
  handler functions are always owned by superusers, but in existing branches
  this is a minor security fix.

  Problem noted by Noah Misch (after several of us had failed to detect
  it :-().  This is CVE-2012-2655.
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 8851d5e9bf1d02760d801c276f13114a2a8a7e2d
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b53c7c3bc69658c31c5fd5fe7873cb85254e42f5
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 33c6eaf78e692c0699e74a3883780d2edb68e4d7
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d72a3bd75813615898db27d4bbd2dca5cac9615a
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: af6ee5e8d4d3b8623e1e8309d10d77d0dd8a5297
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: ad0009e7be27489f5acc0a36217d9ea8f3db2b14
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/33c6eaf78e692c0699e74a3883780d2edb68e4d7
    reference_type: commit
    reference_id: 33c6eaf78e692c0699e74a3883780d2edb68e4d7
  - url: https://github.com/postgres/postgres/tree/8851d5e9bf1d02760d801c276f13114a2a8a7e2d
    reference_type: commit
    reference_id: 8851d5e9bf1d02760d801c276f13114a2a8a7e2d
  - url: https://github.com/postgres/postgres/tree/ad0009e7be27489f5acc0a36217d9ea8f3db2b14
    reference_type: commit
    reference_id: ad0009e7be27489f5acc0a36217d9ea8f3db2b14
  - url: https://github.com/postgres/postgres/tree/af6ee5e8d4d3b8623e1e8309d10d77d0dd8a5297
    reference_type: commit
    reference_id: af6ee5e8d4d3b8623e1e8309d10d77d0dd8a5297
  - url: https://github.com/postgres/postgres/tree/b53c7c3bc69658c31c5fd5fe7873cb85254e42f5
    reference_type: commit
    reference_id: b53c7c3bc69658c31c5fd5fe7873cb85254e42f5
  - url: https://github.com/postgres/postgres/tree/d72a3bd75813615898db27d4bbd2dca5cac9615a
    reference_type: commit
    reference_id: d72a3bd75813615898db27d4bbd2dca5cac9615a
