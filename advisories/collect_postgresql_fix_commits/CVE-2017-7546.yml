advisory_id: CVE-2017-7546
datasource_id: collect_postgresql_fix_commits/CVE-2017-7546
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  a8b37ebe407f1916c5df22452cdbb1d00e2a409d:Last-minute updates for release notes.

  Security: CVE-2017-7546, CVE-2017-7547, CVE-2017-7548
  e28b2b094319e007b53ba384bb114c3f0b775a05:Last-minute updates for release notes.

  Security: CVE-2017-7546, CVE-2017-7547, CVE-2017-7548
  d64440f5fb7483faeb5fc1c9822e1ad2e0b555e2:Last-minute updates for release notes.

  Security: CVE-2017-7546, CVE-2017-7547, CVE-2017-7548
  5bb8162e45e3604a0f29825f792594f6ab2a7973:Last-minute updates for release notes.

  Security: CVE-2017-7546, CVE-2017-7547, CVE-2017-7548
  16f4297d1dc892eb55b384eb0a11543287138de3:Last-minute updates for release notes.

  Security: CVE-2017-7546, CVE-2017-7547, CVE-2017-7548
  57b995a9a4650cd294e1017946af54aabbbfe146:Last-minute updates for release notes.

  Security: CVE-2017-7546, CVE-2017-7547, CVE-2017-7548
  06651648a6dfb49e93612cc1dbd15dce362e31be:Don't allow logging in with empty password.

  Some authentication methods allowed it, others did not. In the client-side,
  libpq does not even try to authenticate with an empty password, which makes
  using empty passwords hazardous: an administrator might think that an
  account with an empty password cannot be used to log in, because psql
  doesn't allow it, and not realize that a different client would in fact
  allow it. To clear that confusion and to be be consistent, disallow empty
  passwords in all authentication methods.

  All the authentication methods that used plaintext authentication over the
  wire, except for BSD authentication, already checked that the password
  received from the user was not empty. To avoid forgetting it in the future
  again, move the check to the recv_password_packet function. That only
  forbids using an empty password with plaintext authentication, however.
  MD5 and SCRAM need a different fix:

  * In stable branches, check that the MD5 hash stored for the user does not
  not correspond to an empty string. This adds some overhead to MD5
  authentication, because the server needs to compute an extra MD5 hash, but
  it is not noticeable in practice.

  * In HEAD, modify CREATE and ALTER ROLE to clear the password if an empty
  string, or a password hash that corresponds to an empty string, is
  specified. The user-visible behavior is the same as in the stable branches,
  the user cannot log in, but it seems better to stop the empty password from
  entering the system in the first place. Secondly, it is fairly expensive to
  check that a SCRAM hash doesn't correspond to an empty string, because
  computing a SCRAM hash is much more expensive than an MD5 hash by design,
  so better avoid doing that on every authentication.

  We could clear the password on CREATE/ALTER ROLE also in stable branches,
  but we would still need to check at authentication time, because even if we
  prevent empty passwords from being stored in pg_authid, there might be
  existing ones there already.

  Reported by Jeroen van der Ham, Ben de Graaff and Jelte Fennema.

  Security: CVE-2017-7546
  b2f833ea71bf9d2d56ec0c0ae4d839b001e6e7b1:Don't allow logging in with empty password.

  Some authentication methods allowed it, others did not. In the client-side,
  libpq does not even try to authenticate with an empty password, which makes
  using empty passwords hazardous: an administrator might think that an
  account with an empty password cannot be used to log in, because psql
  doesn't allow it, and not realize that a different client would in fact
  allow it. To clear that confusion and to be be consistent, disallow empty
  passwords in all authentication methods.

  All the authentication methods that used plaintext authentication over the
  wire, except for BSD authentication, already checked that the password
  received from the user was not empty. To avoid forgetting it in the future
  again, move the check to the recv_password_packet function. That only
  forbids using an empty password with plaintext authentication, however.
  MD5 and SCRAM need a different fix:

  * In stable branches, check that the MD5 hash stored for the user does not
  not correspond to an empty string. This adds some overhead to MD5
  authentication, because the server needs to compute an extra MD5 hash, but
  it is not noticeable in practice.

  * In HEAD, modify CREATE and ALTER ROLE to clear the password if an empty
  string, or a password hash that corresponds to an empty string, is
  specified. The user-visible behavior is the same as in the stable branches,
  the user cannot log in, but it seems better to stop the empty password from
  entering the system in the first place. Secondly, it is fairly expensive to
  check that a SCRAM hash doesn't correspond to an empty string, because
  computing a SCRAM hash is much more expensive than an MD5 hash by design,
  so better avoid doing that on every authentication.

  We could clear the password on CREATE/ALTER ROLE also in stable branches,
  but we would still need to check at authentication time, because even if we
  prevent empty passwords from being stored in pg_authid, there might be
  existing ones there already.

  Reported by Jeroen van der Ham, Ben de Graaff and Jelte Fennema.

  Security: CVE-2017-7546
  d5d46d99ba47f77a847d29a35d6e069b233f2183:Don't allow logging in with empty password.

  Some authentication methods allowed it, others did not. In the client-side,
  libpq does not even try to authenticate with an empty password, which makes
  using empty passwords hazardous: an administrator might think that an
  account with an empty password cannot be used to log in, because psql
  doesn't allow it, and not realize that a different client would in fact
  allow it. To clear that confusion and to be be consistent, disallow empty
  passwords in all authentication methods.

  All the authentication methods that used plaintext authentication over the
  wire, except for BSD authentication, already checked that the password
  received from the user was not empty. To avoid forgetting it in the future
  again, move the check to the recv_password_packet function. That only
  forbids using an empty password with plaintext authentication, however.
  MD5 and SCRAM need a different fix:

  * In stable branches, check that the MD5 hash stored for the user does not
  not correspond to an empty string. This adds some overhead to MD5
  authentication, because the server needs to compute an extra MD5 hash, but
  it is not noticeable in practice.

  * In HEAD, modify CREATE and ALTER ROLE to clear the password if an empty
  string, or a password hash that corresponds to an empty string, is
  specified. The user-visible behavior is the same as in the stable branches,
  the user cannot log in, but it seems better to stop the empty password from
  entering the system in the first place. Secondly, it is fairly expensive to
  check that a SCRAM hash doesn't correspond to an empty string, because
  computing a SCRAM hash is much more expensive than an MD5 hash by design,
  so better avoid doing that on every authentication.

  We could clear the password on CREATE/ALTER ROLE also in stable branches,
  but we would still need to check at authentication time, because even if we
  prevent empty passwords from being stored in pg_authid, there might be
  existing ones there already.

  Reported by Jeroen van der Ham, Ben de Graaff and Jelte Fennema.

  Security: CVE-2017-7546
  127835ddf8c19c3df2cc05e40b6bcf84ad8abd42:Don't allow logging in with empty password.

  Some authentication methods allowed it, others did not. In the client-side,
  libpq does not even try to authenticate with an empty password, which makes
  using empty passwords hazardous: an administrator might think that an
  account with an empty password cannot be used to log in, because psql
  doesn't allow it, and not realize that a different client would in fact
  allow it. To clear that confusion and to be be consistent, disallow empty
  passwords in all authentication methods.

  All the authentication methods that used plaintext authentication over the
  wire, except for BSD authentication, already checked that the password
  received from the user was not empty. To avoid forgetting it in the future
  again, move the check to the recv_password_packet function. That only
  forbids using an empty password with plaintext authentication, however.
  MD5 and SCRAM need a different fix:

  * In stable branches, check that the MD5 hash stored for the user does not
  not correspond to an empty string. This adds some overhead to MD5
  authentication, because the server needs to compute an extra MD5 hash, but
  it is not noticeable in practice.

  * In HEAD, modify CREATE and ALTER ROLE to clear the password if an empty
  string, or a password hash that corresponds to an empty string, is
  specified. The user-visible behavior is the same as in the stable branches,
  the user cannot log in, but it seems better to stop the empty password from
  entering the system in the first place. Secondly, it is fairly expensive to
  check that a SCRAM hash doesn't correspond to an empty string, because
  computing a SCRAM hash is much more expensive than an MD5 hash by design,
  so better avoid doing that on every authentication.

  We could clear the password on CREATE/ALTER ROLE also in stable branches,
  but we would still need to check at authentication time, because even if we
  prevent empty passwords from being stored in pg_authid, there might be
  existing ones there already.

  Reported by Jeroen van der Ham, Ben de Graaff and Jelte Fennema.

  Security: CVE-2017-7546
  f6fc72cb697295c1807d14ee5c52d2086d1864af:Don't allow logging in with empty password.

  Some authentication methods allowed it, others did not. In the client-side,
  libpq does not even try to authenticate with an empty password, which makes
  using empty passwords hazardous: an administrator might think that an
  account with an empty password cannot be used to log in, because psql
  doesn't allow it, and not realize that a different client would in fact
  allow it. To clear that confusion and to be be consistent, disallow empty
  passwords in all authentication methods.

  All the authentication methods that used plaintext authentication over the
  wire, except for BSD authentication, already checked that the password
  received from the user was not empty. To avoid forgetting it in the future
  again, move the check to the recv_password_packet function. That only
  forbids using an empty password with plaintext authentication, however.
  MD5 and SCRAM need a different fix:

  * In stable branches, check that the MD5 hash stored for the user does not
  not correspond to an empty string. This adds some overhead to MD5
  authentication, because the server needs to compute an extra MD5 hash, but
  it is not noticeable in practice.

  * In HEAD, modify CREATE and ALTER ROLE to clear the password if an empty
  string, or a password hash that corresponds to an empty string, is
  specified. The user-visible behavior is the same as in the stable branches,
  the user cannot log in, but it seems better to stop the empty password from
  entering the system in the first place. Secondly, it is fairly expensive to
  check that a SCRAM hash doesn't correspond to an empty string, because
  computing a SCRAM hash is much more expensive than an MD5 hash by design,
  so better avoid doing that on every authentication.

  We could clear the password on CREATE/ALTER ROLE also in stable branches,
  but we would still need to check at authentication time, because even if we
  prevent empty passwords from being stored in pg_authid, there might be
  existing ones there already.

  Reported by Jeroen van der Ham, Ben de Graaff and Jelte Fennema.

  Security: CVE-2017-7546
  bf6b9e94445610a3d84cf9521032fab993f96fd6:Don't allow logging in with empty password.

  Some authentication methods allowed it, others did not. In the client-side,
  libpq does not even try to authenticate with an empty password, which makes
  using empty passwords hazardous: an administrator might think that an
  account with an empty password cannot be used to log in, because psql
  doesn't allow it, and not realize that a different client would in fact
  allow it. To clear that confusion and to be be consistent, disallow empty
  passwords in all authentication methods.

  All the authentication methods that used plaintext authentication over the
  wire, except for BSD authentication, already checked that the password
  received from the user was not empty. To avoid forgetting it in the future
  again, move the check to the recv_password_packet function. That only
  forbids using an empty password with plaintext authentication, however.
  MD5 and SCRAM need a different fix:

  * In stable branches, check that the MD5 hash stored for the user does not
  not correspond to an empty string. This adds some overhead to MD5
  authentication, because the server needs to compute an extra MD5 hash, but
  it is not noticeable in practice.

  * In HEAD, modify CREATE and ALTER ROLE to clear the password if an empty
  string, or a password hash that corresponds to an empty string, is
  specified. The user-visible behavior is the same as in the stable branches,
  the user cannot log in, but it seems better to stop the empty password from
  entering the system in the first place. Secondly, it is fairly expensive to
  check that a SCRAM hash doesn't correspond to an empty string, because
  computing a SCRAM hash is much more expensive than an MD5 hash by design,
  so better avoid doing that on every authentication.

  We could clear the password on CREATE/ALTER ROLE also in stable branches,
  but we would still need to check at authentication time, because even if we
  prevent empty passwords from being stored in pg_authid, there might be
  existing ones there already.

  Reported by Jeroen van der Ham, Ben de Graaff and Jelte Fennema.

  Security: CVE-2017-7546
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d5d46d99ba47f77a847d29a35d6e069b233f2183
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: f6fc72cb697295c1807d14ee5c52d2086d1864af
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b2f833ea71bf9d2d56ec0c0ae4d839b001e6e7b1
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: bf6b9e94445610a3d84cf9521032fab993f96fd6
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 5bb8162e45e3604a0f29825f792594f6ab2a7973
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 16f4297d1dc892eb55b384eb0a11543287138de3
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e28b2b094319e007b53ba384bb114c3f0b775a05
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d64440f5fb7483faeb5fc1c9822e1ad2e0b555e2
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 06651648a6dfb49e93612cc1dbd15dce362e31be
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 127835ddf8c19c3df2cc05e40b6bcf84ad8abd42
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 57b995a9a4650cd294e1017946af54aabbbfe146
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a8b37ebe407f1916c5df22452cdbb1d00e2a409d
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/06651648a6dfb49e93612cc1dbd15dce362e31be
    reference_type: commit
    reference_id: 06651648a6dfb49e93612cc1dbd15dce362e31be
  - url: https://github.com/postgres/postgres/tree/127835ddf8c19c3df2cc05e40b6bcf84ad8abd42
    reference_type: commit
    reference_id: 127835ddf8c19c3df2cc05e40b6bcf84ad8abd42
  - url: https://github.com/postgres/postgres/tree/16f4297d1dc892eb55b384eb0a11543287138de3
    reference_type: commit
    reference_id: 16f4297d1dc892eb55b384eb0a11543287138de3
  - url: https://github.com/postgres/postgres/tree/57b995a9a4650cd294e1017946af54aabbbfe146
    reference_type: commit
    reference_id: 57b995a9a4650cd294e1017946af54aabbbfe146
  - url: https://github.com/postgres/postgres/tree/5bb8162e45e3604a0f29825f792594f6ab2a7973
    reference_type: commit
    reference_id: 5bb8162e45e3604a0f29825f792594f6ab2a7973
  - url: https://github.com/postgres/postgres/tree/a8b37ebe407f1916c5df22452cdbb1d00e2a409d
    reference_type: commit
    reference_id: a8b37ebe407f1916c5df22452cdbb1d00e2a409d
  - url: https://github.com/postgres/postgres/tree/b2f833ea71bf9d2d56ec0c0ae4d839b001e6e7b1
    reference_type: commit
    reference_id: b2f833ea71bf9d2d56ec0c0ae4d839b001e6e7b1
  - url: https://github.com/postgres/postgres/tree/bf6b9e94445610a3d84cf9521032fab993f96fd6
    reference_type: commit
    reference_id: bf6b9e94445610a3d84cf9521032fab993f96fd6
  - url: https://github.com/postgres/postgres/tree/d5d46d99ba47f77a847d29a35d6e069b233f2183
    reference_type: commit
    reference_id: d5d46d99ba47f77a847d29a35d6e069b233f2183
  - url: https://github.com/postgres/postgres/tree/d64440f5fb7483faeb5fc1c9822e1ad2e0b555e2
    reference_type: commit
    reference_id: d64440f5fb7483faeb5fc1c9822e1ad2e0b555e2
  - url: https://github.com/postgres/postgres/tree/e28b2b094319e007b53ba384bb114c3f0b775a05
    reference_type: commit
    reference_id: e28b2b094319e007b53ba384bb114c3f0b775a05
  - url: https://github.com/postgres/postgres/tree/f6fc72cb697295c1807d14ee5c52d2086d1864af
    reference_type: commit
    reference_id: f6fc72cb697295c1807d14ee5c52d2086d1864af
