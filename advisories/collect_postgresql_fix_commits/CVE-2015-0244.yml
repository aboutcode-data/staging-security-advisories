advisory_id: CVE-2015-0244
datasource_id: collect_postgresql_fix_commits/CVE-2015-0244
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  69ba47d6f9866d1dad93c4d613d8c635f32c1c07:Last-minute updates for release notes.

  Add entries for security issues.

  Security: CVE-2015-0241 through CVE-2015-0244
  0c93924b1698a284fe49026b24d1b436e8a01722:Last-minute updates for release notes.

  Add entries for security issues.

  Security: CVE-2015-0241 through CVE-2015-0244
  b8f0a57d13fce3c61f99f07077e07ccba0848e71:Last-minute updates for release notes.

  Add entries for security issues.

  Security: CVE-2015-0241 through CVE-2015-0244
  0a819b6f6239188ac9d6c9d7f463ff9c6ca9e4ec:Last-minute updates for release notes.

  Add entries for security issues.

  Security: CVE-2015-0241 through CVE-2015-0244
  3face5a8d9ffbb5d37b5c29949d4363bd64f7446:Last-minute updates for release notes.

  Add entries for security issues.

  Security: CVE-2015-0241 through CVE-2015-0244
  2488eff889f83d7d6411be9a6172ff69df3f0085:Last-minute updates for release notes.

  Add entries for security issues.

  Security: CVE-2015-0241 through CVE-2015-0244
  2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b:Be more careful to not lose sync in the FE/BE protocol.

  If any error occurred while we were in the middle of reading a protocol
  message from the client, we could lose sync, and incorrectly try to
  interpret a part of another message as a new protocol message. That will
  usually lead to an "invalid frontend message" error that terminates the
  connection. However, this is a security issue because an attacker might
  be able to deliberately cause an error, inject a Query message in what's
  supposed to be just user data, and have the server execute it.

  We were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other
  operations that could ereport(ERROR) in the middle of processing a message,
  but a query cancel interrupt or statement timeout could nevertheless cause
  it to happen. Also, the V2 fastpath and COPY handling were not so careful.
  It's very difficult to recover in the V2 COPY protocol, so we will just
  terminate the connection on error. In practice, that's what happened
  previously anyway, as we lost protocol sync.

  To fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set
  whenever we're in the middle of reading a message. When it's set, we cannot
  safely ERROR out and continue running, because we might've read only part
  of a message. PqCommReadingMsg acts somewhat similarly to critical sections
  in that if an error occurs while it's set, the error handler will force the
  connection to be terminated, as if the error was FATAL. It's not
  implemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted
  to PANIC in critical sections, because we want to be able to use
  PG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes
  advantage of that to prevent an OOM error from terminating the connection.

  To prevent unnecessary connection terminations, add a holdoff mechanism
  similar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel
  interrupts, but still allow die interrupts. The rules on which interrupts
  are processed when are now a bit more complicated, so refactor
  ProcessInterrupts() and the calls to it in signal handlers so that the
  signal handlers always call it if ImmediateInterruptOK is set, and
  ProcessInterrupts() can decide to not do anything if the other conditions
  are not met.

  Reported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.
  Backpatch to all supported versions.

  Security: CVE-2015-0244
  57ec87c6b8dcb5258aae414fbdbeaf6eaf09feb1:Be more careful to not lose sync in the FE/BE protocol.

  If any error occurred while we were in the middle of reading a protocol
  message from the client, we could lose sync, and incorrectly try to
  interpret a part of another message as a new protocol message. That will
  usually lead to an "invalid frontend message" error that terminates the
  connection. However, this is a security issue because an attacker might
  be able to deliberately cause an error, inject a Query message in what's
  supposed to be just user data, and have the server execute it.

  We were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other
  operations that could ereport(ERROR) in the middle of processing a message,
  but a query cancel interrupt or statement timeout could nevertheless cause
  it to happen. Also, the V2 fastpath and COPY handling were not so careful.
  It's very difficult to recover in the V2 COPY protocol, so we will just
  terminate the connection on error. In practice, that's what happened
  previously anyway, as we lost protocol sync.

  To fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set
  whenever we're in the middle of reading a message. When it's set, we cannot
  safely ERROR out and continue running, because we might've read only part
  of a message. PqCommReadingMsg acts somewhat similarly to critical sections
  in that if an error occurs while it's set, the error handler will force the
  connection to be terminated, as if the error was FATAL. It's not
  implemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted
  to PANIC in critical sections, because we want to be able to use
  PG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes
  advantage of that to prevent an OOM error from terminating the connection.

  To prevent unnecessary connection terminations, add a holdoff mechanism
  similar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel
  interrupts, but still allow die interrupts. The rules on which interrupts
  are processed when are now a bit more complicated, so refactor
  ProcessInterrupts() and the calls to it in signal handlers so that the
  signal handlers always call it if ImmediateInterruptOK is set, and
  ProcessInterrupts() can decide to not do anything if the other conditions
  are not met.

  Reported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.
  Backpatch to all supported versions.

  Security: CVE-2015-0244
  cd19848bd555223eb613c699a5f6360b4133f7fa:Be more careful to not lose sync in the FE/BE protocol.

  If any error occurred while we were in the middle of reading a protocol
  message from the client, we could lose sync, and incorrectly try to
  interpret a part of another message as a new protocol message. That will
  usually lead to an "invalid frontend message" error that terminates the
  connection. However, this is a security issue because an attacker might
  be able to deliberately cause an error, inject a Query message in what's
  supposed to be just user data, and have the server execute it.

  We were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other
  operations that could ereport(ERROR) in the middle of processing a message,
  but a query cancel interrupt or statement timeout could nevertheless cause
  it to happen. Also, the V2 fastpath and COPY handling were not so careful.
  It's very difficult to recover in the V2 COPY protocol, so we will just
  terminate the connection on error. In practice, that's what happened
  previously anyway, as we lost protocol sync.

  To fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set
  whenever we're in the middle of reading a message. When it's set, we cannot
  safely ERROR out and continue running, because we might've read only part
  of a message. PqCommReadingMsg acts somewhat similarly to critical sections
  in that if an error occurs while it's set, the error handler will force the
  connection to be terminated, as if the error was FATAL. It's not
  implemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted
  to PANIC in critical sections, because we want to be able to use
  PG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes
  advantage of that to prevent an OOM error from terminating the connection.

  To prevent unnecessary connection terminations, add a holdoff mechanism
  similar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel
  interrupts, but still allow die interrupts. The rules on which interrupts
  are processed when are now a bit more complicated, so refactor
  ProcessInterrupts() and the calls to it in signal handlers so that the
  signal handlers always call it if ImmediateInterruptOK is set, and
  ProcessInterrupts() can decide to not do anything if the other conditions
  are not met.

  Reported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.
  Backpatch to all supported versions.

  Security: CVE-2015-0244
  289592b23eef85b82034595b6261c7a6b0326139:Be more careful to not lose sync in the FE/BE protocol.

  If any error occurred while we were in the middle of reading a protocol
  message from the client, we could lose sync, and incorrectly try to
  interpret a part of another message as a new protocol message. That will
  usually lead to an "invalid frontend message" error that terminates the
  connection. However, this is a security issue because an attacker might
  be able to deliberately cause an error, inject a Query message in what's
  supposed to be just user data, and have the server execute it.

  We were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other
  operations that could ereport(ERROR) in the middle of processing a message,
  but a query cancel interrupt or statement timeout could nevertheless cause
  it to happen. Also, the V2 fastpath and COPY handling were not so careful.
  It's very difficult to recover in the V2 COPY protocol, so we will just
  terminate the connection on error. In practice, that's what happened
  previously anyway, as we lost protocol sync.

  To fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set
  whenever we're in the middle of reading a message. When it's set, we cannot
  safely ERROR out and continue running, because we might've read only part
  of a message. PqCommReadingMsg acts somewhat similarly to critical sections
  in that if an error occurs while it's set, the error handler will force the
  connection to be terminated, as if the error was FATAL. It's not
  implemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted
  to PANIC in critical sections, because we want to be able to use
  PG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes
  advantage of that to prevent an OOM error from terminating the connection.

  To prevent unnecessary connection terminations, add a holdoff mechanism
  similar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel
  interrupts, but still allow die interrupts. The rules on which interrupts
  are processed when are now a bit more complicated, so refactor
  ProcessInterrupts() and the calls to it in signal handlers so that the
  signal handlers always call it if ImmediateInterruptOK is set, and
  ProcessInterrupts() can decide to not do anything if the other conditions
  are not met.

  Reported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.
  Backpatch to all supported versions.

  Security: CVE-2015-0244
  af9c5c074f7a0f6688351ef4e973707a26ccd1ea:Be more careful to not lose sync in the FE/BE protocol.

  If any error occurred while we were in the middle of reading a protocol
  message from the client, we could lose sync, and incorrectly try to
  interpret a part of another message as a new protocol message. That will
  usually lead to an "invalid frontend message" error that terminates the
  connection. However, this is a security issue because an attacker might
  be able to deliberately cause an error, inject a Query message in what's
  supposed to be just user data, and have the server execute it.

  We were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other
  operations that could ereport(ERROR) in the middle of processing a message,
  but a query cancel interrupt or statement timeout could nevertheless cause
  it to happen. Also, the V2 fastpath and COPY handling were not so careful.
  It's very difficult to recover in the V2 COPY protocol, so we will just
  terminate the connection on error. In practice, that's what happened
  previously anyway, as we lost protocol sync.

  To fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set
  whenever we're in the middle of reading a message. When it's set, we cannot
  safely ERROR out and continue running, because we might've read only part
  of a message. PqCommReadingMsg acts somewhat similarly to critical sections
  in that if an error occurs while it's set, the error handler will force the
  connection to be terminated, as if the error was FATAL. It's not
  implemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted
  to PANIC in critical sections, because we want to be able to use
  PG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes
  advantage of that to prevent an OOM error from terminating the connection.

  To prevent unnecessary connection terminations, add a holdoff mechanism
  similar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel
  interrupts, but still allow die interrupts. The rules on which interrupts
  are processed when are now a bit more complicated, so refactor
  ProcessInterrupts() and the calls to it in signal handlers so that the
  signal handlers always call it if ImmediateInterruptOK is set, and
  ProcessInterrupts() can decide to not do anything if the other conditions
  are not met.

  Reported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.
  Backpatch to all supported versions.

  Security: CVE-2015-0244
  47ba0fbd796bb71652d1c73d38a0b4ca8de4a253:Be more careful to not lose sync in the FE/BE protocol.

  If any error occurred while we were in the middle of reading a protocol
  message from the client, we could lose sync, and incorrectly try to
  interpret a part of another message as a new protocol message. That will
  usually lead to an "invalid frontend message" error that terminates the
  connection. However, this is a security issue because an attacker might
  be able to deliberately cause an error, inject a Query message in what's
  supposed to be just user data, and have the server execute it.

  We were quite careful to not have CHECK_FOR_INTERRUPTS() calls or other
  operations that could ereport(ERROR) in the middle of processing a message,
  but a query cancel interrupt or statement timeout could nevertheless cause
  it to happen. Also, the V2 fastpath and COPY handling were not so careful.
  It's very difficult to recover in the V2 COPY protocol, so we will just
  terminate the connection on error. In practice, that's what happened
  previously anyway, as we lost protocol sync.

  To fix, add a new variable in pqcomm.c, PqCommReadingMsg, that is set
  whenever we're in the middle of reading a message. When it's set, we cannot
  safely ERROR out and continue running, because we might've read only part
  of a message. PqCommReadingMsg acts somewhat similarly to critical sections
  in that if an error occurs while it's set, the error handler will force the
  connection to be terminated, as if the error was FATAL. It's not
  implemented by promoting ERROR to FATAL in elog.c, like ERROR is promoted
  to PANIC in critical sections, because we want to be able to use
  PG_TRY/CATCH to recover and regain protocol sync. pq_getmessage() takes
  advantage of that to prevent an OOM error from terminating the connection.

  To prevent unnecessary connection terminations, add a holdoff mechanism
  similar to HOLD/RESUME_INTERRUPTS() that can be used hold off query cancel
  interrupts, but still allow die interrupts. The rules on which interrupts
  are processed when are now a bit more complicated, so refactor
  ProcessInterrupts() and the calls to it in signal handlers so that the
  signal handlers always call it if ImmediateInterruptOK is set, and
  ProcessInterrupts() can decide to not do anything if the other conditions
  are not met.

  Reported by Emil Lenngren. Patch reviewed by Noah Misch and Andres Freund.
  Backpatch to all supported versions.

  Security: CVE-2015-0244
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 57ec87c6b8dcb5258aae414fbdbeaf6eaf09feb1
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 0c93924b1698a284fe49026b24d1b436e8a01722
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 3face5a8d9ffbb5d37b5c29949d4363bd64f7446
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 289592b23eef85b82034595b6261c7a6b0326139
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b8f0a57d13fce3c61f99f07077e07ccba0848e71
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 2488eff889f83d7d6411be9a6172ff69df3f0085
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 47ba0fbd796bb71652d1c73d38a0b4ca8de4a253
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: af9c5c074f7a0f6688351ef4e973707a26ccd1ea
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 69ba47d6f9866d1dad93c4d613d8c635f32c1c07
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: cd19848bd555223eb613c699a5f6360b4133f7fa
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 0a819b6f6239188ac9d6c9d7f463ff9c6ca9e4ec
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/0a819b6f6239188ac9d6c9d7f463ff9c6ca9e4ec
    reference_type: commit
    reference_id: 0a819b6f6239188ac9d6c9d7f463ff9c6ca9e4ec
  - url: https://github.com/postgres/postgres/tree/0c93924b1698a284fe49026b24d1b436e8a01722
    reference_type: commit
    reference_id: 0c93924b1698a284fe49026b24d1b436e8a01722
  - url: https://github.com/postgres/postgres/tree/2488eff889f83d7d6411be9a6172ff69df3f0085
    reference_type: commit
    reference_id: 2488eff889f83d7d6411be9a6172ff69df3f0085
  - url: https://github.com/postgres/postgres/tree/289592b23eef85b82034595b6261c7a6b0326139
    reference_type: commit
    reference_id: 289592b23eef85b82034595b6261c7a6b0326139
  - url: https://github.com/postgres/postgres/tree/2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b
    reference_type: commit
    reference_id: 2b3a8b20c2da9f39ffecae25ab7c66974fbc0d3b
  - url: https://github.com/postgres/postgres/tree/3face5a8d9ffbb5d37b5c29949d4363bd64f7446
    reference_type: commit
    reference_id: 3face5a8d9ffbb5d37b5c29949d4363bd64f7446
  - url: https://github.com/postgres/postgres/tree/47ba0fbd796bb71652d1c73d38a0b4ca8de4a253
    reference_type: commit
    reference_id: 47ba0fbd796bb71652d1c73d38a0b4ca8de4a253
  - url: https://github.com/postgres/postgres/tree/57ec87c6b8dcb5258aae414fbdbeaf6eaf09feb1
    reference_type: commit
    reference_id: 57ec87c6b8dcb5258aae414fbdbeaf6eaf09feb1
  - url: https://github.com/postgres/postgres/tree/69ba47d6f9866d1dad93c4d613d8c635f32c1c07
    reference_type: commit
    reference_id: 69ba47d6f9866d1dad93c4d613d8c635f32c1c07
  - url: https://github.com/postgres/postgres/tree/af9c5c074f7a0f6688351ef4e973707a26ccd1ea
    reference_type: commit
    reference_id: af9c5c074f7a0f6688351ef4e973707a26ccd1ea
  - url: https://github.com/postgres/postgres/tree/b8f0a57d13fce3c61f99f07077e07ccba0848e71
    reference_type: commit
    reference_id: b8f0a57d13fce3c61f99f07077e07ccba0848e71
  - url: https://github.com/postgres/postgres/tree/cd19848bd555223eb613c699a5f6360b4133f7fa
    reference_type: commit
    reference_id: cd19848bd555223eb613c699a5f6360b4133f7fa
