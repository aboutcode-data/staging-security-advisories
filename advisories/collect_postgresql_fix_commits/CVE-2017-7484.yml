advisory_id: CVE-2017-7484
datasource_id: collect_postgresql_fix_commits/CVE-2017-7484
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  533211ded37aed55c715e9e237209a3deef4dd8d:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  afe38fb6abb8ef364191201f577a5a638ba55509:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  415badc138189a6ecfe3b664dc900af741342258:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  7e86da539d18bc29377a3882b9945dfbeb375f9c:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  a85eddab23f17bce333d7d9481f528d7ba78285e:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  64f77c6a65cb6a0731e59acbfab1dd1663b1cdd3:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  22424953cded3f83f0382383773eaf36eb1abda9:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  1d9056f563f3dcef6296e252b60c1d5831e43be6:Allow access to child table statistics if user can read parent table.

  The fix for CVE-2017-7484 disallowed use of pg_statistic data for
  planning purposes if the user would not be able to select the associated
  column and a non-leakproof function is to be applied to the statistics
  values.  That turns out to disable use of pg_statistic data in some
  common cases involving inheritance/partitioning, where the user does
  have permission to select from the parent table that was actually named
  in the query, but not from a child table whose stats are needed.  Since,
  in non-corner cases, the user *can* select the child table's data via
  the parent, this restriction is not actually useful from a security
  standpoint.  Improve the logic so that we also check the permissions of
  the originally-named table, and allow access if select permission exists
  for that.

  When checking access to stats for a simple child column, we can map
  the child column number back to the parent, and perform this test
  exactly (including not allowing access if the child column isn't
  exposed by the parent).  For expression indexes, the current logic
  just insists on whole-table select access, and this patch allows
  access if the user can select the whole parent table.  In principle,
  if the child table has extra columns, this might allow access to
  stats on columns the user can't read.  In practice, it's unlikely
  that the planner is going to do any stats calculations involving
  expressions that are not visible to the query, so we'll ignore that
  fine point for now.  Perhaps someday we'll improve that logic to
  detect exactly which columns are used by an expression index ...
  but today is not that day.

  Back-patch to v11.  The issue was created in 9.2 and up by the
  CVE-2017-7484 fix, but this patch depends on the append_rel_array[]
  planner data structure which only exists in v11 and up.  In
  practice the issue is most urgent with partitioned tables, so
  fixing v11 and later should satisfy much of the practical need.

  Dilip Kumar and Amit Langote, with some kibitzing by me

  Discussion: https://postgr.es/m/3876.1531261875@sss.pgh.pa.us
  1d9056f563f3dcef6296e252b60c1d5831e43be6:Allow access to child table statistics if user can read parent table.

  The fix for CVE-2017-7484 disallowed use of pg_statistic data for
  planning purposes if the user would not be able to select the associated
  column and a non-leakproof function is to be applied to the statistics
  values.  That turns out to disable use of pg_statistic data in some
  common cases involving inheritance/partitioning, where the user does
  have permission to select from the parent table that was actually named
  in the query, but not from a child table whose stats are needed.  Since,
  in non-corner cases, the user *can* select the child table's data via
  the parent, this restriction is not actually useful from a security
  standpoint.  Improve the logic so that we also check the permissions of
  the originally-named table, and allow access if select permission exists
  for that.

  When checking access to stats for a simple child column, we can map
  the child column number back to the parent, and perform this test
  exactly (including not allowing access if the child column isn't
  exposed by the parent).  For expression indexes, the current logic
  just insists on whole-table select access, and this patch allows
  access if the user can select the whole parent table.  In principle,
  if the child table has extra columns, this might allow access to
  stats on columns the user can't read.  In practice, it's unlikely
  that the planner is going to do any stats calculations involving
  expressions that are not visible to the query, so we'll ignore that
  fine point for now.  Perhaps someday we'll improve that logic to
  detect exactly which columns are used by an expression index ...
  but today is not that day.

  Back-patch to v11.  The issue was created in 9.2 and up by the
  CVE-2017-7484 fix, but this patch depends on the append_rel_array[]
  planner data structure which only exists in v11 and up.  In
  practice the issue is most urgent with partitioned tables, so
  fixing v11 and later should satisfy much of the practical need.

  Dilip Kumar and Amit Langote, with some kibitzing by me

  Discussion: https://postgr.es/m/3876.1531261875@sss.pgh.pa.us
  21a4edd1281de5efd09f1cf5c6073af14a2de409:Allow access to child table statistics if user can read parent table.

  The fix for CVE-2017-7484 disallowed use of pg_statistic data for
  planning purposes if the user would not be able to select the associated
  column and a non-leakproof function is to be applied to the statistics
  values.  That turns out to disable use of pg_statistic data in some
  common cases involving inheritance/partitioning, where the user does
  have permission to select from the parent table that was actually named
  in the query, but not from a child table whose stats are needed.  Since,
  in non-corner cases, the user *can* select the child table's data via
  the parent, this restriction is not actually useful from a security
  standpoint.  Improve the logic so that we also check the permissions of
  the originally-named table, and allow access if select permission exists
  for that.

  When checking access to stats for a simple child column, we can map
  the child column number back to the parent, and perform this test
  exactly (including not allowing access if the child column isn't
  exposed by the parent).  For expression indexes, the current logic
  just insists on whole-table select access, and this patch allows
  access if the user can select the whole parent table.  In principle,
  if the child table has extra columns, this might allow access to
  stats on columns the user can't read.  In practice, it's unlikely
  that the planner is going to do any stats calculations involving
  expressions that are not visible to the query, so we'll ignore that
  fine point for now.  Perhaps someday we'll improve that logic to
  detect exactly which columns are used by an expression index ...
  but today is not that day.

  Back-patch to v11.  The issue was created in 9.2 and up by the
  CVE-2017-7484 fix, but this patch depends on the append_rel_array[]
  planner data structure which only exists in v11 and up.  In
  practice the issue is most urgent with partitioned tables, so
  fixing v11 and later should satisfy much of the practical need.

  Dilip Kumar and Amit Langote, with some kibitzing by me

  Discussion: https://postgr.es/m/3876.1531261875@sss.pgh.pa.us
  21a4edd1281de5efd09f1cf5c6073af14a2de409:Allow access to child table statistics if user can read parent table.

  The fix for CVE-2017-7484 disallowed use of pg_statistic data for
  planning purposes if the user would not be able to select the associated
  column and a non-leakproof function is to be applied to the statistics
  values.  That turns out to disable use of pg_statistic data in some
  common cases involving inheritance/partitioning, where the user does
  have permission to select from the parent table that was actually named
  in the query, but not from a child table whose stats are needed.  Since,
  in non-corner cases, the user *can* select the child table's data via
  the parent, this restriction is not actually useful from a security
  standpoint.  Improve the logic so that we also check the permissions of
  the originally-named table, and allow access if select permission exists
  for that.

  When checking access to stats for a simple child column, we can map
  the child column number back to the parent, and perform this test
  exactly (including not allowing access if the child column isn't
  exposed by the parent).  For expression indexes, the current logic
  just insists on whole-table select access, and this patch allows
  access if the user can select the whole parent table.  In principle,
  if the child table has extra columns, this might allow access to
  stats on columns the user can't read.  In practice, it's unlikely
  that the planner is going to do any stats calculations involving
  expressions that are not visible to the query, so we'll ignore that
  fine point for now.  Perhaps someday we'll improve that logic to
  detect exactly which columns are used by an expression index ...
  but today is not that day.

  Back-patch to v11.  The issue was created in 9.2 and up by the
  CVE-2017-7484 fix, but this patch depends on the append_rel_array[]
  planner data structure which only exists in v11 and up.  In
  practice the issue is most urgent with partitioned tables, so
  fixing v11 and later should satisfy much of the practical need.

  Dilip Kumar and Amit Langote, with some kibitzing by me

  Discussion: https://postgr.es/m/3876.1531261875@sss.pgh.pa.us
  553d2ec2710be5ae304c40134643c8f6d754af67:Allow access to child table statistics if user can read parent table.

  The fix for CVE-2017-7484 disallowed use of pg_statistic data for
  planning purposes if the user would not be able to select the associated
  column and a non-leakproof function is to be applied to the statistics
  values.  That turns out to disable use of pg_statistic data in some
  common cases involving inheritance/partitioning, where the user does
  have permission to select from the parent table that was actually named
  in the query, but not from a child table whose stats are needed.  Since,
  in non-corner cases, the user *can* select the child table's data via
  the parent, this restriction is not actually useful from a security
  standpoint.  Improve the logic so that we also check the permissions of
  the originally-named table, and allow access if select permission exists
  for that.

  When checking access to stats for a simple child column, we can map
  the child column number back to the parent, and perform this test
  exactly (including not allowing access if the child column isn't
  exposed by the parent).  For expression indexes, the current logic
  just insists on whole-table select access, and this patch allows
  access if the user can select the whole parent table.  In principle,
  if the child table has extra columns, this might allow access to
  stats on columns the user can't read.  In practice, it's unlikely
  that the planner is going to do any stats calculations involving
  expressions that are not visible to the query, so we'll ignore that
  fine point for now.  Perhaps someday we'll improve that logic to
  detect exactly which columns are used by an expression index ...
  but today is not that day.

  Back-patch to v11.  The issue was created in 9.2 and up by the
  CVE-2017-7484 fix, but this patch depends on the append_rel_array[]
  planner data structure which only exists in v11 and up.  In
  practice the issue is most urgent with partitioned tables, so
  fixing v11 and later should satisfy much of the practical need.

  Dilip Kumar and Amit Langote, with some kibitzing by me

  Discussion: https://postgr.es/m/3876.1531261875@sss.pgh.pa.us
  553d2ec2710be5ae304c40134643c8f6d754af67:Allow access to child table statistics if user can read parent table.

  The fix for CVE-2017-7484 disallowed use of pg_statistic data for
  planning purposes if the user would not be able to select the associated
  column and a non-leakproof function is to be applied to the statistics
  values.  That turns out to disable use of pg_statistic data in some
  common cases involving inheritance/partitioning, where the user does
  have permission to select from the parent table that was actually named
  in the query, but not from a child table whose stats are needed.  Since,
  in non-corner cases, the user *can* select the child table's data via
  the parent, this restriction is not actually useful from a security
  standpoint.  Improve the logic so that we also check the permissions of
  the originally-named table, and allow access if select permission exists
  for that.

  When checking access to stats for a simple child column, we can map
  the child column number back to the parent, and perform this test
  exactly (including not allowing access if the child column isn't
  exposed by the parent).  For expression indexes, the current logic
  just insists on whole-table select access, and this patch allows
  access if the user can select the whole parent table.  In principle,
  if the child table has extra columns, this might allow access to
  stats on columns the user can't read.  In practice, it's unlikely
  that the planner is going to do any stats calculations involving
  expressions that are not visible to the query, so we'll ignore that
  fine point for now.  Perhaps someday we'll improve that logic to
  detect exactly which columns are used by an expression index ...
  but today is not that day.

  Back-patch to v11.  The issue was created in 9.2 and up by the
  CVE-2017-7484 fix, but this patch depends on the append_rel_array[]
  planner data structure which only exists in v11 and up.  In
  practice the issue is most urgent with partitioned tables, so
  fixing v11 and later should satisfy much of the practical need.

  Dilip Kumar and Amit Langote, with some kibitzing by me

  Discussion: https://postgr.es/m/3876.1531261875@sss.pgh.pa.us
  da0759600664439238fe25fa84b1f0059bfdcdd6:Further patch rangetypes_selfuncs.c's statistics slot management.

  Values in a STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM slot are float8,
  not of the type of the column the statistics are for.

  This bug is at least partly the fault of sloppy specification comments
  for get_attstatsslot()/free_attstatsslot(): the type OID they want is that
  of the stavalues entries, not of the underlying column.  (I double-checked
  other callers and they seem to get this right.)  Adjust the comments to be
  more correct.

  Per buildfarm.

  Security: CVE-2017-7484
  417c9ce2695ec0f716eeff30013979587313bdc1:Further patch rangetypes_selfuncs.c's statistics slot management.

  Values in a STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM slot are float8,
  not of the type of the column the statistics are for.

  This bug is at least partly the fault of sloppy specification comments
  for get_attstatsslot()/free_attstatsslot(): the type OID they want is that
  of the stavalues entries, not of the underlying column.  (I double-checked
  other callers and they seem to get this right.)  Adjust the comments to be
  more correct.

  Per buildfarm.

  Security: CVE-2017-7484
  f793effdc763381f61d592c9ec8ee8657167b7b9:Further patch rangetypes_selfuncs.c's statistics slot management.

  Values in a STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM slot are float8,
  not of the type of the column the statistics are for.

  This bug is at least partly the fault of sloppy specification comments
  for get_attstatsslot()/free_attstatsslot(): the type OID they want is that
  of the stavalues entries, not of the underlying column.  (I double-checked
  other callers and they seem to get this right.)  Adjust the comments to be
  more correct.

  Per buildfarm.

  Security: CVE-2017-7484
  4509b4eb188beeea5c74a52f238127d323093113:Further patch rangetypes_selfuncs.c's statistics slot management.

  Values in a STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM slot are float8,
  not of the type of the column the statistics are for.

  This bug is at least partly the fault of sloppy specification comments
  for get_attstatsslot()/free_attstatsslot(): the type OID they want is that
  of the stavalues entries, not of the underlying column.  (I double-checked
  other callers and they seem to get this right.)  Adjust the comments to be
  more correct.

  Per buildfarm.

  Security: CVE-2017-7484
  935e77d527a018b652f247c7374c558871210db6:Further patch rangetypes_selfuncs.c's statistics slot management.

  Values in a STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM slot are float8,
  not of the type of the column the statistics are for.

  This bug is at least partly the fault of sloppy specification comments
  for get_attstatsslot()/free_attstatsslot(): the type OID they want is that
  of the stavalues entries, not of the underlying column.  (I double-checked
  other callers and they seem to get this right.)  Adjust the comments to be
  more correct.

  Per buildfarm.

  Security: CVE-2017-7484
  89cd44cc50d3d82dc6f001ac357bedd96b8387d8:Last-minute updates for release notes.

  Security: CVE-2017-7484, CVE-2017-7485, CVE-2017-7486
  73b1aee886a211b0438aa3fe4bcded7fd671c1e4:Last-minute updates for release notes.

  Security: CVE-2017-7484, CVE-2017-7485, CVE-2017-7486
  abba57b9af951242054bd9cc5ca84764c18649e6:Last-minute updates for release notes.

  Security: CVE-2017-7484, CVE-2017-7485, CVE-2017-7486
  7603952e751a3b27adae16192b59ab09f0d0ba72:Last-minute updates for release notes.

  Security: CVE-2017-7484, CVE-2017-7485, CVE-2017-7486
  2d5e7b4a912d55d90c01732d318b94e4ae47027b:Last-minute updates for release notes.

  Security: CVE-2017-7484, CVE-2017-7485, CVE-2017-7486
  c89d2d0204f25e556e94dabd0fd5174cf6963b1d:Last-minute updates for release notes.

  Security: CVE-2017-7484, CVE-2017-7485, CVE-2017-7486
  703da179505e8bac2aa8ebdc600402338cc0f226:Fix possibly-uninitialized variable.

  Oversight in e2d4ef8de et al (my fault not Peter's).  Per buildfarm.

  Security: CVE-2017-7484
  d3f3f95680701fb5f5bd8df603ec57d66b5b3d1b:Fix possibly-uninitialized variable.

  Oversight in e2d4ef8de et al (my fault not Peter's).  Per buildfarm.

  Security: CVE-2017-7484
  a199582ef6d56786cd21aab55bf8011a478ed2d4:Fix possibly-uninitialized variable.

  Oversight in e2d4ef8de et al (my fault not Peter's).  Per buildfarm.

  Security: CVE-2017-7484
  cad15943225adbcadea51602b38b04d71d1183d2:Fix possibly-uninitialized variable.

  Oversight in e2d4ef8de et al (my fault not Peter's).  Per buildfarm.

  Security: CVE-2017-7484
  b6576e5914d042bfad1c8629fe199f59b036c342:Fix possibly-uninitialized variable.

  Oversight in e2d4ef8de et al (my fault not Peter's).  Per buildfarm.

  Security: CVE-2017-7484
  e2d4ef8de869c57e3bf270a30c12d48c2ce4e00c:Add security checks to selectivity estimation functions

  Some selectivity estimation functions run user-supplied operators over
  data obtained from pg_statistic without security checks, which allows
  those operators to leak pg_statistic data without having privileges on
  the underlying tables.  Fix by checking that one of the following is
  satisfied: (1) the user has table or column privileges on the table
  underlying the pg_statistic data, or (2) the function implementing the
  user-supplied operator is leak-proof.  If neither is satisfied, planning
  will proceed as if there are no statistics available.

  At least one of these is satisfied in most cases in practice.  The only
  situations that are negatively impacted are user-defined or
  not-leak-proof operators on a security-barrier view.

  Reported-by: Robert Haas <robertmhaas@gmail.com>
  Author: Peter Eisentraut <peter_e@gmx.net>
  Author: Tom Lane <tgl@sss.pgh.pa.us>

  Security: CVE-2017-7484
  d035c1b970fe948c10773315a2f022204bc45df6:Add security checks to selectivity estimation functions

  Some selectivity estimation functions run user-supplied operators over
  data obtained from pg_statistic without security checks, which allows
  those operators to leak pg_statistic data without having privileges on
  the underlying tables.  Fix by checking that one of the following is
  satisfied: (1) the user has table or column privileges on the table
  underlying the pg_statistic data, or (2) the function implementing the
  user-supplied operator is leak-proof.  If neither is satisfied, planning
  will proceed as if there are no statistics available.

  At least one of these is satisfied in most cases in practice.  The only
  situations that are negatively impacted are user-defined or
  not-leak-proof operators on a security-barrier view.

  Reported-by: Robert Haas <robertmhaas@gmail.com>
  Author: Peter Eisentraut <peter_e@gmx.net>
  Author: Tom Lane <tgl@sss.pgh.pa.us>

  Security: CVE-2017-7484
  4f1b2089a1b8f82cbd28b4cd8d0e1e9f1486d2b6:Add security checks to selectivity estimation functions

  Some selectivity estimation functions run user-supplied operators over
  data obtained from pg_statistic without security checks, which allows
  those operators to leak pg_statistic data without having privileges on
  the underlying tables.  Fix by checking that one of the following is
  satisfied: (1) the user has table or column privileges on the table
  underlying the pg_statistic data, or (2) the function implementing the
  user-supplied operator is leak-proof.  If neither is satisfied, planning
  will proceed as if there are no statistics available.

  At least one of these is satisfied in most cases in practice.  The only
  situations that are negatively impacted are user-defined or
  not-leak-proof operators on a security-barrier view.

  Reported-by: Robert Haas <robertmhaas@gmail.com>
  Author: Peter Eisentraut <peter_e@gmx.net>
  Author: Tom Lane <tgl@sss.pgh.pa.us>

  Security: CVE-2017-7484
  3e5ea1f9b21c94acce01d7a5bf5bfcf36e670b0a:Add security checks to selectivity estimation functions

  Some selectivity estimation functions run user-supplied operators over
  data obtained from pg_statistic without security checks, which allows
  those operators to leak pg_statistic data without having privileges on
  the underlying tables.  Fix by checking that one of the following is
  satisfied: (1) the user has table or column privileges on the table
  underlying the pg_statistic data, or (2) the function implementing the
  user-supplied operator is leak-proof.  If neither is satisfied, planning
  will proceed as if there are no statistics available.

  At least one of these is satisfied in most cases in practice.  The only
  situations that are negatively impacted are user-defined or
  not-leak-proof operators on a security-barrier view.

  Reported-by: Robert Haas <robertmhaas@gmail.com>
  Author: Peter Eisentraut <peter_e@gmx.net>
  Author: Tom Lane <tgl@sss.pgh.pa.us>

  Security: CVE-2017-7484
  d45cd7c0edb5364c525f2128c837850c93138b27:Add security checks to selectivity estimation functions

  Some selectivity estimation functions run user-supplied operators over
  data obtained from pg_statistic without security checks, which allows
  those operators to leak pg_statistic data without having privileges on
  the underlying tables.  Fix by checking that one of the following is
  satisfied: (1) the user has table or column privileges on the table
  underlying the pg_statistic data, or (2) the function implementing the
  user-supplied operator is leak-proof.  If neither is satisfied, planning
  will proceed as if there are no statistics available.

  At least one of these is satisfied in most cases in practice.  The only
  situations that are negatively impacted are user-defined or
  not-leak-proof operators on a security-barrier view.

  Reported-by: Robert Haas <robertmhaas@gmail.com>
  Author: Peter Eisentraut <peter_e@gmx.net>
  Author: Tom Lane <tgl@sss.pgh.pa.us>

  Security: CVE-2017-7484
  c33c42362256382ed398df9dcda559cd547c68a7:Add security checks to selectivity estimation functions

  Some selectivity estimation functions run user-supplied operators over
  data obtained from pg_statistic without security checks, which allows
  those operators to leak pg_statistic data without having privileges on
  the underlying tables.  Fix by checking that one of the following is
  satisfied: (1) the user has table or column privileges on the table
  underlying the pg_statistic data, or (2) the function implementing the
  user-supplied operator is leak-proof.  If neither is satisfied, planning
  will proceed as if there are no statistics available.

  At least one of these is satisfied in most cases in practice.  The only
  situations that are negatively impacted are user-defined or
  not-leak-proof operators on a security-barrier view.

  Reported-by: Robert Haas <robertmhaas@gmail.com>
  Author: Peter Eisentraut <peter_e@gmx.net>
  Author: Tom Lane <tgl@sss.pgh.pa.us>

  Security: CVE-2017-7484
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 553d2ec2710be5ae304c40134643c8f6d754af67
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: da0759600664439238fe25fa84b1f0059bfdcdd6
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: c33c42362256382ed398df9dcda559cd547c68a7
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: c89d2d0204f25e556e94dabd0fd5174cf6963b1d
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 2d5e7b4a912d55d90c01732d318b94e4ae47027b
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: f793effdc763381f61d592c9ec8ee8657167b7b9
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 1d9056f563f3dcef6296e252b60c1d5831e43be6
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 703da179505e8bac2aa8ebdc600402338cc0f226
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 73b1aee886a211b0438aa3fe4bcded7fd671c1e4
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a199582ef6d56786cd21aab55bf8011a478ed2d4
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 22424953cded3f83f0382383773eaf36eb1abda9
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 3e5ea1f9b21c94acce01d7a5bf5bfcf36e670b0a
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 64f77c6a65cb6a0731e59acbfab1dd1663b1cdd3
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 417c9ce2695ec0f716eeff30013979587313bdc1
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d45cd7c0edb5364c525f2128c837850c93138b27
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d035c1b970fe948c10773315a2f022204bc45df6
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 415badc138189a6ecfe3b664dc900af741342258
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 21a4edd1281de5efd09f1cf5c6073af14a2de409
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 4509b4eb188beeea5c74a52f238127d323093113
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: abba57b9af951242054bd9cc5ca84764c18649e6
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d3f3f95680701fb5f5bd8df603ec57d66b5b3d1b
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a85eddab23f17bce333d7d9481f528d7ba78285e
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: cad15943225adbcadea51602b38b04d71d1183d2
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 7e86da539d18bc29377a3882b9945dfbeb375f9c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 89cd44cc50d3d82dc6f001ac357bedd96b8387d8
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b6576e5914d042bfad1c8629fe199f59b036c342
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 4f1b2089a1b8f82cbd28b4cd8d0e1e9f1486d2b6
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: afe38fb6abb8ef364191201f577a5a638ba55509
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 935e77d527a018b652f247c7374c558871210db6
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 533211ded37aed55c715e9e237209a3deef4dd8d
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e2d4ef8de869c57e3bf270a30c12d48c2ce4e00c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 7603952e751a3b27adae16192b59ab09f0d0ba72
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/1d9056f563f3dcef6296e252b60c1d5831e43be6
    reference_type: commit
    reference_id: 1d9056f563f3dcef6296e252b60c1d5831e43be6
  - url: https://github.com/postgres/postgres/tree/21a4edd1281de5efd09f1cf5c6073af14a2de409
    reference_type: commit
    reference_id: 21a4edd1281de5efd09f1cf5c6073af14a2de409
  - url: https://github.com/postgres/postgres/tree/22424953cded3f83f0382383773eaf36eb1abda9
    reference_type: commit
    reference_id: 22424953cded3f83f0382383773eaf36eb1abda9
  - url: https://github.com/postgres/postgres/tree/2d5e7b4a912d55d90c01732d318b94e4ae47027b
    reference_type: commit
    reference_id: 2d5e7b4a912d55d90c01732d318b94e4ae47027b
  - url: https://github.com/postgres/postgres/tree/3e5ea1f9b21c94acce01d7a5bf5bfcf36e670b0a
    reference_type: commit
    reference_id: 3e5ea1f9b21c94acce01d7a5bf5bfcf36e670b0a
  - url: https://github.com/postgres/postgres/tree/415badc138189a6ecfe3b664dc900af741342258
    reference_type: commit
    reference_id: 415badc138189a6ecfe3b664dc900af741342258
  - url: https://github.com/postgres/postgres/tree/417c9ce2695ec0f716eeff30013979587313bdc1
    reference_type: commit
    reference_id: 417c9ce2695ec0f716eeff30013979587313bdc1
  - url: https://github.com/postgres/postgres/tree/4509b4eb188beeea5c74a52f238127d323093113
    reference_type: commit
    reference_id: 4509b4eb188beeea5c74a52f238127d323093113
  - url: https://github.com/postgres/postgres/tree/4f1b2089a1b8f82cbd28b4cd8d0e1e9f1486d2b6
    reference_type: commit
    reference_id: 4f1b2089a1b8f82cbd28b4cd8d0e1e9f1486d2b6
  - url: https://github.com/postgres/postgres/tree/533211ded37aed55c715e9e237209a3deef4dd8d
    reference_type: commit
    reference_id: 533211ded37aed55c715e9e237209a3deef4dd8d
  - url: https://github.com/postgres/postgres/tree/553d2ec2710be5ae304c40134643c8f6d754af67
    reference_type: commit
    reference_id: 553d2ec2710be5ae304c40134643c8f6d754af67
  - url: https://github.com/postgres/postgres/tree/64f77c6a65cb6a0731e59acbfab1dd1663b1cdd3
    reference_type: commit
    reference_id: 64f77c6a65cb6a0731e59acbfab1dd1663b1cdd3
  - url: https://github.com/postgres/postgres/tree/703da179505e8bac2aa8ebdc600402338cc0f226
    reference_type: commit
    reference_id: 703da179505e8bac2aa8ebdc600402338cc0f226
  - url: https://github.com/postgres/postgres/tree/73b1aee886a211b0438aa3fe4bcded7fd671c1e4
    reference_type: commit
    reference_id: 73b1aee886a211b0438aa3fe4bcded7fd671c1e4
  - url: https://github.com/postgres/postgres/tree/7603952e751a3b27adae16192b59ab09f0d0ba72
    reference_type: commit
    reference_id: 7603952e751a3b27adae16192b59ab09f0d0ba72
  - url: https://github.com/postgres/postgres/tree/7e86da539d18bc29377a3882b9945dfbeb375f9c
    reference_type: commit
    reference_id: 7e86da539d18bc29377a3882b9945dfbeb375f9c
  - url: https://github.com/postgres/postgres/tree/89cd44cc50d3d82dc6f001ac357bedd96b8387d8
    reference_type: commit
    reference_id: 89cd44cc50d3d82dc6f001ac357bedd96b8387d8
  - url: https://github.com/postgres/postgres/tree/935e77d527a018b652f247c7374c558871210db6
    reference_type: commit
    reference_id: 935e77d527a018b652f247c7374c558871210db6
  - url: https://github.com/postgres/postgres/tree/a199582ef6d56786cd21aab55bf8011a478ed2d4
    reference_type: commit
    reference_id: a199582ef6d56786cd21aab55bf8011a478ed2d4
  - url: https://github.com/postgres/postgres/tree/a85eddab23f17bce333d7d9481f528d7ba78285e
    reference_type: commit
    reference_id: a85eddab23f17bce333d7d9481f528d7ba78285e
  - url: https://github.com/postgres/postgres/tree/abba57b9af951242054bd9cc5ca84764c18649e6
    reference_type: commit
    reference_id: abba57b9af951242054bd9cc5ca84764c18649e6
  - url: https://github.com/postgres/postgres/tree/afe38fb6abb8ef364191201f577a5a638ba55509
    reference_type: commit
    reference_id: afe38fb6abb8ef364191201f577a5a638ba55509
  - url: https://github.com/postgres/postgres/tree/b6576e5914d042bfad1c8629fe199f59b036c342
    reference_type: commit
    reference_id: b6576e5914d042bfad1c8629fe199f59b036c342
  - url: https://github.com/postgres/postgres/tree/c33c42362256382ed398df9dcda559cd547c68a7
    reference_type: commit
    reference_id: c33c42362256382ed398df9dcda559cd547c68a7
  - url: https://github.com/postgres/postgres/tree/c89d2d0204f25e556e94dabd0fd5174cf6963b1d
    reference_type: commit
    reference_id: c89d2d0204f25e556e94dabd0fd5174cf6963b1d
  - url: https://github.com/postgres/postgres/tree/cad15943225adbcadea51602b38b04d71d1183d2
    reference_type: commit
    reference_id: cad15943225adbcadea51602b38b04d71d1183d2
  - url: https://github.com/postgres/postgres/tree/d035c1b970fe948c10773315a2f022204bc45df6
    reference_type: commit
    reference_id: d035c1b970fe948c10773315a2f022204bc45df6
  - url: https://github.com/postgres/postgres/tree/d3f3f95680701fb5f5bd8df603ec57d66b5b3d1b
    reference_type: commit
    reference_id: d3f3f95680701fb5f5bd8df603ec57d66b5b3d1b
  - url: https://github.com/postgres/postgres/tree/d45cd7c0edb5364c525f2128c837850c93138b27
    reference_type: commit
    reference_id: d45cd7c0edb5364c525f2128c837850c93138b27
  - url: https://github.com/postgres/postgres/tree/da0759600664439238fe25fa84b1f0059bfdcdd6
    reference_type: commit
    reference_id: da0759600664439238fe25fa84b1f0059bfdcdd6
  - url: https://github.com/postgres/postgres/tree/e2d4ef8de869c57e3bf270a30c12d48c2ce4e00c
    reference_type: commit
    reference_id: e2d4ef8de869c57e3bf270a30c12d48c2ce4e00c
  - url: https://github.com/postgres/postgres/tree/f793effdc763381f61d592c9ec8ee8657167b7b9
    reference_type: commit
    reference_id: f793effdc763381f61d592c9ec8ee8657167b7b9
