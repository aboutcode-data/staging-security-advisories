advisory_id: CVE-2007-4772
datasource_id: collect_postgresql_fix_commits/CVE-2007-4772
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  1bb0fbca39b447d1ce6da5f6bcf9f468a6346a08:Improve performance of pullback/pushfwd in regular-expression compiler.

  The previous coding would create a new intermediate state every time it
  wanted to interchange the ordering of two constraint arcs.  Certain regex
  features such as \Y can generate large numbers of parallel constraint arcs,
  and if we needed to reorder the results of that, we created unreasonable
  numbers of intermediate states.  To improve matters, keep a list of
  already-created intermediate states associated with the state currently
  being considered by the outer loop; we can re-use such states to place all
  the new arcs leading to the same destination or source.

  I also took the trouble to redefine push() and pull() to have a less risky
  API: they no longer delete any state or arc that the caller might possibly
  have a pointer to, except for the specifically-passed constraint arc.
  This reduces the risk of re-introducing the same type of error seen in
  the failed patch for CVE-2007-4772.

  Back-patch to all supported branches.
  0889e1857f07dea110e07fd7634af1ea773df951:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  0889e1857f07dea110e07fd7634af1ea773df951:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  6a7153661d66a00a03ff117c24fa49480b0699c8:Improve performance of pullback/pushfwd in regular-expression compiler.

  The previous coding would create a new intermediate state every time it
  wanted to interchange the ordering of two constraint arcs.  Certain regex
  features such as \Y can generate large numbers of parallel constraint arcs,
  and if we needed to reorder the results of that, we created unreasonable
  numbers of intermediate states.  To improve matters, keep a list of
  already-created intermediate states associated with the state currently
  being considered by the outer loop; we can re-use such states to place all
  the new arcs leading to the same destination or source.

  I also took the trouble to redefine push() and pull() to have a less risky
  API: they no longer delete any state or arc that the caller might possibly
  have a pointer to, except for the specifically-passed constraint arc.
  This reduces the risk of re-introducing the same type of error seen in
  the failed patch for CVE-2007-4772.

  Back-patch to all supported branches.
  48789c5d23a7f382e3cb721547d5e0af7aaa4585:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  48789c5d23a7f382e3cb721547d5e0af7aaa4585:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  067f96fe3a70755b225f03cd49f51bd4920a6d91:Improve performance of pullback/pushfwd in regular-expression compiler.

  The previous coding would create a new intermediate state every time it
  wanted to interchange the ordering of two constraint arcs.  Certain regex
  features such as \Y can generate large numbers of parallel constraint arcs,
  and if we needed to reorder the results of that, we created unreasonable
  numbers of intermediate states.  To improve matters, keep a list of
  already-created intermediate states associated with the state currently
  being considered by the outer loop; we can re-use such states to place all
  the new arcs leading to the same destination or source.

  I also took the trouble to redefine push() and pull() to have a less risky
  API: they no longer delete any state or arc that the caller might possibly
  have a pointer to, except for the specifically-passed constraint arc.
  This reduces the risk of re-introducing the same type of error seen in
  the failed patch for CVE-2007-4772.

  Back-patch to all supported branches.
  a257b808a507649432246b2bd9733e733f5b6332:Improve performance of pullback/pushfwd in regular-expression compiler.

  The previous coding would create a new intermediate state every time it
  wanted to interchange the ordering of two constraint arcs.  Certain regex
  features such as \Y can generate large numbers of parallel constraint arcs,
  and if we needed to reorder the results of that, we created unreasonable
  numbers of intermediate states.  To improve matters, keep a list of
  already-created intermediate states associated with the state currently
  being considered by the outer loop; we can re-use such states to place all
  the new arcs leading to the same destination or source.

  I also took the trouble to redefine push() and pull() to have a less risky
  API: they no longer delete any state or arc that the caller might possibly
  have a pointer to, except for the specifically-passed constraint arc.
  This reduces the risk of re-introducing the same type of error seen in
  the failed patch for CVE-2007-4772.

  Back-patch to all supported branches.
  2a8d6e4d06d6ea2e1323aeab79bbb867d0f816c5:Improve performance of pullback/pushfwd in regular-expression compiler.

  The previous coding would create a new intermediate state every time it
  wanted to interchange the ordering of two constraint arcs.  Certain regex
  features such as \Y can generate large numbers of parallel constraint arcs,
  and if we needed to reorder the results of that, we created unreasonable
  numbers of intermediate states.  To improve matters, keep a list of
  already-created intermediate states associated with the state currently
  being considered by the outer loop; we can re-use such states to place all
  the new arcs leading to the same destination or source.

  I also took the trouble to redefine push() and pull() to have a less risky
  API: they no longer delete any state or arc that the caller might possibly
  have a pointer to, except for the specifically-passed constraint arc.
  This reduces the risk of re-introducing the same type of error seen in
  the failed patch for CVE-2007-4772.

  Back-patch to all supported branches.
  9774fda86866fb12c8d690cb754e3981dc45efcd:Improve performance of pullback/pushfwd in regular-expression compiler.

  The previous coding would create a new intermediate state every time it
  wanted to interchange the ordering of two constraint arcs.  Certain regex
  features such as \Y can generate large numbers of parallel constraint arcs,
  and if we needed to reorder the results of that, we created unreasonable
  numbers of intermediate states.  To improve matters, keep a list of
  already-created intermediate states associated with the state currently
  being considered by the outer loop; we can re-use such states to place all
  the new arcs leading to the same destination or source.

  I also took the trouble to redefine push() and pull() to have a less risky
  API: they no longer delete any state or arc that the caller might possibly
  have a pointer to, except for the specifically-passed constraint arc.
  This reduces the risk of re-introducing the same type of error seen in
  the failed patch for CVE-2007-4772.

  Back-patch to all supported branches.
  d394f12c0c5576ac5a2f43da817074251abefed7:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  d394f12c0c5576ac5a2f43da817074251abefed7:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  83c34825e5b02880bdad2afdba7861590abe7fe7:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  83c34825e5b02880bdad2afdba7861590abe7fe7:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  6e4dda79633c978e73b2bad7ba25db0661d9204e:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  6e4dda79633c978e73b2bad7ba25db0661d9204e:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  b6eb5fc40ed60dc0c58bc52356ab5b3679f74d0d:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  b6eb5fc40ed60dc0c58bc52356ab5b3679f74d0d:Fix regular-expression compiler to handle loops of constraint arcs.

  It's possible to construct regular expressions that contain loops of
  constraint arcs (that is, ^ $ AHEAD BEHIND or LACON arcs).  There's no use
  in fully traversing such a loop at execution, since you'd just end up in
  the same NFA state without having consumed any input.  Worse, such a loop
  leads to infinite looping in the pullback/pushfwd stage of compilation,
  because we keep pushing or pulling the same constraints around the loop
  in a vain attempt to move them to the pre or post state.  Such looping was
  previously recognized in CVE-2007-4772; but the fix only handled the case
  of trivial single-state loops (that is, a constraint arc leading back to
  its source state) ... and not only that, it was incorrect even for that
  case, because it broke the admittedly-not-very-clearly-stated API contract
  of the pull() and push() subroutines.  The first two regression test cases
  added by this commit exhibit patterns that result in assertion failures
  because of that (though there seem to be no ill effects in non-assert
  builds).  The other new test cases exhibit multi-state constraint loops;
  in an unpatched build they will run until the NFA state-count limit is
  exceeded.

  To fix, remove the code added for CVE-2007-4772, and instead create a
  general-purpose constraint-loop-breaking phase of regex compilation that
  executes before we do pullback/pushfwd.  Since we never need to traverse
  a constraint loop fully, we can just break the loop at any chosen spot,
  if we add clone states that can replicate any sequence of arc transitions
  that would've traversed just part of the loop.

  Also add some commentary clarifying why we have to have all these
  machinations in the first place.

  This class of problems has been known for some time --- we had a report
  from Marc Mamin about two years ago, for example, and there are related
  complaints in the Tcl bug tracker.  I had discussed a fix of this kind
  off-list with Henry Spencer, but didn't get around to doing something
  about it until the issue was rediscovered by Greg Stark recently.

  Back-patch to all supported branches.
  9d4269f087d94c868d4da72d14bdf89617b0246c:Stamp release 7.3.21.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  56a2a4176389abdba65adf063fbfacf853a20132:Stamp release 7.4.19.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  231967907d66a89b456da70d90751db9b8034433:Stamp release 8.0.15.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  d419ce456838ad1d2257ff24ef3f081718a51985:Stamp release 8.1.11.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  e29972bb56d9cb6f3c514d37baec70cd3cc57a89:Stamp release 8.2.6.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  2bf121e40b998f0b3aacd163b5b0da0a17bb99e8:Stamp release 8.3RC1.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  d66dcb144a3a5b8fd5cc76018bdbee2ef9f21f5f:Update release notes for security releases.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  63ee91fc451f11422371baec7e6041bd77cc414e:Update release notes for security releases.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  b161e26de6546080eb53f2bcc4ae4156e2101046:Update release notes for security releases.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  bf4d342f8ea79699d5fa87eea50cfb042f2be2ae:Update release notes for security releases.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  f3c52c64e82dbe350264d3e1b4f77de39abf0f1f:Update release notes for security releases.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  019fac777dff020b9d5d80a194ee11396e5a7ed7:Update release notes for security releases.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067, CVE-2007-6600, CVE-2007-6601
  0776cb2116f4eaec743f1e304c1255c318a20d1f:Fix assorted security-grade bugs in the regex engine.  All of these problems
  are shared with Tcl, since it's their code to begin with, and the patches
  have been copied from Tcl 8.5.0.  Problems:

  CVE-2007-4769: Inadequate check on the range of backref numbers allows
  crash due to out-of-bounds read.
  CVE-2007-4772: Infinite loop in regex optimizer for pattern '($|^)*'.
  CVE-2007-6067: Very slow optimizer cleanup for regex with a large NFA
  representation, as well as crash if we encounter an out-of-memory condition
  during NFA construction.

  Part of the response to CVE-2007-6067 is to put a limit on the number of
  states in the NFA representation of a regex.  This seems needed even though
  the within-the-code problems have been corrected, since otherwise the code
  could try to use very large amounts of memory for a suitably-crafted regex,
  leading to potential DOS by driving the system into swap, activating a kernel
  OOM killer, etc.

  Although there are certainly plenty of ways to drive the system into effective
  DOS with poorly-written SQL queries, these problems seem worth treating as
  security issues because many applications might accept regex search patterns
  from untrustworthy sources.

  Thanks to Will Drewry of Google for reporting these problems.  Patches by Will
  Drewry and Tom Lane.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067
  0776cb2116f4eaec743f1e304c1255c318a20d1f:Fix assorted security-grade bugs in the regex engine.  All of these problems
  are shared with Tcl, since it's their code to begin with, and the patches
  have been copied from Tcl 8.5.0.  Problems:

  CVE-2007-4769: Inadequate check on the range of backref numbers allows
  crash due to out-of-bounds read.
  CVE-2007-4772: Infinite loop in regex optimizer for pattern '($|^)*'.
  CVE-2007-6067: Very slow optimizer cleanup for regex with a large NFA
  representation, as well as crash if we encounter an out-of-memory condition
  during NFA construction.

  Part of the response to CVE-2007-6067 is to put a limit on the number of
  states in the NFA representation of a regex.  This seems needed even though
  the within-the-code problems have been corrected, since otherwise the code
  could try to use very large amounts of memory for a suitably-crafted regex,
  leading to potential DOS by driving the system into swap, activating a kernel
  OOM killer, etc.

  Although there are certainly plenty of ways to drive the system into effective
  DOS with poorly-written SQL queries, these problems seem worth treating as
  security issues because many applications might accept regex search patterns
  from untrustworthy sources.

  Thanks to Will Drewry of Google for reporting these problems.  Patches by Will
  Drewry and Tom Lane.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067
  69abe8294be828bf3f156b4265e5ae734456b915:Fix assorted security-grade bugs in the regex engine.  All of these problems
  are shared with Tcl, since it's their code to begin with, and the patches
  have been copied from Tcl 8.5.0.  Problems:

  CVE-2007-4769: Inadequate check on the range of backref numbers allows
  crash due to out-of-bounds read.
  CVE-2007-4772: Infinite loop in regex optimizer for pattern '($|^)*'.
  CVE-2007-6067: Very slow optimizer cleanup for regex with a large NFA
  representation, as well as crash if we encounter an out-of-memory condition
  during NFA construction.

  Part of the response to CVE-2007-6067 is to put a limit on the number of
  states in the NFA representation of a regex.  This seems needed even though
  the within-the-code problems have been corrected, since otherwise the code
  could try to use very large amounts of memory for a suitably-crafted regex,
  leading to potential DOS by driving the system into swap, activating a kernel
  OOM killer, etc.

  Although there are certainly plenty of ways to drive the system into effective
  DOS with poorly-written SQL queries, these problems seem worth treating as
  security issues because many applications might accept regex search patterns
  from untrustworthy sources.

  Thanks to Will Drewry of Google for reporting these problems.  Patches by Will
  Drewry and Tom Lane.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067
  69abe8294be828bf3f156b4265e5ae734456b915:Fix assorted security-grade bugs in the regex engine.  All of these problems
  are shared with Tcl, since it's their code to begin with, and the patches
  have been copied from Tcl 8.5.0.  Problems:

  CVE-2007-4769: Inadequate check on the range of backref numbers allows
  crash due to out-of-bounds read.
  CVE-2007-4772: Infinite loop in regex optimizer for pattern '($|^)*'.
  CVE-2007-6067: Very slow optimizer cleanup for regex with a large NFA
  representation, as well as crash if we encounter an out-of-memory condition
  during NFA construction.

  Part of the response to CVE-2007-6067 is to put a limit on the number of
  states in the NFA representation of a regex.  This seems needed even though
  the within-the-code problems have been corrected, since otherwise the code
  could try to use very large amounts of memory for a suitably-crafted regex,
  leading to potential DOS by driving the system into swap, activating a kernel
  OOM killer, etc.

  Although there are certainly plenty of ways to drive the system into effective
  DOS with poorly-written SQL queries, these problems seem worth treating as
  security issues because many applications might accept regex search patterns
  from untrustworthy sources.

  Thanks to Will Drewry of Google for reporting these problems.  Patches by Will
  Drewry and Tom Lane.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067
  8b1de3b515b80e86dbef5fcbcc29e5e3256de779:Fix assorted security-grade bugs in the regex engine.  All of these problems
  are shared with Tcl, since it's their code to begin with, and the patches
  have been copied from Tcl 8.5.0.  Problems:

  CVE-2007-4769: Inadequate check on the range of backref numbers allows
  crash due to out-of-bounds read.
  CVE-2007-4772: Infinite loop in regex optimizer for pattern '($|^)*'.
  CVE-2007-6067: Very slow optimizer cleanup for regex with a large NFA
  representation, as well as crash if we encounter an out-of-memory condition
  during NFA construction.

  Part of the response to CVE-2007-6067 is to put a limit on the number of
  states in the NFA representation of a regex.  This seems needed even though
  the within-the-code problems have been corrected, since otherwise the code
  could try to use very large amounts of memory for a suitably-crafted regex,
  leading to potential DOS by driving the system into swap, activating a kernel
  OOM killer, etc.

  Although there are certainly plenty of ways to drive the system into effective
  DOS with poorly-written SQL queries, these problems seem worth treating as
  security issues because many applications might accept regex search patterns
  from untrustworthy sources.

  Thanks to Will Drewry of Google for reporting these problems.  Patches by Will
  Drewry and Tom Lane.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067
  8b1de3b515b80e86dbef5fcbcc29e5e3256de779:Fix assorted security-grade bugs in the regex engine.  All of these problems
  are shared with Tcl, since it's their code to begin with, and the patches
  have been copied from Tcl 8.5.0.  Problems:

  CVE-2007-4769: Inadequate check on the range of backref numbers allows
  crash due to out-of-bounds read.
  CVE-2007-4772: Infinite loop in regex optimizer for pattern '($|^)*'.
  CVE-2007-6067: Very slow optimizer cleanup for regex with a large NFA
  representation, as well as crash if we encounter an out-of-memory condition
  during NFA construction.

  Part of the response to CVE-2007-6067 is to put a limit on the number of
  states in the NFA representation of a regex.  This seems needed even though
  the within-the-code problems have been corrected, since otherwise the code
  could try to use very large amounts of memory for a suitably-crafted regex,
  leading to potential DOS by driving the system into swap, activating a kernel
  OOM killer, etc.

  Although there are certainly plenty of ways to drive the system into effective
  DOS with poorly-written SQL queries, these problems seem worth treating as
  security issues because many applications might accept regex search patterns
  from untrustworthy sources.

  Thanks to Will Drewry of Google for reporting these problems.  Patches by Will
  Drewry and Tom Lane.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067
  0f8fe9bed141e78bbce03f4517fdc5a6e35665c9:Fix assorted security-grade bugs in the regex engine.  All of these problems
  are shared with Tcl, since it's their code to begin with, and the patches
  have been copied from Tcl 8.5.0.  Problems:

  CVE-2007-4769: Inadequate check on the range of backref numbers allows
  crash due to out-of-bounds read.
  CVE-2007-4772: Infinite loop in regex optimizer for pattern '($|^)*'.
  CVE-2007-6067: Very slow optimizer cleanup for regex with a large NFA
  representation, as well as crash if we encounter an out-of-memory condition
  during NFA construction.

  Part of the response to CVE-2007-6067 is to put a limit on the number of
  states in the NFA representation of a regex.  This seems needed even though
  the within-the-code problems have been corrected, since otherwise the code
  could try to use very large amounts of memory for a suitably-crafted regex,
  leading to potential DOS by driving the system into swap, activating a kernel
  OOM killer, etc.

  Although there are certainly plenty of ways to drive the system into effective
  DOS with poorly-written SQL queries, these problems seem worth treating as
  security issues because many applications might accept regex search patterns
  from untrustworthy sources.

  Thanks to Will Drewry of Google for reporting these problems.  Patches by Will
  Drewry and Tom Lane.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067
  0f8fe9bed141e78bbce03f4517fdc5a6e35665c9:Fix assorted security-grade bugs in the regex engine.  All of these problems
  are shared with Tcl, since it's their code to begin with, and the patches
  have been copied from Tcl 8.5.0.  Problems:

  CVE-2007-4769: Inadequate check on the range of backref numbers allows
  crash due to out-of-bounds read.
  CVE-2007-4772: Infinite loop in regex optimizer for pattern '($|^)*'.
  CVE-2007-6067: Very slow optimizer cleanup for regex with a large NFA
  representation, as well as crash if we encounter an out-of-memory condition
  during NFA construction.

  Part of the response to CVE-2007-6067 is to put a limit on the number of
  states in the NFA representation of a regex.  This seems needed even though
  the within-the-code problems have been corrected, since otherwise the code
  could try to use very large amounts of memory for a suitably-crafted regex,
  leading to potential DOS by driving the system into swap, activating a kernel
  OOM killer, etc.

  Although there are certainly plenty of ways to drive the system into effective
  DOS with poorly-written SQL queries, these problems seem worth treating as
  security issues because many applications might accept regex search patterns
  from untrustworthy sources.

  Thanks to Will Drewry of Google for reporting these problems.  Patches by Will
  Drewry and Tom Lane.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067
  98f27aaef34291246c09ce5d0e0fba4f4477467a:Fix assorted security-grade bugs in the regex engine.  All of these problems
  are shared with Tcl, since it's their code to begin with, and the patches
  have been copied from Tcl 8.5.0.  Problems:

  CVE-2007-4769: Inadequate check on the range of backref numbers allows
  crash due to out-of-bounds read.
  CVE-2007-4772: Infinite loop in regex optimizer for pattern '($|^)*'.
  CVE-2007-6067: Very slow optimizer cleanup for regex with a large NFA
  representation, as well as crash if we encounter an out-of-memory condition
  during NFA construction.

  Part of the response to CVE-2007-6067 is to put a limit on the number of
  states in the NFA representation of a regex.  This seems needed even though
  the within-the-code problems have been corrected, since otherwise the code
  could try to use very large amounts of memory for a suitably-crafted regex,
  leading to potential DOS by driving the system into swap, activating a kernel
  OOM killer, etc.

  Although there are certainly plenty of ways to drive the system into effective
  DOS with poorly-written SQL queries, these problems seem worth treating as
  security issues because many applications might accept regex search patterns
  from untrustworthy sources.

  Thanks to Will Drewry of Google for reporting these problems.  Patches by Will
  Drewry and Tom Lane.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067
  98f27aaef34291246c09ce5d0e0fba4f4477467a:Fix assorted security-grade bugs in the regex engine.  All of these problems
  are shared with Tcl, since it's their code to begin with, and the patches
  have been copied from Tcl 8.5.0.  Problems:

  CVE-2007-4769: Inadequate check on the range of backref numbers allows
  crash due to out-of-bounds read.
  CVE-2007-4772: Infinite loop in regex optimizer for pattern '($|^)*'.
  CVE-2007-6067: Very slow optimizer cleanup for regex with a large NFA
  representation, as well as crash if we encounter an out-of-memory condition
  during NFA construction.

  Part of the response to CVE-2007-6067 is to put a limit on the number of
  states in the NFA representation of a regex.  This seems needed even though
  the within-the-code problems have been corrected, since otherwise the code
  could try to use very large amounts of memory for a suitably-crafted regex,
  leading to potential DOS by driving the system into swap, activating a kernel
  OOM killer, etc.

  Although there are certainly plenty of ways to drive the system into effective
  DOS with poorly-written SQL queries, these problems seem worth treating as
  security issues because many applications might accept regex search patterns
  from untrustworthy sources.

  Thanks to Will Drewry of Google for reporting these problems.  Patches by Will
  Drewry and Tom Lane.

  Security: CVE-2007-4769, CVE-2007-4772, CVE-2007-6067
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9d4269f087d94c868d4da72d14bdf89617b0246c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 63ee91fc451f11422371baec7e6041bd77cc414e
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 0776cb2116f4eaec743f1e304c1255c318a20d1f
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 83c34825e5b02880bdad2afdba7861590abe7fe7
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 98f27aaef34291246c09ce5d0e0fba4f4477467a
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 48789c5d23a7f382e3cb721547d5e0af7aaa4585
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 2a8d6e4d06d6ea2e1323aeab79bbb867d0f816c5
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 2bf121e40b998f0b3aacd163b5b0da0a17bb99e8
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b161e26de6546080eb53f2bcc4ae4156e2101046
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 56a2a4176389abdba65adf063fbfacf853a20132
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 019fac777dff020b9d5d80a194ee11396e5a7ed7
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 231967907d66a89b456da70d90751db9b8034433
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9774fda86866fb12c8d690cb754e3981dc45efcd
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 6e4dda79633c978e73b2bad7ba25db0661d9204e
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a257b808a507649432246b2bd9733e733f5b6332
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 6a7153661d66a00a03ff117c24fa49480b0699c8
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b6eb5fc40ed60dc0c58bc52356ab5b3679f74d0d
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 8b1de3b515b80e86dbef5fcbcc29e5e3256de779
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 067f96fe3a70755b225f03cd49f51bd4920a6d91
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 69abe8294be828bf3f156b4265e5ae734456b915
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d419ce456838ad1d2257ff24ef3f081718a51985
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d394f12c0c5576ac5a2f43da817074251abefed7
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 1bb0fbca39b447d1ce6da5f6bcf9f468a6346a08
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d66dcb144a3a5b8fd5cc76018bdbee2ef9f21f5f
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: bf4d342f8ea79699d5fa87eea50cfb042f2be2ae
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: f3c52c64e82dbe350264d3e1b4f77de39abf0f1f
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e29972bb56d9cb6f3c514d37baec70cd3cc57a89
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 0889e1857f07dea110e07fd7634af1ea773df951
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 0f8fe9bed141e78bbce03f4517fdc5a6e35665c9
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/019fac777dff020b9d5d80a194ee11396e5a7ed7
    reference_type: commit
    reference_id: 019fac777dff020b9d5d80a194ee11396e5a7ed7
  - url: https://github.com/postgres/postgres/tree/067f96fe3a70755b225f03cd49f51bd4920a6d91
    reference_type: commit
    reference_id: 067f96fe3a70755b225f03cd49f51bd4920a6d91
  - url: https://github.com/postgres/postgres/tree/0776cb2116f4eaec743f1e304c1255c318a20d1f
    reference_type: commit
    reference_id: 0776cb2116f4eaec743f1e304c1255c318a20d1f
  - url: https://github.com/postgres/postgres/tree/0889e1857f07dea110e07fd7634af1ea773df951
    reference_type: commit
    reference_id: 0889e1857f07dea110e07fd7634af1ea773df951
  - url: https://github.com/postgres/postgres/tree/0f8fe9bed141e78bbce03f4517fdc5a6e35665c9
    reference_type: commit
    reference_id: 0f8fe9bed141e78bbce03f4517fdc5a6e35665c9
  - url: https://github.com/postgres/postgres/tree/1bb0fbca39b447d1ce6da5f6bcf9f468a6346a08
    reference_type: commit
    reference_id: 1bb0fbca39b447d1ce6da5f6bcf9f468a6346a08
  - url: https://github.com/postgres/postgres/tree/231967907d66a89b456da70d90751db9b8034433
    reference_type: commit
    reference_id: 231967907d66a89b456da70d90751db9b8034433
  - url: https://github.com/postgres/postgres/tree/2a8d6e4d06d6ea2e1323aeab79bbb867d0f816c5
    reference_type: commit
    reference_id: 2a8d6e4d06d6ea2e1323aeab79bbb867d0f816c5
  - url: https://github.com/postgres/postgres/tree/2bf121e40b998f0b3aacd163b5b0da0a17bb99e8
    reference_type: commit
    reference_id: 2bf121e40b998f0b3aacd163b5b0da0a17bb99e8
  - url: https://github.com/postgres/postgres/tree/48789c5d23a7f382e3cb721547d5e0af7aaa4585
    reference_type: commit
    reference_id: 48789c5d23a7f382e3cb721547d5e0af7aaa4585
  - url: https://github.com/postgres/postgres/tree/56a2a4176389abdba65adf063fbfacf853a20132
    reference_type: commit
    reference_id: 56a2a4176389abdba65adf063fbfacf853a20132
  - url: https://github.com/postgres/postgres/tree/63ee91fc451f11422371baec7e6041bd77cc414e
    reference_type: commit
    reference_id: 63ee91fc451f11422371baec7e6041bd77cc414e
  - url: https://github.com/postgres/postgres/tree/69abe8294be828bf3f156b4265e5ae734456b915
    reference_type: commit
    reference_id: 69abe8294be828bf3f156b4265e5ae734456b915
  - url: https://github.com/postgres/postgres/tree/6a7153661d66a00a03ff117c24fa49480b0699c8
    reference_type: commit
    reference_id: 6a7153661d66a00a03ff117c24fa49480b0699c8
  - url: https://github.com/postgres/postgres/tree/6e4dda79633c978e73b2bad7ba25db0661d9204e
    reference_type: commit
    reference_id: 6e4dda79633c978e73b2bad7ba25db0661d9204e
  - url: https://github.com/postgres/postgres/tree/83c34825e5b02880bdad2afdba7861590abe7fe7
    reference_type: commit
    reference_id: 83c34825e5b02880bdad2afdba7861590abe7fe7
  - url: https://github.com/postgres/postgres/tree/8b1de3b515b80e86dbef5fcbcc29e5e3256de779
    reference_type: commit
    reference_id: 8b1de3b515b80e86dbef5fcbcc29e5e3256de779
  - url: https://github.com/postgres/postgres/tree/9774fda86866fb12c8d690cb754e3981dc45efcd
    reference_type: commit
    reference_id: 9774fda86866fb12c8d690cb754e3981dc45efcd
  - url: https://github.com/postgres/postgres/tree/98f27aaef34291246c09ce5d0e0fba4f4477467a
    reference_type: commit
    reference_id: 98f27aaef34291246c09ce5d0e0fba4f4477467a
  - url: https://github.com/postgres/postgres/tree/9d4269f087d94c868d4da72d14bdf89617b0246c
    reference_type: commit
    reference_id: 9d4269f087d94c868d4da72d14bdf89617b0246c
  - url: https://github.com/postgres/postgres/tree/a257b808a507649432246b2bd9733e733f5b6332
    reference_type: commit
    reference_id: a257b808a507649432246b2bd9733e733f5b6332
  - url: https://github.com/postgres/postgres/tree/b161e26de6546080eb53f2bcc4ae4156e2101046
    reference_type: commit
    reference_id: b161e26de6546080eb53f2bcc4ae4156e2101046
  - url: https://github.com/postgres/postgres/tree/b6eb5fc40ed60dc0c58bc52356ab5b3679f74d0d
    reference_type: commit
    reference_id: b6eb5fc40ed60dc0c58bc52356ab5b3679f74d0d
  - url: https://github.com/postgres/postgres/tree/bf4d342f8ea79699d5fa87eea50cfb042f2be2ae
    reference_type: commit
    reference_id: bf4d342f8ea79699d5fa87eea50cfb042f2be2ae
  - url: https://github.com/postgres/postgres/tree/d394f12c0c5576ac5a2f43da817074251abefed7
    reference_type: commit
    reference_id: d394f12c0c5576ac5a2f43da817074251abefed7
  - url: https://github.com/postgres/postgres/tree/d419ce456838ad1d2257ff24ef3f081718a51985
    reference_type: commit
    reference_id: d419ce456838ad1d2257ff24ef3f081718a51985
  - url: https://github.com/postgres/postgres/tree/d66dcb144a3a5b8fd5cc76018bdbee2ef9f21f5f
    reference_type: commit
    reference_id: d66dcb144a3a5b8fd5cc76018bdbee2ef9f21f5f
  - url: https://github.com/postgres/postgres/tree/e29972bb56d9cb6f3c514d37baec70cd3cc57a89
    reference_type: commit
    reference_id: e29972bb56d9cb6f3c514d37baec70cd3cc57a89
  - url: https://github.com/postgres/postgres/tree/f3c52c64e82dbe350264d3e1b4f77de39abf0f1f
    reference_type: commit
    reference_id: f3c52c64e82dbe350264d3e1b4f77de39abf0f1f
