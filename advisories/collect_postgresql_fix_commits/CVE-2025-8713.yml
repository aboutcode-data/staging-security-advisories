advisory_id: CVE-2025-8713
datasource_id: collect_postgresql_fix_commits/CVE-2025-8713
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  17d41fc70d5b87a1fc1b41d045a9634da120a74f:Last-minute updates for release notes.

  Security: CVE-2025-8713, CVE-2025-8714, CVE-2025-8715
  2e19ad79e1a14e5dacd0ad3a3ec959fff928ca17:Last-minute updates for release notes.

  Security: CVE-2025-8713, CVE-2025-8714, CVE-2025-8715
  4eb9733b2b76aeaca84e450be8c7653012ab215a:Last-minute updates for release notes.

  Security: CVE-2025-8713, CVE-2025-8714, CVE-2025-8715
  18d01671ef2576f7f950c2797a467370bc1a654d:Last-minute updates for release notes.

  Security: CVE-2025-8713, CVE-2025-8714, CVE-2025-8715
  86ad5a84c76b0ed1cf9ddb1d88f7204a9a076051:Last-minute updates for release notes.

  Security: CVE-2025-8713, CVE-2025-8714, CVE-2025-8715
  533211ded37aed55c715e9e237209a3deef4dd8d:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  afe38fb6abb8ef364191201f577a5a638ba55509:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  415badc138189a6ecfe3b664dc900af741342258:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  7e86da539d18bc29377a3882b9945dfbeb375f9c:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  a85eddab23f17bce333d7d9481f528d7ba78285e:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  64f77c6a65cb6a0731e59acbfab1dd1663b1cdd3:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
  22424953cded3f83f0382383773eaf36eb1abda9:Fix security checks in selectivity estimation functions.

  Commit e2d4ef8de86 (the fix for CVE-2017-7484) added security checks
  to the selectivity estimation functions to prevent them from running
  user-supplied operators on data obtained from pg_statistic if the user
  lacks privileges to select from the underlying table. In cases
  involving inheritance/partitioning, those checks were originally
  performed against the child RTE (which for plain inheritance might
  actually refer to the parent table). Commit 553d2ec2710 then extended
  that to also check the parent RTE, allowing access if the user had
  permissions on either the parent or the child. It turns out, however,
  that doing any checks using the child RTE is incorrect, since
  securityQuals is set to NULL when creating an RTE for an inheritance
  child (whether it refers to the parent table or the child table), and
  therefore such checks do not correctly account for any RLS policies or
  security barrier views. Therefore, do the security checks using only
  the parent RTE. This is consistent with how RLS policies are applied,
  and the executor's ACL checks, both of which use only the parent
  table's permissions/policies. Similar checks are performed in the
  extended stats code, so update that in the same way, centralizing all
  the checks in a new function.

  In addition, note that these checks by themselves are insufficient to
  ensure that the user has access to the table's data because, in a
  query that goes via a view, they only check that the view owner has
  permissions on the underlying table, not that the current user has
  permissions on the view itself. In the selectivity estimation
  functions, there is no easy way to navigate from underlying tables to
  views, so add permissions checks for all views mentioned in the query
  to the planner startup code. If the user lacks permissions on a view,
  a permissions error will now be reported at planner-startup, and the
  selectivity estimation functions will not be run.

  Checking view permissions at planner-startup in this way is a little
  ugly, since the same checks will be repeated at executor-startup.
  Longer-term, it might be better to move all the permissions checks
  from the executor to the planner so that permissions errors can be
  reported sooner, instead of creating a plan that won't ever be run.
  However, such a change seems too far-reaching to be back-patched.

  Back-patch to all supported versions. In v13, there is the added
  complication that UPDATEs and DELETEs on inherited target tables are
  planned using inheritance_planner(), which plans each inheritance
  child table separately, so that the selectivity estimation functions
  do not know that they are dealing with a child table accessed via its
  parent. Handle that by checking access permissions on the top parent
  table at planner-startup, in the same way as we do for views. Any
  securityQuals on the top parent table are moved down to the child
  tables by inheritance_planner(), so they continue to be checked by the
  selectivity estimation functions.

  Author: Dean Rasheed <dean.a.rasheed@gmail.com>
  Reviewed-by: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Backpatch-through: 13
  Security: CVE-2025-8713
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a85eddab23f17bce333d7d9481f528d7ba78285e
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 18d01671ef2576f7f950c2797a467370bc1a654d
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 86ad5a84c76b0ed1cf9ddb1d88f7204a9a076051
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 22424953cded3f83f0382383773eaf36eb1abda9
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 7e86da539d18bc29377a3882b9945dfbeb375f9c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 533211ded37aed55c715e9e237209a3deef4dd8d
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 64f77c6a65cb6a0731e59acbfab1dd1663b1cdd3
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 17d41fc70d5b87a1fc1b41d045a9634da120a74f
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 4eb9733b2b76aeaca84e450be8c7653012ab215a
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 415badc138189a6ecfe3b664dc900af741342258
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 2e19ad79e1a14e5dacd0ad3a3ec959fff928ca17
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: afe38fb6abb8ef364191201f577a5a638ba55509
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/17d41fc70d5b87a1fc1b41d045a9634da120a74f
    reference_type: commit
    reference_id: 17d41fc70d5b87a1fc1b41d045a9634da120a74f
  - url: https://github.com/postgres/postgres/tree/18d01671ef2576f7f950c2797a467370bc1a654d
    reference_type: commit
    reference_id: 18d01671ef2576f7f950c2797a467370bc1a654d
  - url: https://github.com/postgres/postgres/tree/22424953cded3f83f0382383773eaf36eb1abda9
    reference_type: commit
    reference_id: 22424953cded3f83f0382383773eaf36eb1abda9
  - url: https://github.com/postgres/postgres/tree/2e19ad79e1a14e5dacd0ad3a3ec959fff928ca17
    reference_type: commit
    reference_id: 2e19ad79e1a14e5dacd0ad3a3ec959fff928ca17
  - url: https://github.com/postgres/postgres/tree/415badc138189a6ecfe3b664dc900af741342258
    reference_type: commit
    reference_id: 415badc138189a6ecfe3b664dc900af741342258
  - url: https://github.com/postgres/postgres/tree/4eb9733b2b76aeaca84e450be8c7653012ab215a
    reference_type: commit
    reference_id: 4eb9733b2b76aeaca84e450be8c7653012ab215a
  - url: https://github.com/postgres/postgres/tree/533211ded37aed55c715e9e237209a3deef4dd8d
    reference_type: commit
    reference_id: 533211ded37aed55c715e9e237209a3deef4dd8d
  - url: https://github.com/postgres/postgres/tree/64f77c6a65cb6a0731e59acbfab1dd1663b1cdd3
    reference_type: commit
    reference_id: 64f77c6a65cb6a0731e59acbfab1dd1663b1cdd3
  - url: https://github.com/postgres/postgres/tree/7e86da539d18bc29377a3882b9945dfbeb375f9c
    reference_type: commit
    reference_id: 7e86da539d18bc29377a3882b9945dfbeb375f9c
  - url: https://github.com/postgres/postgres/tree/86ad5a84c76b0ed1cf9ddb1d88f7204a9a076051
    reference_type: commit
    reference_id: 86ad5a84c76b0ed1cf9ddb1d88f7204a9a076051
  - url: https://github.com/postgres/postgres/tree/a85eddab23f17bce333d7d9481f528d7ba78285e
    reference_type: commit
    reference_id: a85eddab23f17bce333d7d9481f528d7ba78285e
  - url: https://github.com/postgres/postgres/tree/afe38fb6abb8ef364191201f577a5a638ba55509
    reference_type: commit
    reference_id: afe38fb6abb8ef364191201f577a5a638ba55509
