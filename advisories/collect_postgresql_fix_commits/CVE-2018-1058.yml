advisory_id: CVE-2018-1058
datasource_id: collect_postgresql_fix_commits/CVE-2018-1058
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  b073c3ccd06e4cb845e121387a43faa8c68a7b62:Revoke PUBLIC CREATE from public schema, now owned by pg_database_owner.

  This switches the default ACL to what the documentation has recommended
  since CVE-2018-1058.  Upgrades will carry forward any old ownership and
  ACL.  Sites that declined the 2018 recommendation should take a fresh
  look.  Recipes for commissioning a new database cluster from scratch may
  need to create a schema, grant more privileges, etc.  Out-of-tree test
  suites may require such updates.

  Reviewed by Peter Eisentraut.

  Discussion: https://postgr.es/m/20201031163518.GB4039133@rfd.leadboat.com
  dd5d9951618831aa8f015c6a0ebd3a8f96a9ac32:Empty search_path in logical replication apply worker and walsender.

  This is like CVE-2018-1058 commit
  582edc369cdbd348d68441fc50fa26a84afd0c1a.  Today, a malicious user of a
  publisher or subscriber database can invoke arbitrary SQL functions
  under an identity running replication, often a superuser.  This fix may
  cause "does not exist" or "no schema has been selected to create in"
  errors in a replication process.  After upgrading, consider watching
  server logs for these errors.  Objects accruing schema qualification in
  the wake of the earlier commit are unlikely to need further correction.
  Back-patch to v10, which introduced logical replication.

  Security: CVE-2020-14349
  5a936d64c84ddce2c0e0f2f1f9db2c1094c3ceb8:Empty search_path in logical replication apply worker and walsender.

  This is like CVE-2018-1058 commit
  582edc369cdbd348d68441fc50fa26a84afd0c1a.  Today, a malicious user of a
  publisher or subscriber database can invoke arbitrary SQL functions
  under an identity running replication, often a superuser.  This fix may
  cause "does not exist" or "no schema has been selected to create in"
  errors in a replication process.  After upgrading, consider watching
  server logs for these errors.  Objects accruing schema qualification in
  the wake of the earlier commit are unlikely to need further correction.
  Back-patch to v10, which introduced logical replication.

  Security: CVE-2020-14349
  412c5c4010c0bec294f60a10cd56929680d3f95b:Empty search_path in logical replication apply worker and walsender.

  This is like CVE-2018-1058 commit
  582edc369cdbd348d68441fc50fa26a84afd0c1a.  Today, a malicious user of a
  publisher or subscriber database can invoke arbitrary SQL functions
  under an identity running replication, often a superuser.  This fix may
  cause "does not exist" or "no schema has been selected to create in"
  errors in a replication process.  After upgrading, consider watching
  server logs for these errors.  Objects accruing schema qualification in
  the wake of the earlier commit are unlikely to need further correction.
  Back-patch to v10, which introduced logical replication.

  Security: CVE-2020-14349
  64a71062e0e2fd7eb1eddd3cb4138c554fb29e4c:Empty search_path in logical replication apply worker and walsender.

  This is like CVE-2018-1058 commit
  582edc369cdbd348d68441fc50fa26a84afd0c1a.  Today, a malicious user of a
  publisher or subscriber database can invoke arbitrary SQL functions
  under an identity running replication, often a superuser.  This fix may
  cause "does not exist" or "no schema has been selected to create in"
  errors in a replication process.  After upgrading, consider watching
  server logs for these errors.  Objects accruing schema qualification in
  the wake of the earlier commit are unlikely to need further correction.
  Back-patch to v10, which introduced logical replication.

  Security: CVE-2020-14349
  11da97024abbe76b8c81e3f2375b2a62e9717c67:Empty search_path in logical replication apply worker and walsender.

  This is like CVE-2018-1058 commit
  582edc369cdbd348d68441fc50fa26a84afd0c1a.  Today, a malicious user of a
  publisher or subscriber database can invoke arbitrary SQL functions
  under an identity running replication, often a superuser.  This fix may
  cause "does not exist" or "no schema has been selected to create in"
  errors in a replication process.  After upgrading, consider watching
  server logs for these errors.  Objects accruing schema qualification in
  the wake of the earlier commit are unlikely to need further correction.
  Back-patch to v10, which introduced logical replication.

  Security: CVE-2020-14349
  25ff97ba77cbf8e3c08b4706328c50a470efd0ae:Make contrib/unaccent's unaccent() function work when not in search path.

  Since the fixes for CVE-2018-1058, we've advised people to schema-qualify
  function references in order to fix failures in code that executes under
  a minimal search_path setting.  However, that's insufficient to make the
  single-argument form of unaccent() work, because it looks up the "unaccent"
  text search dictionary using the search path.

  The most expedient answer seems to be to remove the search_path dependency
  by making it look in the same schema that the unaccent() function itself
  is declared in.  This will definitely work for the normal usage of this
  function with the unaccent dictionary provided by the extension.
  It's barely possible that there are people who were relying on the
  search-path-dependent behavior to select other dictionaries with the same
  name; but if there are any such people at all, they can still get that
  behavior by writing unaccent('unaccent', ...), or possibly
  unaccent('unaccent'::text::regdictionary, ...) if the lookup has to be
  postponed to runtime.

  Per complaint from Gunnlaugur Thor Briem.  Back-patch to all supported
  branches.

  Discussion: https://postgr.es/m/CAPs+M8LCex6d=DeneofdsoJVijaG59m9V0ggbb3pOH7hZO4+cQ@mail.gmail.com
  d4ab3962613f39ec81c2077e84b9cfe158433ecd:Make contrib/unaccent's unaccent() function work when not in search path.

  Since the fixes for CVE-2018-1058, we've advised people to schema-qualify
  function references in order to fix failures in code that executes under
  a minimal search_path setting.  However, that's insufficient to make the
  single-argument form of unaccent() work, because it looks up the "unaccent"
  text search dictionary using the search path.

  The most expedient answer seems to be to remove the search_path dependency
  by making it look in the same schema that the unaccent() function itself
  is declared in.  This will definitely work for the normal usage of this
  function with the unaccent dictionary provided by the extension.
  It's barely possible that there are people who were relying on the
  search-path-dependent behavior to select other dictionaries with the same
  name; but if there are any such people at all, they can still get that
  behavior by writing unaccent('unaccent', ...), or possibly
  unaccent('unaccent'::text::regdictionary, ...) if the lookup has to be
  postponed to runtime.

  Per complaint from Gunnlaugur Thor Briem.  Back-patch to all supported
  branches.

  Discussion: https://postgr.es/m/CAPs+M8LCex6d=DeneofdsoJVijaG59m9V0ggbb3pOH7hZO4+cQ@mail.gmail.com
  c79b39fb1c5bbb5a8e2f86a2187b31b2c3b3ae96:Make contrib/unaccent's unaccent() function work when not in search path.

  Since the fixes for CVE-2018-1058, we've advised people to schema-qualify
  function references in order to fix failures in code that executes under
  a minimal search_path setting.  However, that's insufficient to make the
  single-argument form of unaccent() work, because it looks up the "unaccent"
  text search dictionary using the search path.

  The most expedient answer seems to be to remove the search_path dependency
  by making it look in the same schema that the unaccent() function itself
  is declared in.  This will definitely work for the normal usage of this
  function with the unaccent dictionary provided by the extension.
  It's barely possible that there are people who were relying on the
  search-path-dependent behavior to select other dictionaries with the same
  name; but if there are any such people at all, they can still get that
  behavior by writing unaccent('unaccent', ...), or possibly
  unaccent('unaccent'::text::regdictionary, ...) if the lookup has to be
  postponed to runtime.

  Per complaint from Gunnlaugur Thor Briem.  Back-patch to all supported
  branches.

  Discussion: https://postgr.es/m/CAPs+M8LCex6d=DeneofdsoJVijaG59m9V0ggbb3pOH7hZO4+cQ@mail.gmail.com
  23aad181f44741c2061ce5caceb307774ac14fb8:Make contrib/unaccent's unaccent() function work when not in search path.

  Since the fixes for CVE-2018-1058, we've advised people to schema-qualify
  function references in order to fix failures in code that executes under
  a minimal search_path setting.  However, that's insufficient to make the
  single-argument form of unaccent() work, because it looks up the "unaccent"
  text search dictionary using the search path.

  The most expedient answer seems to be to remove the search_path dependency
  by making it look in the same schema that the unaccent() function itself
  is declared in.  This will definitely work for the normal usage of this
  function with the unaccent dictionary provided by the extension.
  It's barely possible that there are people who were relying on the
  search-path-dependent behavior to select other dictionaries with the same
  name; but if there are any such people at all, they can still get that
  behavior by writing unaccent('unaccent', ...), or possibly
  unaccent('unaccent'::text::regdictionary, ...) if the lookup has to be
  postponed to runtime.

  Per complaint from Gunnlaugur Thor Briem.  Back-patch to all supported
  branches.

  Discussion: https://postgr.es/m/CAPs+M8LCex6d=DeneofdsoJVijaG59m9V0ggbb3pOH7hZO4+cQ@mail.gmail.com
  594ee1ada5bc9affa37751d7ee840acb636a1f32:Make contrib/unaccent's unaccent() function work when not in search path.

  Since the fixes for CVE-2018-1058, we've advised people to schema-qualify
  function references in order to fix failures in code that executes under
  a minimal search_path setting.  However, that's insufficient to make the
  single-argument form of unaccent() work, because it looks up the "unaccent"
  text search dictionary using the search path.

  The most expedient answer seems to be to remove the search_path dependency
  by making it look in the same schema that the unaccent() function itself
  is declared in.  This will definitely work for the normal usage of this
  function with the unaccent dictionary provided by the extension.
  It's barely possible that there are people who were relying on the
  search-path-dependent behavior to select other dictionaries with the same
  name; but if there are any such people at all, they can still get that
  behavior by writing unaccent('unaccent', ...), or possibly
  unaccent('unaccent'::text::regdictionary, ...) if the lookup has to be
  postponed to runtime.

  Per complaint from Gunnlaugur Thor Briem.  Back-patch to all supported
  branches.

  Discussion: https://postgr.es/m/CAPs+M8LCex6d=DeneofdsoJVijaG59m9V0ggbb3pOH7hZO4+cQ@mail.gmail.com
  a54f5b187a4a12a0a694d0911525a451840a1d30:Make contrib/unaccent's unaccent() function work when not in search path.

  Since the fixes for CVE-2018-1058, we've advised people to schema-qualify
  function references in order to fix failures in code that executes under
  a minimal search_path setting.  However, that's insufficient to make the
  single-argument form of unaccent() work, because it looks up the "unaccent"
  text search dictionary using the search path.

  The most expedient answer seems to be to remove the search_path dependency
  by making it look in the same schema that the unaccent() function itself
  is declared in.  This will definitely work for the normal usage of this
  function with the unaccent dictionary provided by the extension.
  It's barely possible that there are people who were relying on the
  search-path-dependent behavior to select other dictionaries with the same
  name; but if there are any such people at all, they can still get that
  behavior by writing unaccent('unaccent', ...), or possibly
  unaccent('unaccent'::text::regdictionary, ...) if the lookup has to be
  postponed to runtime.

  Per complaint from Gunnlaugur Thor Briem.  Back-patch to all supported
  branches.

  Discussion: https://postgr.es/m/CAPs+M8LCex6d=DeneofdsoJVijaG59m9V0ggbb3pOH7hZO4+cQ@mail.gmail.com
  a5322ca10fa16bed01e3e3d6c49c0f49c68b5593:Make contrib/unaccent's unaccent() function work when not in search path.

  Since the fixes for CVE-2018-1058, we've advised people to schema-qualify
  function references in order to fix failures in code that executes under
  a minimal search_path setting.  However, that's insufficient to make the
  single-argument form of unaccent() work, because it looks up the "unaccent"
  text search dictionary using the search path.

  The most expedient answer seems to be to remove the search_path dependency
  by making it look in the same schema that the unaccent() function itself
  is declared in.  This will definitely work for the normal usage of this
  function with the unaccent dictionary provided by the extension.
  It's barely possible that there are people who were relying on the
  search-path-dependent behavior to select other dictionaries with the same
  name; but if there are any such people at all, they can still get that
  behavior by writing unaccent('unaccent', ...), or possibly
  unaccent('unaccent'::text::regdictionary, ...) if the lookup has to be
  postponed to runtime.

  Per complaint from Gunnlaugur Thor Briem.  Back-patch to all supported
  branches.

  Discussion: https://postgr.es/m/CAPs+M8LCex6d=DeneofdsoJVijaG59m9V0ggbb3pOH7hZO4+cQ@mail.gmail.com
  bb532859f45a16ae622eeebfd6e409c4481c28fa:Correct pg_recvlogical server version test.

  The predecessor test boiled down to "PQserverVersion(NULL) >= 100000",
  which is always false.  No release includes that, so it could not have
  reintroduced CVE-2018-1058.  Back-patch to 9.4, like the addition of the
  predecessor in commit 8d2814f274def85f39fbe997d454b01628cb5667.

  Discussion: https://postgr.es/m/20180422215551.GB2676194@rfd.leadboat.com
  24f1e9ca0b9261dd6ae3c16cebbcc572732f3587:Correct pg_recvlogical server version test.

  The predecessor test boiled down to "PQserverVersion(NULL) >= 100000",
  which is always false.  No release includes that, so it could not have
  reintroduced CVE-2018-1058.  Back-patch to 9.4, like the addition of the
  predecessor in commit 8d2814f274def85f39fbe997d454b01628cb5667.

  Discussion: https://postgr.es/m/20180422215551.GB2676194@rfd.leadboat.com
  32c247629367c827b09e65d135d0a26fc91eb8fa:Correct pg_recvlogical server version test.

  The predecessor test boiled down to "PQserverVersion(NULL) >= 100000",
  which is always false.  No release includes that, so it could not have
  reintroduced CVE-2018-1058.  Back-patch to 9.4, like the addition of the
  predecessor in commit 8d2814f274def85f39fbe997d454b01628cb5667.

  Discussion: https://postgr.es/m/20180422215551.GB2676194@rfd.leadboat.com
  c7cc9b7d408063c04482efb6bdd3c822fc3455ce:Correct pg_recvlogical server version test.

  The predecessor test boiled down to "PQserverVersion(NULL) >= 100000",
  which is always false.  No release includes that, so it could not have
  reintroduced CVE-2018-1058.  Back-patch to 9.4, like the addition of the
  predecessor in commit 8d2814f274def85f39fbe997d454b01628cb5667.

  Discussion: https://postgr.es/m/20180422215551.GB2676194@rfd.leadboat.com
  6336b6dfc5c5f7ef746fb7b14c720ef0c2c6a1f1:Correct pg_recvlogical server version test.

  The predecessor test boiled down to "PQserverVersion(NULL) >= 100000",
  which is always false.  No release includes that, so it could not have
  reintroduced CVE-2018-1058.  Back-patch to 9.4, like the addition of the
  predecessor in commit 8d2814f274def85f39fbe997d454b01628cb5667.

  Discussion: https://postgr.es/m/20180422215551.GB2676194@rfd.leadboat.com
  6497a18e6c1b5874566a77737ec3d381fded3ec2:Fix some corner-case issues in REFRESH MATERIALIZED VIEW CONCURRENTLY.

  refresh_by_match_merge() has some issues in the way it builds a SQL
  query to construct the "diff" table:

  1. It doesn't require the selected unique index(es) to be indimmediate.
  2. It doesn't pay attention to the particular equality semantics enforced
  by a given index, but just assumes that they must be those of the column
  datatype's default btree opclass.
  3. It doesn't check that the indexes are btrees.
  4. It's insufficiently careful to ensure that the parser will pick the
  intended operator when parsing the query.  (This would have been a
  security bug before CVE-2018-1058.)
  5. It's not careful about indexes on system columns.

  The way to fix #4 is to make use of the existing code in ri_triggers.c
  for generating an arbitrary binary operator clause.  I chose to move
  that to ruleutils.c, since that seems a more reasonable place to be
  exporting such functionality from than ri_triggers.c.

  While #1, #3, and #5 are just latent given existing feature restrictions,
  and #2 doesn't arise in the core system for lack of alternate opclasses
  with different equality behaviors, #4 seems like an issue worth
  back-patching.  That's the bulk of the change anyway, so just back-patch
  the whole thing to 9.4 where this code was introduced.

  Discussion: https://postgr.es/m/13836.1521413227@sss.pgh.pa.us
  e1f186da949dff96f974f491c0248b44845cc3e8:Fix some corner-case issues in REFRESH MATERIALIZED VIEW CONCURRENTLY.

  refresh_by_match_merge() has some issues in the way it builds a SQL
  query to construct the "diff" table:

  1. It doesn't require the selected unique index(es) to be indimmediate.
  2. It doesn't pay attention to the particular equality semantics enforced
  by a given index, but just assumes that they must be those of the column
  datatype's default btree opclass.
  3. It doesn't check that the indexes are btrees.
  4. It's insufficiently careful to ensure that the parser will pick the
  intended operator when parsing the query.  (This would have been a
  security bug before CVE-2018-1058.)
  5. It's not careful about indexes on system columns.

  The way to fix #4 is to make use of the existing code in ri_triggers.c
  for generating an arbitrary binary operator clause.  I chose to move
  that to ruleutils.c, since that seems a more reasonable place to be
  exporting such functionality from than ri_triggers.c.

  While #1, #3, and #5 are just latent given existing feature restrictions,
  and #2 doesn't arise in the core system for lack of alternate opclasses
  with different equality behaviors, #4 seems like an issue worth
  back-patching.  That's the bulk of the change anyway, so just back-patch
  the whole thing to 9.4 where this code was introduced.

  Discussion: https://postgr.es/m/13836.1521413227@sss.pgh.pa.us
  aa1cacd9541a4b46b3ca416d987e3b4a681ac5f3:Fix some corner-case issues in REFRESH MATERIALIZED VIEW CONCURRENTLY.

  refresh_by_match_merge() has some issues in the way it builds a SQL
  query to construct the "diff" table:

  1. It doesn't require the selected unique index(es) to be indimmediate.
  2. It doesn't pay attention to the particular equality semantics enforced
  by a given index, but just assumes that they must be those of the column
  datatype's default btree opclass.
  3. It doesn't check that the indexes are btrees.
  4. It's insufficiently careful to ensure that the parser will pick the
  intended operator when parsing the query.  (This would have been a
  security bug before CVE-2018-1058.)
  5. It's not careful about indexes on system columns.

  The way to fix #4 is to make use of the existing code in ri_triggers.c
  for generating an arbitrary binary operator clause.  I chose to move
  that to ruleutils.c, since that seems a more reasonable place to be
  exporting such functionality from than ri_triggers.c.

  While #1, #3, and #5 are just latent given existing feature restrictions,
  and #2 doesn't arise in the core system for lack of alternate opclasses
  with different equality behaviors, #4 seems like an issue worth
  back-patching.  That's the bulk of the change anyway, so just back-patch
  the whole thing to 9.4 where this code was introduced.

  Discussion: https://postgr.es/m/13836.1521413227@sss.pgh.pa.us
  7d7b59aa65918f59e3c122318b31e0f77f12f2cd:Fix some corner-case issues in REFRESH MATERIALIZED VIEW CONCURRENTLY.

  refresh_by_match_merge() has some issues in the way it builds a SQL
  query to construct the "diff" table:

  1. It doesn't require the selected unique index(es) to be indimmediate.
  2. It doesn't pay attention to the particular equality semantics enforced
  by a given index, but just assumes that they must be those of the column
  datatype's default btree opclass.
  3. It doesn't check that the indexes are btrees.
  4. It's insufficiently careful to ensure that the parser will pick the
  intended operator when parsing the query.  (This would have been a
  security bug before CVE-2018-1058.)
  5. It's not careful about indexes on system columns.

  The way to fix #4 is to make use of the existing code in ri_triggers.c
  for generating an arbitrary binary operator clause.  I chose to move
  that to ruleutils.c, since that seems a more reasonable place to be
  exporting such functionality from than ri_triggers.c.

  While #1, #3, and #5 are just latent given existing feature restrictions,
  and #2 doesn't arise in the core system for lack of alternate opclasses
  with different equality behaviors, #4 seems like an issue worth
  back-patching.  That's the bulk of the change anyway, so just back-patch
  the whole thing to 9.4 where this code was introduced.

  Discussion: https://postgr.es/m/13836.1521413227@sss.pgh.pa.us
  e17e9055f5644f1b39ecd1bf64ec03d3430dfb46:Fix some corner-case issues in REFRESH MATERIALIZED VIEW CONCURRENTLY.

  refresh_by_match_merge() has some issues in the way it builds a SQL
  query to construct the "diff" table:

  1. It doesn't require the selected unique index(es) to be indimmediate.
  2. It doesn't pay attention to the particular equality semantics enforced
  by a given index, but just assumes that they must be those of the column
  datatype's default btree opclass.
  3. It doesn't check that the indexes are btrees.
  4. It's insufficiently careful to ensure that the parser will pick the
  intended operator when parsing the query.  (This would have been a
  security bug before CVE-2018-1058.)
  5. It's not careful about indexes on system columns.

  The way to fix #4 is to make use of the existing code in ri_triggers.c
  for generating an arbitrary binary operator clause.  I chose to move
  that to ruleutils.c, since that seems a more reasonable place to be
  exporting such functionality from than ri_triggers.c.

  While #1, #3, and #5 are just latent given existing feature restrictions,
  and #2 doesn't arise in the core system for lack of alternate opclasses
  with different equality behaviors, #4 seems like an issue worth
  back-patching.  That's the bulk of the change anyway, so just back-patch
  the whole thing to 9.4 where this code was introduced.

  Discussion: https://postgr.es/m/13836.1521413227@sss.pgh.pa.us
  046a4ce39c440403b0034f0df625c29d848bb697:Schema-qualify references in test_ddl_deparse test script.

  This omission seems to be what is causing buildfarm failures on crake.

  Security: CVE-2018-1058
  3300e876cd45cf169d981fa53f9c9e8289ee3c82:Schema-qualify references in test_ddl_deparse test script.

  This omission seems to be what is causing buildfarm failures on crake.

  Security: CVE-2018-1058
  fdf521d697a37fbaa283e7b9de3ffc7f5029f544:Schema-qualify references in test_ddl_deparse test script.

  This omission seems to be what is causing buildfarm failures on crake.

  Security: CVE-2018-1058
  fb533e45f91796875939a63e7554efff0da3c8e5:Schema-qualify references in test_ddl_deparse test script.

  This omission seems to be what is causing buildfarm failures on crake.

  Security: CVE-2018-1058
  8af3855699aa6fa97b7d0d39e0bc7d3279d3fe47:Last-minute updates for release notes.

  Security: CVE-2018-1058
  6674761c88b48832a5336b33cf7e3e2de7b1a7d8:Last-minute updates for release notes.

  Security: CVE-2018-1058
  dfebb71692724081374a391b1a8549a467bc1d08:Last-minute updates for release notes.

  Security: CVE-2018-1058
  7e5903937085ff873ce8b00131e89ebe59959f18:Last-minute updates for release notes.

  Security: CVE-2018-1058
  adb0718a7f5ff453a6f9b2d7ce30943dec336e8b:Last-minute updates for release notes.

  Security: CVE-2018-1058
  e7d89ef4b53d5b01504c3fd5873133e6e68637df:Last-minute updates for release notes.

  Security: CVE-2018-1058
  41ee473a49b9990cac276e5b8e12a96615997f8c:Document security implications of search_path and the public schema.

  The ability to create like-named objects in different schemas opens up
  the potential for users to change the behavior of other users' queries,
  maliciously or accidentally.  When you connect to a PostgreSQL server,
  you should remove from your search_path any schema for which a user
  other than yourself or superusers holds the CREATE privilege.  If you do
  not, other users holding CREATE privilege can redefine the behavior of
  your commands, causing them to perform arbitrary SQL statements under
  your identity.  "SET search_path = ..." and "SELECT
  pg_catalog.set_config(...)" are not vulnerable to such hijacking, so one
  can use either as the first command of a session.  As special
  exceptions, the following client applications behave as documented
  regardless of search_path settings and schema privileges: clusterdb
  createdb createlang createuser dropdb droplang dropuser ecpg (not
  programs it generates) initdb oid2name pg_archivecleanup pg_basebackup
  pg_config pg_controldata pg_ctl pg_dump pg_dumpall pg_isready
  pg_receivewal pg_recvlogical pg_resetwal pg_restore pg_rewind pg_standby
  pg_test_fsync pg_test_timing pg_upgrade pg_waldump reindexdb vacuumdb
  vacuumlo.  Not included are core client programs that run user-specified
  SQL commands, namely psql and pgbench.  PostgreSQL encourages non-core
  client applications to do likewise.

  Document this in the context of libpq connections, psql connections,
  dblink connections, ECPG connections, extension packaging, and schema
  usage patterns.  The principal defense for applications is "SELECT
  pg_catalog.set_config('search_path', '', false)", and the principal
  defense for databases is "REVOKE CREATE ON SCHEMA public FROM PUBLIC".
  Either one is sufficient to prevent attack.  After a REVOKE, consider
  auditing the public schema for objects named like pg_catalog objects.

  Authors of SECURITY DEFINER functions use some of the same defenses, and
  the CREATE FUNCTION reference page already covered them thoroughly.
  This is a good opportunity to audit SECURITY DEFINER functions for
  robust security practice.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Michael Paquier and Jonathan S. Katz.  Reported by Arseniy
  Sharoglazov.

  Security: CVE-2018-1058
  f28955e382ee4249ab4283a85664e43c1f635ee9:Document security implications of search_path and the public schema.

  The ability to create like-named objects in different schemas opens up
  the potential for users to change the behavior of other users' queries,
  maliciously or accidentally.  When you connect to a PostgreSQL server,
  you should remove from your search_path any schema for which a user
  other than yourself or superusers holds the CREATE privilege.  If you do
  not, other users holding CREATE privilege can redefine the behavior of
  your commands, causing them to perform arbitrary SQL statements under
  your identity.  "SET search_path = ..." and "SELECT
  pg_catalog.set_config(...)" are not vulnerable to such hijacking, so one
  can use either as the first command of a session.  As special
  exceptions, the following client applications behave as documented
  regardless of search_path settings and schema privileges: clusterdb
  createdb createlang createuser dropdb droplang dropuser ecpg (not
  programs it generates) initdb oid2name pg_archivecleanup pg_basebackup
  pg_config pg_controldata pg_ctl pg_dump pg_dumpall pg_isready
  pg_receivewal pg_recvlogical pg_resetwal pg_restore pg_rewind pg_standby
  pg_test_fsync pg_test_timing pg_upgrade pg_waldump reindexdb vacuumdb
  vacuumlo.  Not included are core client programs that run user-specified
  SQL commands, namely psql and pgbench.  PostgreSQL encourages non-core
  client applications to do likewise.

  Document this in the context of libpq connections, psql connections,
  dblink connections, ECPG connections, extension packaging, and schema
  usage patterns.  The principal defense for applications is "SELECT
  pg_catalog.set_config('search_path', '', false)", and the principal
  defense for databases is "REVOKE CREATE ON SCHEMA public FROM PUBLIC".
  Either one is sufficient to prevent attack.  After a REVOKE, consider
  auditing the public schema for objects named like pg_catalog objects.

  Authors of SECURITY DEFINER functions use some of the same defenses, and
  the CREATE FUNCTION reference page already covered them thoroughly.
  This is a good opportunity to audit SECURITY DEFINER functions for
  robust security practice.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Michael Paquier and Jonathan S. Katz.  Reported by Arseniy
  Sharoglazov.

  Security: CVE-2018-1058
  1f47ea7b87185ff370ef9b27ea7c561c58583be3:Document security implications of search_path and the public schema.

  The ability to create like-named objects in different schemas opens up
  the potential for users to change the behavior of other users' queries,
  maliciously or accidentally.  When you connect to a PostgreSQL server,
  you should remove from your search_path any schema for which a user
  other than yourself or superusers holds the CREATE privilege.  If you do
  not, other users holding CREATE privilege can redefine the behavior of
  your commands, causing them to perform arbitrary SQL statements under
  your identity.  "SET search_path = ..." and "SELECT
  pg_catalog.set_config(...)" are not vulnerable to such hijacking, so one
  can use either as the first command of a session.  As special
  exceptions, the following client applications behave as documented
  regardless of search_path settings and schema privileges: clusterdb
  createdb createlang createuser dropdb droplang dropuser ecpg (not
  programs it generates) initdb oid2name pg_archivecleanup pg_basebackup
  pg_config pg_controldata pg_ctl pg_dump pg_dumpall pg_isready
  pg_receivewal pg_recvlogical pg_resetwal pg_restore pg_rewind pg_standby
  pg_test_fsync pg_test_timing pg_upgrade pg_waldump reindexdb vacuumdb
  vacuumlo.  Not included are core client programs that run user-specified
  SQL commands, namely psql and pgbench.  PostgreSQL encourages non-core
  client applications to do likewise.

  Document this in the context of libpq connections, psql connections,
  dblink connections, ECPG connections, extension packaging, and schema
  usage patterns.  The principal defense for applications is "SELECT
  pg_catalog.set_config('search_path', '', false)", and the principal
  defense for databases is "REVOKE CREATE ON SCHEMA public FROM PUBLIC".
  Either one is sufficient to prevent attack.  After a REVOKE, consider
  auditing the public schema for objects named like pg_catalog objects.

  Authors of SECURITY DEFINER functions use some of the same defenses, and
  the CREATE FUNCTION reference page already covered them thoroughly.
  This is a good opportunity to audit SECURITY DEFINER functions for
  robust security practice.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Michael Paquier and Jonathan S. Katz.  Reported by Arseniy
  Sharoglazov.

  Security: CVE-2018-1058
  70396dbe324e5e27e79908cdb7b183e13f326364:Document security implications of search_path and the public schema.

  The ability to create like-named objects in different schemas opens up
  the potential for users to change the behavior of other users' queries,
  maliciously or accidentally.  When you connect to a PostgreSQL server,
  you should remove from your search_path any schema for which a user
  other than yourself or superusers holds the CREATE privilege.  If you do
  not, other users holding CREATE privilege can redefine the behavior of
  your commands, causing them to perform arbitrary SQL statements under
  your identity.  "SET search_path = ..." and "SELECT
  pg_catalog.set_config(...)" are not vulnerable to such hijacking, so one
  can use either as the first command of a session.  As special
  exceptions, the following client applications behave as documented
  regardless of search_path settings and schema privileges: clusterdb
  createdb createlang createuser dropdb droplang dropuser ecpg (not
  programs it generates) initdb oid2name pg_archivecleanup pg_basebackup
  pg_config pg_controldata pg_ctl pg_dump pg_dumpall pg_isready
  pg_receivewal pg_recvlogical pg_resetwal pg_restore pg_rewind pg_standby
  pg_test_fsync pg_test_timing pg_upgrade pg_waldump reindexdb vacuumdb
  vacuumlo.  Not included are core client programs that run user-specified
  SQL commands, namely psql and pgbench.  PostgreSQL encourages non-core
  client applications to do likewise.

  Document this in the context of libpq connections, psql connections,
  dblink connections, ECPG connections, extension packaging, and schema
  usage patterns.  The principal defense for applications is "SELECT
  pg_catalog.set_config('search_path', '', false)", and the principal
  defense for databases is "REVOKE CREATE ON SCHEMA public FROM PUBLIC".
  Either one is sufficient to prevent attack.  After a REVOKE, consider
  auditing the public schema for objects named like pg_catalog objects.

  Authors of SECURITY DEFINER functions use some of the same defenses, and
  the CREATE FUNCTION reference page already covered them thoroughly.
  This is a good opportunity to audit SECURITY DEFINER functions for
  robust security practice.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Michael Paquier and Jonathan S. Katz.  Reported by Arseniy
  Sharoglazov.

  Security: CVE-2018-1058
  3db38b0ceffd95be81573c884f4be21f79ca954a:Empty search_path in Autovacuum and non-psql/pgbench clients.

  This makes the client programs behave as documented regardless of the
  connect-time search_path and regardless of user-created objects.  Today,
  a malicious user with CREATE permission on a search_path schema can take
  control of certain of these clients' queries and invoke arbitrary SQL
  functions under the client identity, often a superuser.  This is
  exploitable in the default configuration, where all users have CREATE
  privilege on schema "public".

  This changes behavior of user-defined code stored in the database, like
  pg_index.indexprs and pg_extension_config_dump().  If they reach code
  bearing unqualified names, "does not exist" or "no schema has been
  selected to create in" errors might appear.  Users may fix such errors
  by schema-qualifying affected names.  After upgrading, consider watching
  server logs for these errors.

  The --table arguments of src/bin/scripts clients have been lax; for
  example, "vacuumdb -Zt pg_am\;CHECKPOINT" performed a checkpoint.  That
  now fails, but for now, "vacuumdb -Zt 'pg_am(amname);CHECKPOINT'" still
  performs a checkpoint.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Tom Lane, though this fix strategy was not his first choice.
  Reported by Arseniy Sharoglazov.

  Security: CVE-2018-1058
  928bca1a30d7e05cc3857a99e27aa8ed08ed2fac:Empty search_path in Autovacuum and non-psql/pgbench clients.

  This makes the client programs behave as documented regardless of the
  connect-time search_path and regardless of user-created objects.  Today,
  a malicious user with CREATE permission on a search_path schema can take
  control of certain of these clients' queries and invoke arbitrary SQL
  functions under the client identity, often a superuser.  This is
  exploitable in the default configuration, where all users have CREATE
  privilege on schema "public".

  This changes behavior of user-defined code stored in the database, like
  pg_index.indexprs and pg_extension_config_dump().  If they reach code
  bearing unqualified names, "does not exist" or "no schema has been
  selected to create in" errors might appear.  Users may fix such errors
  by schema-qualifying affected names.  After upgrading, consider watching
  server logs for these errors.

  The --table arguments of src/bin/scripts clients have been lax; for
  example, "vacuumdb -Zt pg_am\;CHECKPOINT" performed a checkpoint.  That
  now fails, but for now, "vacuumdb -Zt 'pg_am(amname);CHECKPOINT'" still
  performs a checkpoint.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Tom Lane, though this fix strategy was not his first choice.
  Reported by Arseniy Sharoglazov.

  Security: CVE-2018-1058
  91f3ffc5249eff99c311fb27e7b29a44d9c62be1:Empty search_path in Autovacuum and non-psql/pgbench clients.

  This makes the client programs behave as documented regardless of the
  connect-time search_path and regardless of user-created objects.  Today,
  a malicious user with CREATE permission on a search_path schema can take
  control of certain of these clients' queries and invoke arbitrary SQL
  functions under the client identity, often a superuser.  This is
  exploitable in the default configuration, where all users have CREATE
  privilege on schema "public".

  This changes behavior of user-defined code stored in the database, like
  pg_index.indexprs and pg_extension_config_dump().  If they reach code
  bearing unqualified names, "does not exist" or "no schema has been
  selected to create in" errors might appear.  Users may fix such errors
  by schema-qualifying affected names.  After upgrading, consider watching
  server logs for these errors.

  The --table arguments of src/bin/scripts clients have been lax; for
  example, "vacuumdb -Zt pg_am\;CHECKPOINT" performed a checkpoint.  That
  now fails, but for now, "vacuumdb -Zt 'pg_am(amname);CHECKPOINT'" still
  performs a checkpoint.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Tom Lane, though this fix strategy was not his first choice.
  Reported by Arseniy Sharoglazov.

  Security: CVE-2018-1058
  e170b8c8c62064a16837c9838ef7a168fa9c9506:Empty search_path in Autovacuum and non-psql/pgbench clients.

  This makes the client programs behave as documented regardless of the
  connect-time search_path and regardless of user-created objects.  Today,
  a malicious user with CREATE permission on a search_path schema can take
  control of certain of these clients' queries and invoke arbitrary SQL
  functions under the client identity, often a superuser.  This is
  exploitable in the default configuration, where all users have CREATE
  privilege on schema "public".

  This changes behavior of user-defined code stored in the database, like
  pg_index.indexprs and pg_extension_config_dump().  If they reach code
  bearing unqualified names, "does not exist" or "no schema has been
  selected to create in" errors might appear.  Users may fix such errors
  by schema-qualifying affected names.  After upgrading, consider watching
  server logs for these errors.

  The --table arguments of src/bin/scripts clients have been lax; for
  example, "vacuumdb -Zt pg_am\;CHECKPOINT" performed a checkpoint.  That
  now fails, but for now, "vacuumdb -Zt 'pg_am(amname);CHECKPOINT'" still
  performs a checkpoint.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Tom Lane, though this fix strategy was not his first choice.
  Reported by Arseniy Sharoglazov.

  Security: CVE-2018-1058
  de8ffd6663fbe5a263ff1abc2820f7d6a00ba9a9:Back-patch non-static ExecuteSqlQueryForSingleRow().

  Back-patch a subset of commit 47e59697679a0877e0525c565b1be437487604a7
  to 9.4 and 9.3.  The next commit adds calls to this function.

  Security: CVE-2018-1058
  461c32b557ddbb0ed67b4b2232a191554ad40c3c:Back-patch non-static ExecuteSqlQueryForSingleRow().

  Back-patch a subset of commit 47e59697679a0877e0525c565b1be437487604a7
  to 9.4 and 9.3.  The next commit adds calls to this function.

  Security: CVE-2018-1058
  ee0d1966e5177816cf9e1ec28957774cddc2b742:Document security implications of search_path and the public schema.

  The ability to create like-named objects in different schemas opens up
  the potential for users to change the behavior of other users' queries,
  maliciously or accidentally.  When you connect to a PostgreSQL server,
  you should remove from your search_path any schema for which a user
  other than yourself or superusers holds the CREATE privilege.  If you do
  not, other users holding CREATE privilege can redefine the behavior of
  your commands, causing them to perform arbitrary SQL statements under
  your identity.  "SET search_path = ..." and "SELECT
  pg_catalog.set_config(...)" are not vulnerable to such hijacking, so one
  can use either as the first command of a session.  As special
  exceptions, the following client applications behave as documented
  regardless of search_path settings and schema privileges: clusterdb
  createdb createlang createuser dropdb droplang dropuser ecpg (not
  programs it generates) initdb oid2name pg_archivecleanup pg_basebackup
  pg_config pg_controldata pg_ctl pg_dump pg_dumpall pg_isready
  pg_receivewal pg_recvlogical pg_resetwal pg_restore pg_rewind pg_standby
  pg_test_fsync pg_test_timing pg_upgrade pg_waldump reindexdb vacuumdb
  vacuumlo.  Not included are core client programs that run user-specified
  SQL commands, namely psql and pgbench.  PostgreSQL encourages non-core
  client applications to do likewise.

  Document this in the context of libpq connections, psql connections,
  dblink connections, ECPG connections, extension packaging, and schema
  usage patterns.  The principal defense for applications is "SELECT
  pg_catalog.set_config('search_path', '', false)", and the principal
  defense for databases is "REVOKE CREATE ON SCHEMA public FROM PUBLIC".
  Either one is sufficient to prevent attack.  After a REVOKE, consider
  auditing the public schema for objects named like pg_catalog objects.

  Authors of SECURITY DEFINER functions use some of the same defenses, and
  the CREATE FUNCTION reference page already covered them thoroughly.
  This is a good opportunity to audit SECURITY DEFINER functions for
  robust security practice.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Michael Paquier and Jonathan S. Katz.  Reported by Arseniy
  Sharoglazov.

  Security: CVE-2018-1058
  10d598354a31caea4e9cafa927f8b7311761ae51:Empty search_path in Autovacuum and non-psql/pgbench clients.

  This makes the client programs behave as documented regardless of the
  connect-time search_path and regardless of user-created objects.  Today,
  a malicious user with CREATE permission on a search_path schema can take
  control of certain of these clients' queries and invoke arbitrary SQL
  functions under the client identity, often a superuser.  This is
  exploitable in the default configuration, where all users have CREATE
  privilege on schema "public".

  This changes behavior of user-defined code stored in the database, like
  pg_index.indexprs and pg_extension_config_dump().  If they reach code
  bearing unqualified names, "does not exist" or "no schema has been
  selected to create in" errors might appear.  Users may fix such errors
  by schema-qualifying affected names.  After upgrading, consider watching
  server logs for these errors.

  The --table arguments of src/bin/scripts clients have been lax; for
  example, "vacuumdb -Zt pg_am\;CHECKPOINT" performed a checkpoint.  That
  now fails, but for now, "vacuumdb -Zt 'pg_am(amname);CHECKPOINT'" still
  performs a checkpoint.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Tom Lane, though this fix strategy was not his first choice.
  Reported by Arseniy Sharoglazov.

  Security: CVE-2018-1058
  5770172cb0c9df9e6ce27c507b449557e5b45124:Document security implications of search_path and the public schema.

  The ability to create like-named objects in different schemas opens up
  the potential for users to change the behavior of other users' queries,
  maliciously or accidentally.  When you connect to a PostgreSQL server,
  you should remove from your search_path any schema for which a user
  other than yourself or superusers holds the CREATE privilege.  If you do
  not, other users holding CREATE privilege can redefine the behavior of
  your commands, causing them to perform arbitrary SQL statements under
  your identity.  "SET search_path = ..." and "SELECT
  pg_catalog.set_config(...)" are not vulnerable to such hijacking, so one
  can use either as the first command of a session.  As special
  exceptions, the following client applications behave as documented
  regardless of search_path settings and schema privileges: clusterdb
  createdb createlang createuser dropdb droplang dropuser ecpg (not
  programs it generates) initdb oid2name pg_archivecleanup pg_basebackup
  pg_config pg_controldata pg_ctl pg_dump pg_dumpall pg_isready
  pg_receivewal pg_recvlogical pg_resetwal pg_restore pg_rewind pg_standby
  pg_test_fsync pg_test_timing pg_upgrade pg_waldump reindexdb vacuumdb
  vacuumlo.  Not included are core client programs that run user-specified
  SQL commands, namely psql and pgbench.  PostgreSQL encourages non-core
  client applications to do likewise.

  Document this in the context of libpq connections, psql connections,
  dblink connections, ECPG connections, extension packaging, and schema
  usage patterns.  The principal defense for applications is "SELECT
  pg_catalog.set_config('search_path', '', false)", and the principal
  defense for databases is "REVOKE CREATE ON SCHEMA public FROM PUBLIC".
  Either one is sufficient to prevent attack.  After a REVOKE, consider
  auditing the public schema for objects named like pg_catalog objects.

  Authors of SECURITY DEFINER functions use some of the same defenses, and
  the CREATE FUNCTION reference page already covered them thoroughly.
  This is a good opportunity to audit SECURITY DEFINER functions for
  robust security practice.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Michael Paquier and Jonathan S. Katz.  Reported by Arseniy
  Sharoglazov.

  Security: CVE-2018-1058
  582edc369cdbd348d68441fc50fa26a84afd0c1a:Empty search_path in Autovacuum and non-psql/pgbench clients.

  This makes the client programs behave as documented regardless of the
  connect-time search_path and regardless of user-created objects.  Today,
  a malicious user with CREATE permission on a search_path schema can take
  control of certain of these clients' queries and invoke arbitrary SQL
  functions under the client identity, often a superuser.  This is
  exploitable in the default configuration, where all users have CREATE
  privilege on schema "public".

  This changes behavior of user-defined code stored in the database, like
  pg_index.indexprs and pg_extension_config_dump().  If they reach code
  bearing unqualified names, "does not exist" or "no schema has been
  selected to create in" errors might appear.  Users may fix such errors
  by schema-qualifying affected names.  After upgrading, consider watching
  server logs for these errors.

  The --table arguments of src/bin/scripts clients have been lax; for
  example, "vacuumdb -Zt pg_am\;CHECKPOINT" performed a checkpoint.  That
  now fails, but for now, "vacuumdb -Zt 'pg_am(amname);CHECKPOINT'" still
  performs a checkpoint.

  Back-patch to 9.3 (all supported versions).

  Reviewed by Tom Lane, though this fix strategy was not his first choice.
  Reported by Arseniy Sharoglazov.

  Security: CVE-2018-1058
  a8fc37a6381c0c2a5064d51aa31c72168c01a49a:Avoid using unsafe search_path settings during dump and restore.

  Historically, pg_dump has "set search_path = foo, pg_catalog" when
  dumping an object in schema "foo", and has also caused that setting
  to be used while restoring the object.  This is problematic because
  functions and operators in schema "foo" could capture references meant
  to refer to pg_catalog entries, both in the queries issued by pg_dump
  and those issued during the subsequent restore run.  That could
  result in dump/restore misbehavior, or in privilege escalation if a
  nefarious user installs trojan-horse functions or operators.

  This patch changes pg_dump so that it does not change the search_path
  dynamically.  The emitted restore script sets the search_path to what
  was used at dump time, and then leaves it alone thereafter.  Created
  objects are placed in the correct schema, regardless of the active
  search_path, by dint of schema-qualifying their names in the CREATE
  commands, as well as in subsequent ALTER and ALTER-like commands.

  Since this change requires a change in the behavior of pg_restore
  when processing an archive file made according to this new convention,
  bump the archive file version number; old versions of pg_restore will
  therefore refuse to process files made with new versions of pg_dump.

  Security: CVE-2018-1058
  815172ba8068dbca9b585ed4aa975db00bef01d8:Avoid using unsafe search_path settings during dump and restore.

  Historically, pg_dump has "set search_path = foo, pg_catalog" when
  dumping an object in schema "foo", and has also caused that setting
  to be used while restoring the object.  This is problematic because
  functions and operators in schema "foo" could capture references meant
  to refer to pg_catalog entries, both in the queries issued by pg_dump
  and those issued during the subsequent restore run.  That could
  result in dump/restore misbehavior, or in privilege escalation if a
  nefarious user installs trojan-horse functions or operators.

  This patch changes pg_dump so that it does not change the search_path
  dynamically.  The emitted restore script sets the search_path to what
  was used at dump time, and then leaves it alone thereafter.  Created
  objects are placed in the correct schema, regardless of the active
  search_path, by dint of schema-qualifying their names in the CREATE
  commands, as well as in subsequent ALTER and ALTER-like commands.

  Since this change requires a change in the behavior of pg_restore
  when processing an archive file made according to this new convention,
  bump the archive file version number; old versions of pg_restore will
  therefore refuse to process files made with new versions of pg_dump.

  Security: CVE-2018-1058
  fe8b95b7ea0c6e4294c4c97c555bc7f3492c0e33:Avoid using unsafe search_path settings during dump and restore.

  Historically, pg_dump has "set search_path = foo, pg_catalog" when
  dumping an object in schema "foo", and has also caused that setting
  to be used while restoring the object.  This is problematic because
  functions and operators in schema "foo" could capture references meant
  to refer to pg_catalog entries, both in the queries issued by pg_dump
  and those issued during the subsequent restore run.  That could
  result in dump/restore misbehavior, or in privilege escalation if a
  nefarious user installs trojan-horse functions or operators.

  This patch changes pg_dump so that it does not change the search_path
  dynamically.  The emitted restore script sets the search_path to what
  was used at dump time, and then leaves it alone thereafter.  Created
  objects are placed in the correct schema, regardless of the active
  search_path, by dint of schema-qualifying their names in the CREATE
  commands, as well as in subsequent ALTER and ALTER-like commands.

  Since this change requires a change in the behavior of pg_restore
  when processing an archive file made according to this new convention,
  bump the archive file version number; old versions of pg_restore will
  therefore refuse to process files made with new versions of pg_dump.

  Security: CVE-2018-1058
  9f6e5296a15f541b04ecdfc077957ccaf2f6e49a:Avoid using unsafe search_path settings during dump and restore.

  Historically, pg_dump has "set search_path = foo, pg_catalog" when
  dumping an object in schema "foo", and has also caused that setting
  to be used while restoring the object.  This is problematic because
  functions and operators in schema "foo" could capture references meant
  to refer to pg_catalog entries, both in the queries issued by pg_dump
  and those issued during the subsequent restore run.  That could
  result in dump/restore misbehavior, or in privilege escalation if a
  nefarious user installs trojan-horse functions or operators.

  This patch changes pg_dump so that it does not change the search_path
  dynamically.  The emitted restore script sets the search_path to what
  was used at dump time, and then leaves it alone thereafter.  Created
  objects are placed in the correct schema, regardless of the active
  search_path, by dint of schema-qualifying their names in the CREATE
  commands, as well as in subsequent ALTER and ALTER-like commands.

  Since this change requires a change in the behavior of pg_restore
  when processing an archive file made according to this new convention,
  bump the archive file version number; old versions of pg_restore will
  therefore refuse to process files made with new versions of pg_dump.

  Security: CVE-2018-1058
  b8a2908f0ac735da68d49be2bce2d523e363f67b:Avoid using unsafe search_path settings during dump and restore.

  Historically, pg_dump has "set search_path = foo, pg_catalog" when
  dumping an object in schema "foo", and has also caused that setting
  to be used while restoring the object.  This is problematic because
  functions and operators in schema "foo" could capture references meant
  to refer to pg_catalog entries, both in the queries issued by pg_dump
  and those issued during the subsequent restore run.  That could
  result in dump/restore misbehavior, or in privilege escalation if a
  nefarious user installs trojan-horse functions or operators.

  This patch changes pg_dump so that it does not change the search_path
  dynamically.  The emitted restore script sets the search_path to what
  was used at dump time, and then leaves it alone thereafter.  Created
  objects are placed in the correct schema, regardless of the active
  search_path, by dint of schema-qualifying their names in the CREATE
  commands, as well as in subsequent ALTER and ALTER-like commands.

  Since this change requires a change in the behavior of pg_restore
  when processing an archive file made according to this new convention,
  bump the archive file version number; old versions of pg_restore will
  therefore refuse to process files made with new versions of pg_dump.

  Security: CVE-2018-1058
  3d2aed664ee8271fd6c721ed0aa10168cda112ea:Avoid using unsafe search_path settings during dump and restore.

  Historically, pg_dump has "set search_path = foo, pg_catalog" when
  dumping an object in schema "foo", and has also caused that setting
  to be used while restoring the object.  This is problematic because
  functions and operators in schema "foo" could capture references meant
  to refer to pg_catalog entries, both in the queries issued by pg_dump
  and those issued during the subsequent restore run.  That could
  result in dump/restore misbehavior, or in privilege escalation if a
  nefarious user installs trojan-horse functions or operators.

  This patch changes pg_dump so that it does not change the search_path
  dynamically.  The emitted restore script sets the search_path to what
  was used at dump time, and then leaves it alone thereafter.  Created
  objects are placed in the correct schema, regardless of the active
  search_path, by dint of schema-qualifying their names in the CREATE
  commands, as well as in subsequent ALTER and ALTER-like commands.

  Since this change requires a change in the behavior of pg_restore
  when processing an archive file made according to this new convention,
  bump the archive file version number; old versions of pg_restore will
  therefore refuse to process files made with new versions of pg_dump.

  Security: CVE-2018-1058
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 24f1e9ca0b9261dd6ae3c16cebbcc572732f3587
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 815172ba8068dbca9b585ed4aa975db00bef01d8
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 25ff97ba77cbf8e3c08b4706328c50a470efd0ae
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 1f47ea7b87185ff370ef9b27ea7c561c58583be3
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 11da97024abbe76b8c81e3f2375b2a62e9717c67
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 928bca1a30d7e05cc3857a99e27aa8ed08ed2fac
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: de8ffd6663fbe5a263ff1abc2820f7d6a00ba9a9
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 8af3855699aa6fa97b7d0d39e0bc7d3279d3fe47
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 3300e876cd45cf169d981fa53f9c9e8289ee3c82
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a8fc37a6381c0c2a5064d51aa31c72168c01a49a
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: ee0d1966e5177816cf9e1ec28957774cddc2b742
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 594ee1ada5bc9affa37751d7ee840acb636a1f32
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 32c247629367c827b09e65d135d0a26fc91eb8fa
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 6674761c88b48832a5336b33cf7e3e2de7b1a7d8
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e1f186da949dff96f974f491c0248b44845cc3e8
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 3d2aed664ee8271fd6c721ed0aa10168cda112ea
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e7d89ef4b53d5b01504c3fd5873133e6e68637df
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: fdf521d697a37fbaa283e7b9de3ffc7f5029f544
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: fe8b95b7ea0c6e4294c4c97c555bc7f3492c0e33
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a5322ca10fa16bed01e3e3d6c49c0f49c68b5593
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: adb0718a7f5ff453a6f9b2d7ce30943dec336e8b
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 046a4ce39c440403b0034f0df625c29d848bb697
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 6497a18e6c1b5874566a77737ec3d381fded3ec2
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 64a71062e0e2fd7eb1eddd3cb4138c554fb29e4c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d4ab3962613f39ec81c2077e84b9cfe158433ecd
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a54f5b187a4a12a0a694d0911525a451840a1d30
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e17e9055f5644f1b39ecd1bf64ec03d3430dfb46
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 91f3ffc5249eff99c311fb27e7b29a44d9c62be1
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 6336b6dfc5c5f7ef746fb7b14c720ef0c2c6a1f1
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 3db38b0ceffd95be81573c884f4be21f79ca954a
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 5770172cb0c9df9e6ce27c507b449557e5b45124
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 41ee473a49b9990cac276e5b8e12a96615997f8c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: fb533e45f91796875939a63e7554efff0da3c8e5
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9f6e5296a15f541b04ecdfc077957ccaf2f6e49a
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: bb532859f45a16ae622eeebfd6e409c4481c28fa
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 5a936d64c84ddce2c0e0f2f1f9db2c1094c3ceb8
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: aa1cacd9541a4b46b3ca416d987e3b4a681ac5f3
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: dfebb71692724081374a391b1a8549a467bc1d08
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 70396dbe324e5e27e79908cdb7b183e13f326364
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 7e5903937085ff873ce8b00131e89ebe59959f18
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: f28955e382ee4249ab4283a85664e43c1f635ee9
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e170b8c8c62064a16837c9838ef7a168fa9c9506
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 23aad181f44741c2061ce5caceb307774ac14fb8
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: dd5d9951618831aa8f015c6a0ebd3a8f96a9ac32
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: c7cc9b7d408063c04482efb6bdd3c822fc3455ce
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 7d7b59aa65918f59e3c122318b31e0f77f12f2cd
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 461c32b557ddbb0ed67b4b2232a191554ad40c3c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 10d598354a31caea4e9cafa927f8b7311761ae51
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b073c3ccd06e4cb845e121387a43faa8c68a7b62
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: c79b39fb1c5bbb5a8e2f86a2187b31b2c3b3ae96
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 582edc369cdbd348d68441fc50fa26a84afd0c1a
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 412c5c4010c0bec294f60a10cd56929680d3f95b
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b8a2908f0ac735da68d49be2bce2d523e363f67b
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/046a4ce39c440403b0034f0df625c29d848bb697
    reference_type: commit
    reference_id: 046a4ce39c440403b0034f0df625c29d848bb697
  - url: https://github.com/postgres/postgres/tree/10d598354a31caea4e9cafa927f8b7311761ae51
    reference_type: commit
    reference_id: 10d598354a31caea4e9cafa927f8b7311761ae51
  - url: https://github.com/postgres/postgres/tree/11da97024abbe76b8c81e3f2375b2a62e9717c67
    reference_type: commit
    reference_id: 11da97024abbe76b8c81e3f2375b2a62e9717c67
  - url: https://github.com/postgres/postgres/tree/1f47ea7b87185ff370ef9b27ea7c561c58583be3
    reference_type: commit
    reference_id: 1f47ea7b87185ff370ef9b27ea7c561c58583be3
  - url: https://github.com/postgres/postgres/tree/23aad181f44741c2061ce5caceb307774ac14fb8
    reference_type: commit
    reference_id: 23aad181f44741c2061ce5caceb307774ac14fb8
  - url: https://github.com/postgres/postgres/tree/24f1e9ca0b9261dd6ae3c16cebbcc572732f3587
    reference_type: commit
    reference_id: 24f1e9ca0b9261dd6ae3c16cebbcc572732f3587
  - url: https://github.com/postgres/postgres/tree/25ff97ba77cbf8e3c08b4706328c50a470efd0ae
    reference_type: commit
    reference_id: 25ff97ba77cbf8e3c08b4706328c50a470efd0ae
  - url: https://github.com/postgres/postgres/tree/32c247629367c827b09e65d135d0a26fc91eb8fa
    reference_type: commit
    reference_id: 32c247629367c827b09e65d135d0a26fc91eb8fa
  - url: https://github.com/postgres/postgres/tree/3300e876cd45cf169d981fa53f9c9e8289ee3c82
    reference_type: commit
    reference_id: 3300e876cd45cf169d981fa53f9c9e8289ee3c82
  - url: https://github.com/postgres/postgres/tree/3d2aed664ee8271fd6c721ed0aa10168cda112ea
    reference_type: commit
    reference_id: 3d2aed664ee8271fd6c721ed0aa10168cda112ea
  - url: https://github.com/postgres/postgres/tree/3db38b0ceffd95be81573c884f4be21f79ca954a
    reference_type: commit
    reference_id: 3db38b0ceffd95be81573c884f4be21f79ca954a
  - url: https://github.com/postgres/postgres/tree/412c5c4010c0bec294f60a10cd56929680d3f95b
    reference_type: commit
    reference_id: 412c5c4010c0bec294f60a10cd56929680d3f95b
  - url: https://github.com/postgres/postgres/tree/41ee473a49b9990cac276e5b8e12a96615997f8c
    reference_type: commit
    reference_id: 41ee473a49b9990cac276e5b8e12a96615997f8c
  - url: https://github.com/postgres/postgres/tree/461c32b557ddbb0ed67b4b2232a191554ad40c3c
    reference_type: commit
    reference_id: 461c32b557ddbb0ed67b4b2232a191554ad40c3c
  - url: https://github.com/postgres/postgres/tree/5770172cb0c9df9e6ce27c507b449557e5b45124
    reference_type: commit
    reference_id: 5770172cb0c9df9e6ce27c507b449557e5b45124
  - url: https://github.com/postgres/postgres/tree/582edc369cdbd348d68441fc50fa26a84afd0c1a
    reference_type: commit
    reference_id: 582edc369cdbd348d68441fc50fa26a84afd0c1a
  - url: https://github.com/postgres/postgres/tree/594ee1ada5bc9affa37751d7ee840acb636a1f32
    reference_type: commit
    reference_id: 594ee1ada5bc9affa37751d7ee840acb636a1f32
  - url: https://github.com/postgres/postgres/tree/5a936d64c84ddce2c0e0f2f1f9db2c1094c3ceb8
    reference_type: commit
    reference_id: 5a936d64c84ddce2c0e0f2f1f9db2c1094c3ceb8
  - url: https://github.com/postgres/postgres/tree/6336b6dfc5c5f7ef746fb7b14c720ef0c2c6a1f1
    reference_type: commit
    reference_id: 6336b6dfc5c5f7ef746fb7b14c720ef0c2c6a1f1
  - url: https://github.com/postgres/postgres/tree/6497a18e6c1b5874566a77737ec3d381fded3ec2
    reference_type: commit
    reference_id: 6497a18e6c1b5874566a77737ec3d381fded3ec2
  - url: https://github.com/postgres/postgres/tree/64a71062e0e2fd7eb1eddd3cb4138c554fb29e4c
    reference_type: commit
    reference_id: 64a71062e0e2fd7eb1eddd3cb4138c554fb29e4c
  - url: https://github.com/postgres/postgres/tree/6674761c88b48832a5336b33cf7e3e2de7b1a7d8
    reference_type: commit
    reference_id: 6674761c88b48832a5336b33cf7e3e2de7b1a7d8
  - url: https://github.com/postgres/postgres/tree/70396dbe324e5e27e79908cdb7b183e13f326364
    reference_type: commit
    reference_id: 70396dbe324e5e27e79908cdb7b183e13f326364
  - url: https://github.com/postgres/postgres/tree/7d7b59aa65918f59e3c122318b31e0f77f12f2cd
    reference_type: commit
    reference_id: 7d7b59aa65918f59e3c122318b31e0f77f12f2cd
  - url: https://github.com/postgres/postgres/tree/7e5903937085ff873ce8b00131e89ebe59959f18
    reference_type: commit
    reference_id: 7e5903937085ff873ce8b00131e89ebe59959f18
  - url: https://github.com/postgres/postgres/tree/815172ba8068dbca9b585ed4aa975db00bef01d8
    reference_type: commit
    reference_id: 815172ba8068dbca9b585ed4aa975db00bef01d8
  - url: https://github.com/postgres/postgres/tree/8af3855699aa6fa97b7d0d39e0bc7d3279d3fe47
    reference_type: commit
    reference_id: 8af3855699aa6fa97b7d0d39e0bc7d3279d3fe47
  - url: https://github.com/postgres/postgres/tree/91f3ffc5249eff99c311fb27e7b29a44d9c62be1
    reference_type: commit
    reference_id: 91f3ffc5249eff99c311fb27e7b29a44d9c62be1
  - url: https://github.com/postgres/postgres/tree/928bca1a30d7e05cc3857a99e27aa8ed08ed2fac
    reference_type: commit
    reference_id: 928bca1a30d7e05cc3857a99e27aa8ed08ed2fac
  - url: https://github.com/postgres/postgres/tree/9f6e5296a15f541b04ecdfc077957ccaf2f6e49a
    reference_type: commit
    reference_id: 9f6e5296a15f541b04ecdfc077957ccaf2f6e49a
  - url: https://github.com/postgres/postgres/tree/a5322ca10fa16bed01e3e3d6c49c0f49c68b5593
    reference_type: commit
    reference_id: a5322ca10fa16bed01e3e3d6c49c0f49c68b5593
  - url: https://github.com/postgres/postgres/tree/a54f5b187a4a12a0a694d0911525a451840a1d30
    reference_type: commit
    reference_id: a54f5b187a4a12a0a694d0911525a451840a1d30
  - url: https://github.com/postgres/postgres/tree/a8fc37a6381c0c2a5064d51aa31c72168c01a49a
    reference_type: commit
    reference_id: a8fc37a6381c0c2a5064d51aa31c72168c01a49a
  - url: https://github.com/postgres/postgres/tree/aa1cacd9541a4b46b3ca416d987e3b4a681ac5f3
    reference_type: commit
    reference_id: aa1cacd9541a4b46b3ca416d987e3b4a681ac5f3
  - url: https://github.com/postgres/postgres/tree/adb0718a7f5ff453a6f9b2d7ce30943dec336e8b
    reference_type: commit
    reference_id: adb0718a7f5ff453a6f9b2d7ce30943dec336e8b
  - url: https://github.com/postgres/postgres/tree/b073c3ccd06e4cb845e121387a43faa8c68a7b62
    reference_type: commit
    reference_id: b073c3ccd06e4cb845e121387a43faa8c68a7b62
  - url: https://github.com/postgres/postgres/tree/b8a2908f0ac735da68d49be2bce2d523e363f67b
    reference_type: commit
    reference_id: b8a2908f0ac735da68d49be2bce2d523e363f67b
  - url: https://github.com/postgres/postgres/tree/bb532859f45a16ae622eeebfd6e409c4481c28fa
    reference_type: commit
    reference_id: bb532859f45a16ae622eeebfd6e409c4481c28fa
  - url: https://github.com/postgres/postgres/tree/c79b39fb1c5bbb5a8e2f86a2187b31b2c3b3ae96
    reference_type: commit
    reference_id: c79b39fb1c5bbb5a8e2f86a2187b31b2c3b3ae96
  - url: https://github.com/postgres/postgres/tree/c7cc9b7d408063c04482efb6bdd3c822fc3455ce
    reference_type: commit
    reference_id: c7cc9b7d408063c04482efb6bdd3c822fc3455ce
  - url: https://github.com/postgres/postgres/tree/d4ab3962613f39ec81c2077e84b9cfe158433ecd
    reference_type: commit
    reference_id: d4ab3962613f39ec81c2077e84b9cfe158433ecd
  - url: https://github.com/postgres/postgres/tree/dd5d9951618831aa8f015c6a0ebd3a8f96a9ac32
    reference_type: commit
    reference_id: dd5d9951618831aa8f015c6a0ebd3a8f96a9ac32
  - url: https://github.com/postgres/postgres/tree/de8ffd6663fbe5a263ff1abc2820f7d6a00ba9a9
    reference_type: commit
    reference_id: de8ffd6663fbe5a263ff1abc2820f7d6a00ba9a9
  - url: https://github.com/postgres/postgres/tree/dfebb71692724081374a391b1a8549a467bc1d08
    reference_type: commit
    reference_id: dfebb71692724081374a391b1a8549a467bc1d08
  - url: https://github.com/postgres/postgres/tree/e170b8c8c62064a16837c9838ef7a168fa9c9506
    reference_type: commit
    reference_id: e170b8c8c62064a16837c9838ef7a168fa9c9506
  - url: https://github.com/postgres/postgres/tree/e17e9055f5644f1b39ecd1bf64ec03d3430dfb46
    reference_type: commit
    reference_id: e17e9055f5644f1b39ecd1bf64ec03d3430dfb46
  - url: https://github.com/postgres/postgres/tree/e1f186da949dff96f974f491c0248b44845cc3e8
    reference_type: commit
    reference_id: e1f186da949dff96f974f491c0248b44845cc3e8
  - url: https://github.com/postgres/postgres/tree/e7d89ef4b53d5b01504c3fd5873133e6e68637df
    reference_type: commit
    reference_id: e7d89ef4b53d5b01504c3fd5873133e6e68637df
  - url: https://github.com/postgres/postgres/tree/ee0d1966e5177816cf9e1ec28957774cddc2b742
    reference_type: commit
    reference_id: ee0d1966e5177816cf9e1ec28957774cddc2b742
  - url: https://github.com/postgres/postgres/tree/f28955e382ee4249ab4283a85664e43c1f635ee9
    reference_type: commit
    reference_id: f28955e382ee4249ab4283a85664e43c1f635ee9
  - url: https://github.com/postgres/postgres/tree/fb533e45f91796875939a63e7554efff0da3c8e5
    reference_type: commit
    reference_id: fb533e45f91796875939a63e7554efff0da3c8e5
  - url: https://github.com/postgres/postgres/tree/fdf521d697a37fbaa283e7b9de3ffc7f5029f544
    reference_type: commit
    reference_id: fdf521d697a37fbaa283e7b9de3ffc7f5029f544
  - url: https://github.com/postgres/postgres/tree/fe8b95b7ea0c6e4294c4c97c555bc7f3492c0e33
    reference_type: commit
    reference_id: fe8b95b7ea0c6e4294c4c97c555bc7f3492c0e33
