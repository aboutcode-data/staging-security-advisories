advisory_id: CVE-2006-2313
datasource_id: collect_postgresql_fix_commits/CVE-2006-2313
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  ac600c54165631d5266c8aa7c5cb8c96ac589138:Fix incautious handling of possibly-miscoded strings in client code.

  An incorrectly-encoded multibyte character near the end of a string
  could cause various processing loops to run past the string's
  terminating NUL, with results ranging from no detectable issue to
  a program crash, depending on what happens to be in the following
  memory.

  This isn't an issue in the server, because we take care to verify
  the encoding of strings before doing any interesting processing
  on them.  However, that lack of care leaked into client-side code
  which shouldn't assume that anyone has validated the encoding of
  its input.

  Although this is certainly a bug worth fixing, the PG security team
  elected not to regard it as a security issue, primarily because
  any untrusted text should be sanitized by PQescapeLiteral or
  the like before being incorporated into a SQL or psql command.
  (If an app fails to do so, the same technique can be used to
  cause SQL injection, with probably much more dire consequences
  than a mere client-program crash.)  Those functions were already
  made proof against this class of problem, cf CVE-2006-2313.

  To fix, invent PQmblenBounded() which is like PQmblen() except it
  won't return more than the number of bytes remaining in the string.
  In HEAD we can make this a new libpq function, as PQmblen() is.
  It seems imprudent to change libpq's API in stable branches though,
  so in the back branches define PQmblenBounded as a macro in the files
  that need it.  (Note that just changing PQmblen's behavior would not
  be a good idea; notably, it would completely break the escaping
  functions' defense against this exact problem.  So we just want a
  version for those callers that don't have any better way of handling
  this issue.)

  Per private report from houjingyi.  Back-patch to all supported branches.
  4826fe4c5674b93f3725ce84a091cee521907aae:Fix incautious handling of possibly-miscoded strings in client code.

  An incorrectly-encoded multibyte character near the end of a string
  could cause various processing loops to run past the string's
  terminating NUL, with results ranging from no detectable issue to
  a program crash, depending on what happens to be in the following
  memory.

  This isn't an issue in the server, because we take care to verify
  the encoding of strings before doing any interesting processing
  on them.  However, that lack of care leaked into client-side code
  which shouldn't assume that anyone has validated the encoding of
  its input.

  Although this is certainly a bug worth fixing, the PG security team
  elected not to regard it as a security issue, primarily because
  any untrusted text should be sanitized by PQescapeLiteral or
  the like before being incorporated into a SQL or psql command.
  (If an app fails to do so, the same technique can be used to
  cause SQL injection, with probably much more dire consequences
  than a mere client-program crash.)  Those functions were already
  made proof against this class of problem, cf CVE-2006-2313.

  To fix, invent PQmblenBounded() which is like PQmblen() except it
  won't return more than the number of bytes remaining in the string.
  In HEAD we can make this a new libpq function, as PQmblen() is.
  It seems imprudent to change libpq's API in stable branches though,
  so in the back branches define PQmblenBounded as a macro in the files
  that need it.  (Note that just changing PQmblen's behavior would not
  be a good idea; notably, it would completely break the escaping
  functions' defense against this exact problem.  So we just want a
  version for those callers that don't have any better way of handling
  this issue.)

  Per private report from houjingyi.  Back-patch to all supported branches.
  89a5499ef9e477beb97d742d4df6fc8f601d87d5:Fix incautious handling of possibly-miscoded strings in client code.

  An incorrectly-encoded multibyte character near the end of a string
  could cause various processing loops to run past the string's
  terminating NUL, with results ranging from no detectable issue to
  a program crash, depending on what happens to be in the following
  memory.

  This isn't an issue in the server, because we take care to verify
  the encoding of strings before doing any interesting processing
  on them.  However, that lack of care leaked into client-side code
  which shouldn't assume that anyone has validated the encoding of
  its input.

  Although this is certainly a bug worth fixing, the PG security team
  elected not to regard it as a security issue, primarily because
  any untrusted text should be sanitized by PQescapeLiteral or
  the like before being incorporated into a SQL or psql command.
  (If an app fails to do so, the same technique can be used to
  cause SQL injection, with probably much more dire consequences
  than a mere client-program crash.)  Those functions were already
  made proof against this class of problem, cf CVE-2006-2313.

  To fix, invent PQmblenBounded() which is like PQmblen() except it
  won't return more than the number of bytes remaining in the string.
  In HEAD we can make this a new libpq function, as PQmblen() is.
  It seems imprudent to change libpq's API in stable branches though,
  so in the back branches define PQmblenBounded as a macro in the files
  that need it.  (Note that just changing PQmblen's behavior would not
  be a good idea; notably, it would completely break the escaping
  functions' defense against this exact problem.  So we just want a
  version for those callers that don't have any better way of handling
  this issue.)

  Per private report from houjingyi.  Back-patch to all supported branches.
  fc896f45d6d859d9da52106cf42dc01dce88c224:Fix incautious handling of possibly-miscoded strings in client code.

  An incorrectly-encoded multibyte character near the end of a string
  could cause various processing loops to run past the string's
  terminating NUL, with results ranging from no detectable issue to
  a program crash, depending on what happens to be in the following
  memory.

  This isn't an issue in the server, because we take care to verify
  the encoding of strings before doing any interesting processing
  on them.  However, that lack of care leaked into client-side code
  which shouldn't assume that anyone has validated the encoding of
  its input.

  Although this is certainly a bug worth fixing, the PG security team
  elected not to regard it as a security issue, primarily because
  any untrusted text should be sanitized by PQescapeLiteral or
  the like before being incorporated into a SQL or psql command.
  (If an app fails to do so, the same technique can be used to
  cause SQL injection, with probably much more dire consequences
  than a mere client-program crash.)  Those functions were already
  made proof against this class of problem, cf CVE-2006-2313.

  To fix, invent PQmblenBounded() which is like PQmblen() except it
  won't return more than the number of bytes remaining in the string.
  In HEAD we can make this a new libpq function, as PQmblen() is.
  It seems imprudent to change libpq's API in stable branches though,
  so in the back branches define PQmblenBounded as a macro in the files
  that need it.  (Note that just changing PQmblen's behavior would not
  be a good idea; notably, it would completely break the escaping
  functions' defense against this exact problem.  So we just want a
  version for those callers that don't have any better way of handling
  this issue.)

  Per private report from houjingyi.  Back-patch to all supported branches.
  5b64368742b5cdf73395bd5ddd66b5edcbc20823:Fix incautious handling of possibly-miscoded strings in client code.

  An incorrectly-encoded multibyte character near the end of a string
  could cause various processing loops to run past the string's
  terminating NUL, with results ranging from no detectable issue to
  a program crash, depending on what happens to be in the following
  memory.

  This isn't an issue in the server, because we take care to verify
  the encoding of strings before doing any interesting processing
  on them.  However, that lack of care leaked into client-side code
  which shouldn't assume that anyone has validated the encoding of
  its input.

  Although this is certainly a bug worth fixing, the PG security team
  elected not to regard it as a security issue, primarily because
  any untrusted text should be sanitized by PQescapeLiteral or
  the like before being incorporated into a SQL or psql command.
  (If an app fails to do so, the same technique can be used to
  cause SQL injection, with probably much more dire consequences
  than a mere client-program crash.)  Those functions were already
  made proof against this class of problem, cf CVE-2006-2313.

  To fix, invent PQmblenBounded() which is like PQmblen() except it
  won't return more than the number of bytes remaining in the string.
  In HEAD we can make this a new libpq function, as PQmblen() is.
  It seems imprudent to change libpq's API in stable branches though,
  so in the back branches define PQmblenBounded as a macro in the files
  that need it.  (Note that just changing PQmblen's behavior would not
  be a good idea; notably, it would completely break the escaping
  functions' defense against this exact problem.  So we just want a
  version for those callers that don't have any better way of handling
  this issue.)

  Per private report from houjingyi.  Back-patch to all supported branches.
  42f94f56bf9559f0a3cf5f3ffde50655834694ee:Fix incautious handling of possibly-miscoded strings in client code.

  An incorrectly-encoded multibyte character near the end of a string
  could cause various processing loops to run past the string's
  terminating NUL, with results ranging from no detectable issue to
  a program crash, depending on what happens to be in the following
  memory.

  This isn't an issue in the server, because we take care to verify
  the encoding of strings before doing any interesting processing
  on them.  However, that lack of care leaked into client-side code
  which shouldn't assume that anyone has validated the encoding of
  its input.

  Although this is certainly a bug worth fixing, the PG security team
  elected not to regard it as a security issue, primarily because
  any untrusted text should be sanitized by PQescapeLiteral or
  the like before being incorporated into a SQL or psql command.
  (If an app fails to do so, the same technique can be used to
  cause SQL injection, with probably much more dire consequences
  than a mere client-program crash.)  Those functions were already
  made proof against this class of problem, cf CVE-2006-2313.

  To fix, invent PQmblenBounded() which is like PQmblen() except it
  won't return more than the number of bytes remaining in the string.
  In HEAD we can make this a new libpq function, as PQmblen() is.
  It seems imprudent to change libpq's API in stable branches though,
  so in the back branches define PQmblenBounded as a macro in the files
  that need it.  (Note that just changing PQmblen's behavior would not
  be a good idea; notably, it would completely break the escaping
  functions' defense against this exact problem.  So we just want a
  version for those callers that don't have any better way of handling
  this issue.)

  Per private report from houjingyi.  Back-patch to all supported branches.
  e6f43f7786bdd01c93d6bdcb429d3e724022bf1c:Modify libpq's string-escaping routines to be aware of encoding considerations
  and standard_conforming_strings.  The encoding changes are needed for proper
  escaping in multibyte encodings, as per the SQL-injection vulnerabilities
  noted in CVE-2006-2313 and CVE-2006-2314.  Concurrent fixes are being applied
  to the server to ensure that it rejects queries that may have been corrupted
  by attempted SQL injection, but this merely guarantees that unpatched clients
  will fail rather than allow injection.  An actual fix requires changing the
  client-side code.  While at it we have also fixed these routines to understand
  about standard_conforming_strings, so that the upcoming changeover to SQL-spec
  string syntax can be somewhat transparent to client code.

  Since the existing API of PQescapeString and PQescapeBytea provides no way to
  inform them which settings are in use, these functions are now deprecated in
  favor of new functions PQescapeStringConn and PQescapeByteaConn.  The new
  functions take the PGconn to which the string will be sent as an additional
  parameter, and look inside the connection structure to determine what to do.
  So as to provide some functionality for clients using the old functions,
  libpq stores the latest encoding and standard_conforming_strings values
  received from the backend in static variables, and the old functions consult
  these variables.  This will work reliably in clients using only one Postgres
  connection at a time, or even multiple connections if they all use the same
  encoding and string syntax settings; which should cover many practical
  scenarios.

  Clients that use homebrew escaping methods, such as PHP's addslashes()
  function or even hardwired regexp substitution, will require extra effort
  to fix :-(.  It is strongly recommended that such code be replaced by use of
  PQescapeStringConn/PQescapeByteaConn if at all feasible.
  96871fc236a19a4c3c74dbab81c63838e7de0c32:Modify libpq's string-escaping routines to be aware of encoding considerations
  and standard_conforming_strings.  The encoding changes are needed for proper
  escaping in multibyte encodings, as per the SQL-injection vulnerabilities
  noted in CVE-2006-2313 and CVE-2006-2314.  Concurrent fixes are being applied
  to the server to ensure that it rejects queries that may have been corrupted
  by attempted SQL injection, but this merely guarantees that unpatched clients
  will fail rather than allow injection.  An actual fix requires changing the
  client-side code.  While at it we have also fixed these routines to understand
  about standard_conforming_strings, so that the upcoming changeover to SQL-spec
  string syntax can be somewhat transparent to client code.

  Since the existing API of PQescapeString and PQescapeBytea provides no way to
  inform them which settings are in use, these functions are now deprecated in
  favor of new functions PQescapeStringConn and PQescapeByteaConn.  The new
  functions take the PGconn to which the string will be sent as an additional
  parameter, and look inside the connection structure to determine what to do.
  So as to provide some functionality for clients using the old functions,
  libpq stores the latest encoding and standard_conforming_strings values
  received from the backend in static variables, and the old functions consult
  these variables.  This will work reliably in clients using only one Postgres
  connection at a time, or even multiple connections if they all use the same
  encoding and string syntax settings; which should cover many practical
  scenarios.

  Clients that use homebrew escaping methods, such as PHP's addslashes()
  function or even hardwired regexp substitution, will require extra effort
  to fix :-(.  It is strongly recommended that such code be replaced by use of
  PQescapeStringConn/PQescapeByteaConn if at all feasible.
  94dec9114b5c3b29966223f4e9f2a0c997070e1c:Modify libpq's string-escaping routines to be aware of encoding considerations
  and standard_conforming_strings.  The encoding changes are needed for proper
  escaping in multibyte encodings, as per the SQL-injection vulnerabilities
  noted in CVE-2006-2313 and CVE-2006-2314.  Concurrent fixes are being applied
  to the server to ensure that it rejects queries that may have been corrupted
  by attempted SQL injection, but this merely guarantees that unpatched clients
  will fail rather than allow injection.  An actual fix requires changing the
  client-side code.  While at it we have also fixed these routines to understand
  about standard_conforming_strings, so that the upcoming changeover to SQL-spec
  string syntax can be somewhat transparent to client code.

  Since the existing API of PQescapeString and PQescapeBytea provides no way to
  inform them which settings are in use, these functions are now deprecated in
  favor of new functions PQescapeStringConn and PQescapeByteaConn.  The new
  functions take the PGconn to which the string will be sent as an additional
  parameter, and look inside the connection structure to determine what to do.
  So as to provide some functionality for clients using the old functions,
  libpq stores the latest encoding and standard_conforming_strings values
  received from the backend in static variables, and the old functions consult
  these variables.  This will work reliably in clients using only one Postgres
  connection at a time, or even multiple connections if they all use the same
  encoding and string syntax settings; which should cover many practical
  scenarios.

  Clients that use homebrew escaping methods, such as PHP's addslashes()
  function or even hardwired regexp substitution, will require extra effort
  to fix :-(.  It is strongly recommended that such code be replaced by use of
  PQescapeStringConn/PQescapeByteaConn if at all feasible.
  7f615cab574dc5d93a39a43d9b720c17f19f63e1:Modify libpq's string-escaping routines to be aware of encoding considerations
  and standard_conforming_strings.  The encoding changes are needed for proper
  escaping in multibyte encodings, as per the SQL-injection vulnerabilities
  noted in CVE-2006-2313 and CVE-2006-2314.  Concurrent fixes are being applied
  to the server to ensure that it rejects queries that may have been corrupted
  by attempted SQL injection, but this merely guarantees that unpatched clients
  will fail rather than allow injection.  An actual fix requires changing the
  client-side code.  While at it we have also fixed these routines to understand
  about standard_conforming_strings, so that the upcoming changeover to SQL-spec
  string syntax can be somewhat transparent to client code.

  Since the existing API of PQescapeString and PQescapeBytea provides no way to
  inform them which settings are in use, these functions are now deprecated in
  favor of new functions PQescapeStringConn and PQescapeByteaConn.  The new
  functions take the PGconn to which the string will be sent as an additional
  parameter, and look inside the connection structure to determine what to do.
  So as to provide some functionality for clients using the old functions,
  libpq stores the latest encoding and standard_conforming_strings values
  received from the backend in static variables, and the old functions consult
  these variables.  This will work reliably in clients using only one Postgres
  connection at a time, or even multiple connections if they all use the same
  encoding and string syntax settings; which should cover many practical
  scenarios.

  Clients that use homebrew escaping methods, such as PHP's addslashes()
  function or even hardwired regexp substitution, will require extra effort
  to fix :-(.  It is strongly recommended that such code be replaced by use of
  PQescapeStringConn/PQescapeByteaConn if at all feasible.
  515112f9d4874aaedd0c093f41c0ba3e0bf7f660:Modify libpq's string-escaping routines to be aware of encoding considerations
  and standard_conforming_strings.  The encoding changes are needed for proper
  escaping in multibyte encodings, as per the SQL-injection vulnerabilities
  noted in CVE-2006-2313 and CVE-2006-2314.  Concurrent fixes are being applied
  to the server to ensure that it rejects queries that may have been corrupted
  by attempted SQL injection, but this merely guarantees that unpatched clients
  will fail rather than allow injection.  An actual fix requires changing the
  client-side code.  While at it we have also fixed these routines to understand
  about standard_conforming_strings, so that the upcoming changeover to SQL-spec
  string syntax can be somewhat transparent to client code.

  Since the existing API of PQescapeString and PQescapeBytea provides no way to
  inform them which settings are in use, these functions are now deprecated in
  favor of new functions PQescapeStringConn and PQescapeByteaConn.  The new
  functions take the PGconn to which the string will be sent as an additional
  parameter, and look inside the connection structure to determine what to do.
  So as to provide some functionality for clients using the old functions,
  libpq stores the latest encoding and standard_conforming_strings values
  received from the backend in static variables, and the old functions consult
  these variables.  This will work reliably in clients using only one Postgres
  connection at a time, or even multiple connections if they all use the same
  encoding and string syntax settings; which should cover many practical
  scenarios.

  Clients that use homebrew escaping methods, such as PHP's addslashes()
  function or even hardwired regexp substitution, will require extra effort
  to fix :-(.  It is strongly recommended that such code be replaced by use of
  PQescapeStringConn/PQescapeByteaConn if at all feasible.
  5c4de6704454cebb57662a272f823159844ecf72:Change the backend to reject strings containing invalidly-encoded multibyte
  characters in all cases.  Formerly we mostly just threw warnings for invalid
  input, and failed to detect it at all if no encoding conversion was required.
  The tighter check is needed to defend against SQL-injection attacks as per
  CVE-2006-2313 (further details will be published after release).  Embedded
  zero (null) bytes will be rejected as well.  The checks are applied during
  input to the backend (receipt from client or COPY IN), so it no longer seems
  necessary to check in textin() and related routines; any string arriving at
  those functions will already have been validated.  Conversion failure
  reporting (for characters with no equivalent in the destination encoding)
  has been cleaned up and made consistent while at it.

  Also, fix a few longstanding errors in little-used encoding conversion
  routines: win1251_to_iso, win866_to_iso, euc_tw_to_big5, euc_tw_to_mic,
  mic_to_euc_tw were all broken to varying extents.

  Patches by Tatsuo Ishii and Tom Lane.  Thanks to Akio Ishida and Yasuo Ohgaki
  for identifying the security issues.
  b252352241fdeea313831e4c0da6317b70537514:Change the backend to reject strings containing invalidly-encoded multibyte
  characters in all cases.  Formerly we mostly just threw warnings for invalid
  input, and failed to detect it at all if no encoding conversion was required.
  The tighter check is needed to defend against SQL-injection attacks as per
  CVE-2006-2313 (further details will be published after release).  Embedded
  zero (null) bytes will be rejected as well.  The checks are applied during
  input to the backend (receipt from client or COPY IN), so it no longer seems
  necessary to check in textin() and related routines; any string arriving at
  those functions will already have been validated.  Conversion failure
  reporting (for characters with no equivalent in the destination encoding)
  has been cleaned up and made consistent while at it.

  Also, fix a few longstanding errors in little-used encoding conversion
  routines: win1251_to_iso, win866_to_iso, euc_tw_to_big5, euc_tw_to_mic,
  mic_to_euc_tw were all broken to varying extents.

  Patches by Tatsuo Ishii and Tom Lane.  Thanks to Akio Ishida and Yasuo Ohgaki
  for identifying the security issues.
  70794254a1cc8557e4bddafbfdc4ff2567c653ce:Change the backend to reject strings containing invalidly-encoded multibyte
  characters in all cases.  Formerly we mostly just threw warnings for invalid
  input, and failed to detect it at all if no encoding conversion was required.
  The tighter check is needed to defend against SQL-injection attacks as per
  CVE-2006-2313 (further details will be published after release).  Embedded
  zero (null) bytes will be rejected as well.  The checks are applied during
  input to the backend (receipt from client or COPY IN), so it no longer seems
  necessary to check in textin() and related routines; any string arriving at
  those functions will already have been validated.  Conversion failure
  reporting (for characters with no equivalent in the destination encoding)
  has been cleaned up and made consistent while at it.

  Also, fix a few longstanding errors in little-used encoding conversion
  routines: win1251_to_iso, win866_to_iso, euc_tw_to_big5, euc_tw_to_mic,
  mic_to_euc_tw were all broken to varying extents.

  Patches by Tatsuo Ishii and Tom Lane.  Thanks to Akio Ishida and Yasuo Ohgaki
  for identifying the security issues.
  8fe643b41b93823f8db54149f3b5b3741d6c3613:Change the backend to reject strings containing invalidly-encoded multibyte
  characters in all cases.  Formerly we mostly just threw warnings for invalid
  input, and failed to detect it at all if no encoding conversion was required.
  The tighter check is needed to defend against SQL-injection attacks as per
  CVE-2006-2313 (further details will be published after release).  Embedded
  zero (null) bytes will be rejected as well.  The checks are applied during
  input to the backend (receipt from client or COPY IN), so it no longer seems
  necessary to check in textin() and related routines; any string arriving at
  those functions will already have been validated.  Conversion failure
  reporting (for characters with no equivalent in the destination encoding)
  has been cleaned up and made consistent while at it.

  Also, fix a few longstanding errors in little-used encoding conversion
  routines: win1251_to_iso, win866_to_iso, euc_tw_to_big5, euc_tw_to_mic,
  mic_to_euc_tw were all broken to varying extents.

  Patches by Tatsuo Ishii and Tom Lane.  Thanks to Akio Ishida and Yasuo Ohgaki
  for identifying the security issues.
  c61a2f58418e9fa1d5d36a22351b7350b8ad1400:Change the backend to reject strings containing invalidly-encoded multibyte
  characters in all cases.  Formerly we mostly just threw warnings for invalid
  input, and failed to detect it at all if no encoding conversion was required.
  The tighter check is needed to defend against SQL-injection attacks as per
  CVE-2006-2313 (further details will be published after release).  Embedded
  zero (null) bytes will be rejected as well.  The checks are applied during
  input to the backend (receipt from client or COPY IN), so it no longer seems
  necessary to check in textin() and related routines; any string arriving at
  those functions will already have been validated.  Conversion failure
  reporting (for characters with no equivalent in the destination encoding)
  has been cleaned up and made consistent while at it.

  Also, fix a few longstanding errors in little-used encoding conversion
  routines: win1251_to_iso, win866_to_iso, euc_tw_to_big5, euc_tw_to_mic,
  mic_to_euc_tw were all broken to varying extents.

  Patches by Tatsuo Ishii and Tom Lane.  Thanks to Akio Ishida and Yasuo Ohgaki
  for identifying the security issues.
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 7f615cab574dc5d93a39a43d9b720c17f19f63e1
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 4826fe4c5674b93f3725ce84a091cee521907aae
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 89a5499ef9e477beb97d742d4df6fc8f601d87d5
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e6f43f7786bdd01c93d6bdcb429d3e724022bf1c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b252352241fdeea313831e4c0da6317b70537514
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 94dec9114b5c3b29966223f4e9f2a0c997070e1c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: fc896f45d6d859d9da52106cf42dc01dce88c224
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 8fe643b41b93823f8db54149f3b5b3741d6c3613
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: c61a2f58418e9fa1d5d36a22351b7350b8ad1400
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: ac600c54165631d5266c8aa7c5cb8c96ac589138
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 5c4de6704454cebb57662a272f823159844ecf72
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 70794254a1cc8557e4bddafbfdc4ff2567c653ce
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 515112f9d4874aaedd0c093f41c0ba3e0bf7f660
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 5b64368742b5cdf73395bd5ddd66b5edcbc20823
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 96871fc236a19a4c3c74dbab81c63838e7de0c32
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 42f94f56bf9559f0a3cf5f3ffde50655834694ee
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/42f94f56bf9559f0a3cf5f3ffde50655834694ee
    reference_type: commit
    reference_id: 42f94f56bf9559f0a3cf5f3ffde50655834694ee
  - url: https://github.com/postgres/postgres/tree/4826fe4c5674b93f3725ce84a091cee521907aae
    reference_type: commit
    reference_id: 4826fe4c5674b93f3725ce84a091cee521907aae
  - url: https://github.com/postgres/postgres/tree/515112f9d4874aaedd0c093f41c0ba3e0bf7f660
    reference_type: commit
    reference_id: 515112f9d4874aaedd0c093f41c0ba3e0bf7f660
  - url: https://github.com/postgres/postgres/tree/5b64368742b5cdf73395bd5ddd66b5edcbc20823
    reference_type: commit
    reference_id: 5b64368742b5cdf73395bd5ddd66b5edcbc20823
  - url: https://github.com/postgres/postgres/tree/5c4de6704454cebb57662a272f823159844ecf72
    reference_type: commit
    reference_id: 5c4de6704454cebb57662a272f823159844ecf72
  - url: https://github.com/postgres/postgres/tree/70794254a1cc8557e4bddafbfdc4ff2567c653ce
    reference_type: commit
    reference_id: 70794254a1cc8557e4bddafbfdc4ff2567c653ce
  - url: https://github.com/postgres/postgres/tree/7f615cab574dc5d93a39a43d9b720c17f19f63e1
    reference_type: commit
    reference_id: 7f615cab574dc5d93a39a43d9b720c17f19f63e1
  - url: https://github.com/postgres/postgres/tree/89a5499ef9e477beb97d742d4df6fc8f601d87d5
    reference_type: commit
    reference_id: 89a5499ef9e477beb97d742d4df6fc8f601d87d5
  - url: https://github.com/postgres/postgres/tree/8fe643b41b93823f8db54149f3b5b3741d6c3613
    reference_type: commit
    reference_id: 8fe643b41b93823f8db54149f3b5b3741d6c3613
  - url: https://github.com/postgres/postgres/tree/94dec9114b5c3b29966223f4e9f2a0c997070e1c
    reference_type: commit
    reference_id: 94dec9114b5c3b29966223f4e9f2a0c997070e1c
  - url: https://github.com/postgres/postgres/tree/96871fc236a19a4c3c74dbab81c63838e7de0c32
    reference_type: commit
    reference_id: 96871fc236a19a4c3c74dbab81c63838e7de0c32
  - url: https://github.com/postgres/postgres/tree/ac600c54165631d5266c8aa7c5cb8c96ac589138
    reference_type: commit
    reference_id: ac600c54165631d5266c8aa7c5cb8c96ac589138
  - url: https://github.com/postgres/postgres/tree/b252352241fdeea313831e4c0da6317b70537514
    reference_type: commit
    reference_id: b252352241fdeea313831e4c0da6317b70537514
  - url: https://github.com/postgres/postgres/tree/c61a2f58418e9fa1d5d36a22351b7350b8ad1400
    reference_type: commit
    reference_id: c61a2f58418e9fa1d5d36a22351b7350b8ad1400
  - url: https://github.com/postgres/postgres/tree/e6f43f7786bdd01c93d6bdcb429d3e724022bf1c
    reference_type: commit
    reference_id: e6f43f7786bdd01c93d6bdcb429d3e724022bf1c
  - url: https://github.com/postgres/postgres/tree/fc896f45d6d859d9da52106cf42dc01dce88c224
    reference_type: commit
    reference_id: fc896f45d6d859d9da52106cf42dc01dce88c224
