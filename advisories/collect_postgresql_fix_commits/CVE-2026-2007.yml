advisory_id: CVE-2026-2007
datasource_id: collect_postgresql_fix_commits/CVE-2026-2007
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  8771763bd97607882dd47925dceea0859a59ce97:Last-minute updates for release notes.

  Security: CVE-2026-2003, CVE-2026-2004, CVE-2026-2005, CVE-2026-2006, CVE-2026-2007
  749e616b7693cec9baaaf8744d740d436693ac91:Last-minute updates for release notes.

  Security: CVE-2026-2003, CVE-2026-2004, CVE-2026-2005, CVE-2026-2006, CVE-2026-2007
  9889b3b64fe6bb52084159ae9bc5f2f5943fdd8a:Last-minute updates for release notes.

  Security: CVE-2026-2003, CVE-2026-2004, CVE-2026-2005, CVE-2026-2006, CVE-2026-2007
  a3acb409025a2f8e2cb93346bbc1d87281f861fc:Last-minute updates for release notes.

  Security: CVE-2026-2003, CVE-2026-2004, CVE-2026-2005, CVE-2026-2006, CVE-2026-2007
  30d2603f5c340133ca03e098fcaa9c242843d5e1:Last-minute updates for release notes.

  Security: CVE-2026-2003, CVE-2026-2004, CVE-2026-2005, CVE-2026-2006, CVE-2026-2007
  e0965fb1a8550716db08e2183560be3546851647:Fix buffer overflows in pg_trgm due to lower-casing

  The code made a subtle assumption that the lower-cased version of a
  string never has more characters than the original. That is not always
  true. For example, in a database with the latin9 encoding:

      latin9db=# select lower(U&'\00CC' COLLATE "lt-x-icu");
         lower
      -----------
       i\x1A\x1A
      (1 row)

  In this example, lower-casing expands the single input character into
  three characters.

  The generate_trgm_only() function relied on that assumption in two
  ways:

  - It used "slen * pg_database_encoding_max_length() + 4" to allocate
    the buffer to hold the lowercased and blank-padded string. That
    formula accounts for expansion if the lower-case characters are
    longer (in bytes) than the originals, but it's still not enough if
    the lower-cased string contains more *characters* than the original.

  - Its callers sized the output array to hold the trigrams extracted
    from the input string with the formula "(slen / 2 + 1) * 3", where
    'slen' is the input string length in bytes. (The formula was
    generous to account for the possibility that RPADDING was set to 2.)
    That's also not enough if one input byte can turn into multiple
    characters.

  To fix, introduce a growable trigram array and give up on trying to
  choose the correct max buffer sizes ahead of time.

  Backpatch to v18, but no further. In previous versions lower-casing was
  done character by character, and thus the assumption that lower-casing
  doesn't change the character length was valid. That was changed in v18,
  commit fb1a18810f.

  Security: CVE-2026-2007
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Reviewed-by: Jeff Davis <pgsql@j-davis.com>
  18548681da38b2376d0c071d568b9d0c1f8b6ad2:Remove 'charlen' argument from make_trigrams()

  The function assumed that if charlen == bytelen, there are no
  multibyte characters in the string. That's sensible, but the callers
  were a little careless in how they calculated the lengths. The callers
  converted the string to lowercase before calling make_trigram(), and
  the 'charlen' value was calculated *before* the conversion to
  lowercase while 'bytelen' was calculated after the conversion. If the
  lowercased string had a different number of characters than the
  original, make_trigram() might incorrectly apply the fastpath and
  treat all the bytes as single-byte characters, or fail to apply the
  fastpath (which is harmless), or it might hit the "Assert(bytelen ==
  charlen)" assertion. I'm not aware of any locale / character
  combinations where you could hit that assertion in practice,
  i.e. where a string converted to lowercase would have fewer characters
  than the original, but it seems best to avoid making that assumption.

  To fix, remove the 'charlen' argument. To keep the performance when
  there are no multibyte characters, always try the fast path first, but
  check the input for multibyte characters as we go. The check on each
  byte adds some overhead, but it's close enough. And to compensate, the
  find_word() function no longer needs to count the characters.

  This fixes one small bug in make_trigrams(): in the multibyte
  codepath, it peeked at the byte just after the end of the input
  string. When compiled with IGNORECASE, that was harmless because there
  is always a NUL byte or blank after the input string. But with
  !IGNORECASE, the call from generate_wildcard_trgm() doesn't guarantee
  that.

  Backpatch to v18, but no further. In previous versions lower-casing was
  done character by character, and thus the assumption that lower-casing
  doesn't change the character length was valid. That was changed in v18,
  commit fb1a18810f.

  Security: CVE-2026-2007
  Reviewed-by: Noah Misch <noah@leadboat.com>
  00896ddaf41fa7b725991120678d544c18c6af70:Fix buffer overflows in pg_trgm due to lower-casing

  The code made a subtle assumption that the lower-cased version of a
  string never has more characters than the original. That is not always
  true. For example, in a database with the latin9 encoding:

      latin9db=# select lower(U&'\00CC' COLLATE "lt-x-icu");
         lower
      -----------
       i\x1A\x1A
      (1 row)

  In this example, lower-casing expands the single input character into
  three characters.

  The generate_trgm_only() function relied on that assumption in two
  ways:

  - It used "slen * pg_database_encoding_max_length() + 4" to allocate
    the buffer to hold the lowercased and blank-padded string. That
    formula accounts for expansion if the lower-case characters are
    longer (in bytes) than the originals, but it's still not enough if
    the lower-cased string contains more *characters* than the original.

  - Its callers sized the output array to hold the trigrams extracted
    from the input string with the formula "(slen / 2 + 1) * 3", where
    'slen' is the input string length in bytes. (The formula was
    generous to account for the possibility that RPADDING was set to 2.)
    That's also not enough if one input byte can turn into multiple
    characters.

  To fix, introduce a growable trigram array and give up on trying to
  choose the correct max buffer sizes ahead of time.

  Backpatch to v18, but no further. In previous versions lower-casing was
  done character by character, and thus the assumption that lower-casing
  doesn't change the character length was valid. That was changed in v18,
  commit fb1a18810f.

  Security: CVE-2026-2007
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Reviewed-by: Jeff Davis <pgsql@j-davis.com>
  54598670fe0a191f49848d1a1a8ab09d99616e71:Remove 'charlen' argument from make_trigrams()

  The function assumed that if charlen == bytelen, there are no
  multibyte characters in the string. That's sensible, but the callers
  were a little careless in how they calculated the lengths. The callers
  converted the string to lowercase before calling make_trigram(), and
  the 'charlen' value was calculated *before* the conversion to
  lowercase while 'bytelen' was calculated after the conversion. If the
  lowercased string had a different number of characters than the
  original, make_trigram() might incorrectly apply the fastpath and
  treat all the bytes as single-byte characters, or fail to apply the
  fastpath (which is harmless), or it might hit the "Assert(bytelen ==
  charlen)" assertion. I'm not aware of any locale / character
  combinations where you could hit that assertion in practice,
  i.e. where a string converted to lowercase would have fewer characters
  than the original, but it seems best to avoid making that assumption.

  To fix, remove the 'charlen' argument. To keep the performance when
  there are no multibyte characters, always try the fast path first, but
  check the input for multibyte characters as we go. The check on each
  byte adds some overhead, but it's close enough. And to compensate, the
  find_word() function no longer needs to count the characters.

  This fixes one small bug in make_trigrams(): in the multibyte
  codepath, it peeked at the byte just after the end of the input
  string. When compiled with IGNORECASE, that was harmless because there
  is always a NUL byte or blank after the input string. But with
  !IGNORECASE, the call from generate_wildcard_trgm() doesn't guarantee
  that.

  Backpatch to v18, but no further. In previous versions lower-casing was
  done character by character, and thus the assumption that lower-casing
  doesn't change the character length was valid. That was changed in v18,
  commit fb1a18810f.

  Security: CVE-2026-2007
  Reviewed-by: Noah Misch <noah@leadboat.com>
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a3acb409025a2f8e2cb93346bbc1d87281f861fc
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 18548681da38b2376d0c071d568b9d0c1f8b6ad2
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 8771763bd97607882dd47925dceea0859a59ce97
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 00896ddaf41fa7b725991120678d544c18c6af70
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 54598670fe0a191f49848d1a1a8ab09d99616e71
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 30d2603f5c340133ca03e098fcaa9c242843d5e1
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e0965fb1a8550716db08e2183560be3546851647
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 749e616b7693cec9baaaf8744d740d436693ac91
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9889b3b64fe6bb52084159ae9bc5f2f5943fdd8a
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/00896ddaf41fa7b725991120678d544c18c6af70
    reference_type: commit
    reference_id: 00896ddaf41fa7b725991120678d544c18c6af70
  - url: https://github.com/postgres/postgres/tree/18548681da38b2376d0c071d568b9d0c1f8b6ad2
    reference_type: commit
    reference_id: 18548681da38b2376d0c071d568b9d0c1f8b6ad2
  - url: https://github.com/postgres/postgres/tree/30d2603f5c340133ca03e098fcaa9c242843d5e1
    reference_type: commit
    reference_id: 30d2603f5c340133ca03e098fcaa9c242843d5e1
  - url: https://github.com/postgres/postgres/tree/54598670fe0a191f49848d1a1a8ab09d99616e71
    reference_type: commit
    reference_id: 54598670fe0a191f49848d1a1a8ab09d99616e71
  - url: https://github.com/postgres/postgres/tree/749e616b7693cec9baaaf8744d740d436693ac91
    reference_type: commit
    reference_id: 749e616b7693cec9baaaf8744d740d436693ac91
  - url: https://github.com/postgres/postgres/tree/8771763bd97607882dd47925dceea0859a59ce97
    reference_type: commit
    reference_id: 8771763bd97607882dd47925dceea0859a59ce97
  - url: https://github.com/postgres/postgres/tree/9889b3b64fe6bb52084159ae9bc5f2f5943fdd8a
    reference_type: commit
    reference_id: 9889b3b64fe6bb52084159ae9bc5f2f5943fdd8a
  - url: https://github.com/postgres/postgres/tree/a3acb409025a2f8e2cb93346bbc1d87281f861fc
    reference_type: commit
    reference_id: a3acb409025a2f8e2cb93346bbc1d87281f861fc
  - url: https://github.com/postgres/postgres/tree/e0965fb1a8550716db08e2183560be3546851647
    reference_type: commit
    reference_id: e0965fb1a8550716db08e2183560be3546851647
