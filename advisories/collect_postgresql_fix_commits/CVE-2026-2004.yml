advisory_id: CVE-2026-2004
datasource_id: collect_postgresql_fix_commits/CVE-2026-2004
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  8771763bd97607882dd47925dceea0859a59ce97:Last-minute updates for release notes.

  Security: CVE-2026-2003, CVE-2026-2004, CVE-2026-2005, CVE-2026-2006, CVE-2026-2007
  749e616b7693cec9baaaf8744d740d436693ac91:Last-minute updates for release notes.

  Security: CVE-2026-2003, CVE-2026-2004, CVE-2026-2005, CVE-2026-2006, CVE-2026-2007
  9889b3b64fe6bb52084159ae9bc5f2f5943fdd8a:Last-minute updates for release notes.

  Security: CVE-2026-2003, CVE-2026-2004, CVE-2026-2005, CVE-2026-2006, CVE-2026-2007
  a3acb409025a2f8e2cb93346bbc1d87281f861fc:Last-minute updates for release notes.

  Security: CVE-2026-2003, CVE-2026-2004, CVE-2026-2005, CVE-2026-2006, CVE-2026-2007
  30d2603f5c340133ca03e098fcaa9c242843d5e1:Last-minute updates for release notes.

  Security: CVE-2026-2003, CVE-2026-2004, CVE-2026-2005, CVE-2026-2006, CVE-2026-2007
  7e82d9a04d0fba0678f4349f23b03bbdf83193f7:Harden _int_matchsel() against being attached to the wrong operator.

  While the preceding commit prevented such attachments from occurring
  in future, this one aims to prevent further abuse of any already-
  created operator that exposes _int_matchsel to the wrong data types.
  (No other contrib module has a vulnerable selectivity estimator.)

  We need only check that the Const we've found in the query is indeed
  of the type we expect (query_int), but there's a difficulty: as an
  extension type, query_int doesn't have a fixed OID that we could
  hard-code into the estimator.

  Therefore, the bulk of this patch consists of infrastructure to let
  an extension function securely look up the OID of a datatype
  belonging to the same extension.  (Extension authors have requested
  such functionality before, so we anticipate that this code will
  have additional non-security uses, and may soon be extended to allow
  looking up other kinds of SQL objects.)

  This is done by first finding the extension that owns the calling
  function (there can be only one), and then thumbing through the
  objects owned by that extension to find a type that has the desired
  name.  This is relatively expensive, especially for large extensions,
  so a simple cache is put in front of these lookups.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  deb464a40852b381320264a2249b6f7641227db0:Harden _int_matchsel() against being attached to the wrong operator.

  While the preceding commit prevented such attachments from occurring
  in future, this one aims to prevent further abuse of any already-
  created operator that exposes _int_matchsel to the wrong data types.
  (No other contrib module has a vulnerable selectivity estimator.)

  We need only check that the Const we've found in the query is indeed
  of the type we expect (query_int), but there's a difficulty: as an
  extension type, query_int doesn't have a fixed OID that we could
  hard-code into the estimator.

  Therefore, the bulk of this patch consists of infrastructure to let
  an extension function securely look up the OID of a datatype
  belonging to the same extension.  (Extension authors have requested
  such functionality before, so we anticipate that this code will
  have additional non-security uses, and may soon be extended to allow
  looking up other kinds of SQL objects.)

  This is done by first finding the extension that owns the calling
  function (there can be only one), and then thumbing through the
  objects owned by that extension to find a type that has the desired
  name.  This is relatively expensive, especially for large extensions,
  so a simple cache is put in front of these lookups.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  c0887b39dc5440babd935ab9cab84fbf80454389:Harden _int_matchsel() against being attached to the wrong operator.

  While the preceding commit prevented such attachments from occurring
  in future, this one aims to prevent further abuse of any already-
  created operator that exposes _int_matchsel to the wrong data types.
  (No other contrib module has a vulnerable selectivity estimator.)

  We need only check that the Const we've found in the query is indeed
  of the type we expect (query_int), but there's a difficulty: as an
  extension type, query_int doesn't have a fixed OID that we could
  hard-code into the estimator.

  Therefore, the bulk of this patch consists of infrastructure to let
  an extension function securely look up the OID of a datatype
  belonging to the same extension.  (Extension authors have requested
  such functionality before, so we anticipate that this code will
  have additional non-security uses, and may soon be extended to allow
  looking up other kinds of SQL objects.)

  This is done by first finding the extension that owns the calling
  function (there can be only one), and then thumbing through the
  objects owned by that extension to find a type that has the desired
  name.  This is relatively expensive, especially for large extensions,
  so a simple cache is put in front of these lookups.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  dd3ad2a4d7e8c7bcc34e6574787744b3524d28be:Harden _int_matchsel() against being attached to the wrong operator.

  While the preceding commit prevented such attachments from occurring
  in future, this one aims to prevent further abuse of any already-
  created operator that exposes _int_matchsel to the wrong data types.
  (No other contrib module has a vulnerable selectivity estimator.)

  We need only check that the Const we've found in the query is indeed
  of the type we expect (query_int), but there's a difficulty: as an
  extension type, query_int doesn't have a fixed OID that we could
  hard-code into the estimator.

  Therefore, the bulk of this patch consists of infrastructure to let
  an extension function securely look up the OID of a datatype
  belonging to the same extension.  (Extension authors have requested
  such functionality before, so we anticipate that this code will
  have additional non-security uses, and may soon be extended to allow
  looking up other kinds of SQL objects.)

  This is done by first finding the extension that owns the calling
  function (there can be only one), and then thumbing through the
  objects owned by that extension to find a type that has the desired
  name.  This is relatively expensive, especially for large extensions,
  so a simple cache is put in front of these lookups.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  b69af3dda26104b54d4e728c6946edcc79a8ac61:Harden _int_matchsel() against being attached to the wrong operator.

  While the preceding commit prevented such attachments from occurring
  in future, this one aims to prevent further abuse of any already-
  created operator that exposes _int_matchsel to the wrong data types.
  (No other contrib module has a vulnerable selectivity estimator.)

  We need only check that the Const we've found in the query is indeed
  of the type we expect (query_int), but there's a difficulty: as an
  extension type, query_int doesn't have a fixed OID that we could
  hard-code into the estimator.

  Therefore, the bulk of this patch consists of infrastructure to let
  an extension function securely look up the OID of a datatype
  belonging to the same extension.  (Extension authors have requested
  such functionality before, so we anticipate that this code will
  have additional non-security uses, and may soon be extended to allow
  looking up other kinds of SQL objects.)

  This is done by first finding the extension that owns the calling
  function (there can be only one), and then thumbing through the
  objects owned by that extension to find a type that has the desired
  name.  This is relatively expensive, especially for large extensions,
  so a simple cache is put in front of these lookups.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  8ebdf41c262ccd86407ca684aab3113bdbcf2c66:Harden _int_matchsel() against being attached to the wrong operator.

  While the preceding commit prevented such attachments from occurring
  in future, this one aims to prevent further abuse of any already-
  created operator that exposes _int_matchsel to the wrong data types.
  (No other contrib module has a vulnerable selectivity estimator.)

  We need only check that the Const we've found in the query is indeed
  of the type we expect (query_int), but there's a difficulty: as an
  extension type, query_int doesn't have a fixed OID that we could
  hard-code into the estimator.

  Therefore, the bulk of this patch consists of infrastructure to let
  an extension function securely look up the OID of a datatype
  belonging to the same extension.  (Extension authors have requested
  such functionality before, so we anticipate that this code will
  have additional non-security uses, and may soon be extended to allow
  looking up other kinds of SQL objects.)

  This is done by first finding the extension that owns the calling
  function (there can be only one), and then thumbing through the
  objects owned by that extension to find a type that has the desired
  name.  This is relatively expensive, especially for large extensions,
  so a simple cache is put in front of these lookups.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  ea3bf34986032ba2760538dacbc144b1f6e300fd:Require superuser to install a non-built-in selectivity estimator.

  Selectivity estimators come in two flavors: those that make specific
  assumptions about the data types they are working with, and those
  that don't.  Most of the built-in estimators are of the latter kind
  and are meant to be safely attachable to any operator.  If the
  operator does not behave as the estimator expects, you might get a
  poor estimate, but it won't crash.

  However, estimators that do make datatype assumptions can malfunction
  if they are attached to the wrong operator, since then the data they
  get from pg_statistic may not be of the type they expect.  This can
  rise to the level of a security problem, even permitting arbitrary
  code execution by a user who has the ability to create SQL objects.

  To close this hole, establish a rule that built-in estimators are
  required to protect themselves against being called on the wrong type
  of data.  It does not seem practical however to expect estimators in
  extensions to reach a similar level of security, at least not in the
  near term.  Therefore, also establish a rule that superuser privilege
  is required to attach a non-built-in estimator to an operator.
  We expect that this restriction will have little negative impact on
  extensions, since estimators generally have to be written in C and
  thus superuser privilege is required to create them in the first
  place.

  This commit changes the privilege checks in CREATE/ALTER OPERATOR
  to enforce the rule about superuser privilege, and fixes a couple
  of built-in estimators that were making datatype assumptions without
  sufficiently checking that they're valid.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  b764b26f2e0a0a57057f301ca87e6a604f5e708b:Require superuser to install a non-built-in selectivity estimator.

  Selectivity estimators come in two flavors: those that make specific
  assumptions about the data types they are working with, and those
  that don't.  Most of the built-in estimators are of the latter kind
  and are meant to be safely attachable to any operator.  If the
  operator does not behave as the estimator expects, you might get a
  poor estimate, but it won't crash.

  However, estimators that do make datatype assumptions can malfunction
  if they are attached to the wrong operator, since then the data they
  get from pg_statistic may not be of the type they expect.  This can
  rise to the level of a security problem, even permitting arbitrary
  code execution by a user who has the ability to create SQL objects.

  To close this hole, establish a rule that built-in estimators are
  required to protect themselves against being called on the wrong type
  of data.  It does not seem practical however to expect estimators in
  extensions to reach a similar level of security, at least not in the
  near term.  Therefore, also establish a rule that superuser privilege
  is required to attach a non-built-in estimator to an operator.
  We expect that this restriction will have little negative impact on
  extensions, since estimators generally have to be written in C and
  thus superuser privilege is required to create them in the first
  place.

  This commit changes the privilege checks in CREATE/ALTER OPERATOR
  to enforce the rule about superuser privilege, and fixes a couple
  of built-in estimators that were making datatype assumptions without
  sufficiently checking that they're valid.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  91d7c0bfdd4ae1da0aa3946e35eb1327b5ca2e6d:Require superuser to install a non-built-in selectivity estimator.

  Selectivity estimators come in two flavors: those that make specific
  assumptions about the data types they are working with, and those
  that don't.  Most of the built-in estimators are of the latter kind
  and are meant to be safely attachable to any operator.  If the
  operator does not behave as the estimator expects, you might get a
  poor estimate, but it won't crash.

  However, estimators that do make datatype assumptions can malfunction
  if they are attached to the wrong operator, since then the data they
  get from pg_statistic may not be of the type they expect.  This can
  rise to the level of a security problem, even permitting arbitrary
  code execution by a user who has the ability to create SQL objects.

  To close this hole, establish a rule that built-in estimators are
  required to protect themselves against being called on the wrong type
  of data.  It does not seem practical however to expect estimators in
  extensions to reach a similar level of security, at least not in the
  near term.  Therefore, also establish a rule that superuser privilege
  is required to attach a non-built-in estimator to an operator.
  We expect that this restriction will have little negative impact on
  extensions, since estimators generally have to be written in C and
  thus superuser privilege is required to create them in the first
  place.

  This commit changes the privilege checks in CREATE/ALTER OPERATOR
  to enforce the rule about superuser privilege, and fixes a couple
  of built-in estimators that were making datatype assumptions without
  sufficiently checking that they're valid.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  bbf5bcf587bdd6f8fe446456fe3a515a00772f3c:Require superuser to install a non-built-in selectivity estimator.

  Selectivity estimators come in two flavors: those that make specific
  assumptions about the data types they are working with, and those
  that don't.  Most of the built-in estimators are of the latter kind
  and are meant to be safely attachable to any operator.  If the
  operator does not behave as the estimator expects, you might get a
  poor estimate, but it won't crash.

  However, estimators that do make datatype assumptions can malfunction
  if they are attached to the wrong operator, since then the data they
  get from pg_statistic may not be of the type they expect.  This can
  rise to the level of a security problem, even permitting arbitrary
  code execution by a user who has the ability to create SQL objects.

  To close this hole, establish a rule that built-in estimators are
  required to protect themselves against being called on the wrong type
  of data.  It does not seem practical however to expect estimators in
  extensions to reach a similar level of security, at least not in the
  near term.  Therefore, also establish a rule that superuser privilege
  is required to attach a non-built-in estimator to an operator.
  We expect that this restriction will have little negative impact on
  extensions, since estimators generally have to be written in C and
  thus superuser privilege is required to create them in the first
  place.

  This commit changes the privilege checks in CREATE/ALTER OPERATOR
  to enforce the rule about superuser privilege, and fixes a couple
  of built-in estimators that were making datatype assumptions without
  sufficiently checking that they're valid.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  66ddac6982c6dc0369dc7b2d251f4d210d704a57:Require superuser to install a non-built-in selectivity estimator.

  Selectivity estimators come in two flavors: those that make specific
  assumptions about the data types they are working with, and those
  that don't.  Most of the built-in estimators are of the latter kind
  and are meant to be safely attachable to any operator.  If the
  operator does not behave as the estimator expects, you might get a
  poor estimate, but it won't crash.

  However, estimators that do make datatype assumptions can malfunction
  if they are attached to the wrong operator, since then the data they
  get from pg_statistic may not be of the type they expect.  This can
  rise to the level of a security problem, even permitting arbitrary
  code execution by a user who has the ability to create SQL objects.

  To close this hole, establish a rule that built-in estimators are
  required to protect themselves against being called on the wrong type
  of data.  It does not seem practical however to expect estimators in
  extensions to reach a similar level of security, at least not in the
  near term.  Therefore, also establish a rule that superuser privilege
  is required to attach a non-built-in estimator to an operator.
  We expect that this restriction will have little negative impact on
  extensions, since estimators generally have to be written in C and
  thus superuser privilege is required to create them in the first
  place.

  This commit changes the privilege checks in CREATE/ALTER OPERATOR
  to enforce the rule about superuser privilege, and fixes a couple
  of built-in estimators that were making datatype assumptions without
  sufficiently checking that they're valid.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  841d42cc4e2f9ca1cf59758fc15619b00a11e148:Require superuser to install a non-built-in selectivity estimator.

  Selectivity estimators come in two flavors: those that make specific
  assumptions about the data types they are working with, and those
  that don't.  Most of the built-in estimators are of the latter kind
  and are meant to be safely attachable to any operator.  If the
  operator does not behave as the estimator expects, you might get a
  poor estimate, but it won't crash.

  However, estimators that do make datatype assumptions can malfunction
  if they are attached to the wrong operator, since then the data they
  get from pg_statistic may not be of the type they expect.  This can
  rise to the level of a security problem, even permitting arbitrary
  code execution by a user who has the ability to create SQL objects.

  To close this hole, establish a rule that built-in estimators are
  required to protect themselves against being called on the wrong type
  of data.  It does not seem practical however to expect estimators in
  extensions to reach a similar level of security, at least not in the
  near term.  Therefore, also establish a rule that superuser privilege
  is required to attach a non-built-in estimator to an operator.
  We expect that this restriction will have little negative impact on
  extensions, since estimators generally have to be written in C and
  thus superuser privilege is required to create them in the first
  place.

  This commit changes the privilege checks in CREATE/ALTER OPERATOR
  to enforce the rule about superuser privilege, and fixes a couple
  of built-in estimators that were making datatype assumptions without
  sufficiently checking that they're valid.

  Reported-by: Daniel Firer as part of zeroday.cloud
  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14
  9fa38c572a980c751690821877d94d171bd1a545:Add a syscache on pg_extension.oid.

  An upcoming patch requires this cache so that it can track updates
  in the pg_extension catalog.  So far though, the EXTENSIONOID cache
  only exists in v18 and up (see 490f869d9).  We can add it in older
  branches without an ABI break, if we are careful not to disturb the
  numbering of existing syscache IDs.

  In v16 and before, that just requires adding the new ID at the end
  of the hand-assigned enum list, ignoring our convention about
  alphabetizing the IDs.  But in v17, genbki.pl enforces alphabetical
  order of the IDs listed in MAKE_SYSCACHE macros.  We can fake it
  out by calling the new cache ZEXTENSIONOID.

  Note that adding a syscache does change the required contents of the
  relcache init file (pg_internal.init).  But that isn't problematic
  since we blow those away at postmaster start for other reasons.

  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14-17
  3ecc84cce3c521894d86267df552a2d5f891a409:Add a syscache on pg_extension.oid.

  An upcoming patch requires this cache so that it can track updates
  in the pg_extension catalog.  So far though, the EXTENSIONOID cache
  only exists in v18 and up (see 490f869d9).  We can add it in older
  branches without an ABI break, if we are careful not to disturb the
  numbering of existing syscache IDs.

  In v16 and before, that just requires adding the new ID at the end
  of the hand-assigned enum list, ignoring our convention about
  alphabetizing the IDs.  But in v17, genbki.pl enforces alphabetical
  order of the IDs listed in MAKE_SYSCACHE macros.  We can fake it
  out by calling the new cache ZEXTENSIONOID.

  Note that adding a syscache does change the required contents of the
  relcache init file (pg_internal.init).  But that isn't problematic
  since we blow those away at postmaster start for other reasons.

  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14-17
  d484bc26013caedd0b210bddfcec43c2ab6fa649:Add a syscache on pg_extension.oid.

  An upcoming patch requires this cache so that it can track updates
  in the pg_extension catalog.  So far though, the EXTENSIONOID cache
  only exists in v18 and up (see 490f869d9).  We can add it in older
  branches without an ABI break, if we are careful not to disturb the
  numbering of existing syscache IDs.

  In v16 and before, that just requires adding the new ID at the end
  of the hand-assigned enum list, ignoring our convention about
  alphabetizing the IDs.  But in v17, genbki.pl enforces alphabetical
  order of the IDs listed in MAKE_SYSCACHE macros.  We can fake it
  out by calling the new cache ZEXTENSIONOID.

  Note that adding a syscache does change the required contents of the
  relcache init file (pg_internal.init).  But that isn't problematic
  since we blow those away at postmaster start for other reasons.

  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14-17
  dbb09fd8e8c19c46f09a6f31b2d607239167181d:Add a syscache on pg_extension.oid.

  An upcoming patch requires this cache so that it can track updates
  in the pg_extension catalog.  So far though, the EXTENSIONOID cache
  only exists in v18 and up (see 490f869d9).  We can add it in older
  branches without an ABI break, if we are careful not to disturb the
  numbering of existing syscache IDs.

  In v16 and before, that just requires adding the new ID at the end
  of the hand-assigned enum list, ignoring our convention about
  alphabetizing the IDs.  But in v17, genbki.pl enforces alphabetical
  order of the IDs listed in MAKE_SYSCACHE macros.  We can fake it
  out by calling the new cache ZEXTENSIONOID.

  Note that adding a syscache does change the required contents of the
  relcache init file (pg_internal.init).  But that isn't problematic
  since we blow those away at postmaster start for other reasons.

  Author: Tom Lane <tgl@sss.pgh.pa.us>
  Reviewed-by: Noah Misch <noah@leadboat.com>
  Security: CVE-2026-2004
  Backpatch-through: 14-17
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a3acb409025a2f8e2cb93346bbc1d87281f861fc
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: c0887b39dc5440babd935ab9cab84fbf80454389
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: ea3bf34986032ba2760538dacbc144b1f6e300fd
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9fa38c572a980c751690821877d94d171bd1a545
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 30d2603f5c340133ca03e098fcaa9c242843d5e1
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9889b3b64fe6bb52084159ae9bc5f2f5943fdd8a
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b69af3dda26104b54d4e728c6946edcc79a8ac61
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 8ebdf41c262ccd86407ca684aab3113bdbcf2c66
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 91d7c0bfdd4ae1da0aa3946e35eb1327b5ca2e6d
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: dd3ad2a4d7e8c7bcc34e6574787744b3524d28be
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 749e616b7693cec9baaaf8744d740d436693ac91
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: deb464a40852b381320264a2249b6f7641227db0
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 3ecc84cce3c521894d86267df552a2d5f891a409
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b764b26f2e0a0a57057f301ca87e6a604f5e708b
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 7e82d9a04d0fba0678f4349f23b03bbdf83193f7
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d484bc26013caedd0b210bddfcec43c2ab6fa649
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: bbf5bcf587bdd6f8fe446456fe3a515a00772f3c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 841d42cc4e2f9ca1cf59758fc15619b00a11e148
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: dbb09fd8e8c19c46f09a6f31b2d607239167181d
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 66ddac6982c6dc0369dc7b2d251f4d210d704a57
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 8771763bd97607882dd47925dceea0859a59ce97
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/30d2603f5c340133ca03e098fcaa9c242843d5e1
    reference_type: commit
    reference_id: 30d2603f5c340133ca03e098fcaa9c242843d5e1
  - url: https://github.com/postgres/postgres/tree/3ecc84cce3c521894d86267df552a2d5f891a409
    reference_type: commit
    reference_id: 3ecc84cce3c521894d86267df552a2d5f891a409
  - url: https://github.com/postgres/postgres/tree/66ddac6982c6dc0369dc7b2d251f4d210d704a57
    reference_type: commit
    reference_id: 66ddac6982c6dc0369dc7b2d251f4d210d704a57
  - url: https://github.com/postgres/postgres/tree/749e616b7693cec9baaaf8744d740d436693ac91
    reference_type: commit
    reference_id: 749e616b7693cec9baaaf8744d740d436693ac91
  - url: https://github.com/postgres/postgres/tree/7e82d9a04d0fba0678f4349f23b03bbdf83193f7
    reference_type: commit
    reference_id: 7e82d9a04d0fba0678f4349f23b03bbdf83193f7
  - url: https://github.com/postgres/postgres/tree/841d42cc4e2f9ca1cf59758fc15619b00a11e148
    reference_type: commit
    reference_id: 841d42cc4e2f9ca1cf59758fc15619b00a11e148
  - url: https://github.com/postgres/postgres/tree/8771763bd97607882dd47925dceea0859a59ce97
    reference_type: commit
    reference_id: 8771763bd97607882dd47925dceea0859a59ce97
  - url: https://github.com/postgres/postgres/tree/8ebdf41c262ccd86407ca684aab3113bdbcf2c66
    reference_type: commit
    reference_id: 8ebdf41c262ccd86407ca684aab3113bdbcf2c66
  - url: https://github.com/postgres/postgres/tree/91d7c0bfdd4ae1da0aa3946e35eb1327b5ca2e6d
    reference_type: commit
    reference_id: 91d7c0bfdd4ae1da0aa3946e35eb1327b5ca2e6d
  - url: https://github.com/postgres/postgres/tree/9889b3b64fe6bb52084159ae9bc5f2f5943fdd8a
    reference_type: commit
    reference_id: 9889b3b64fe6bb52084159ae9bc5f2f5943fdd8a
  - url: https://github.com/postgres/postgres/tree/9fa38c572a980c751690821877d94d171bd1a545
    reference_type: commit
    reference_id: 9fa38c572a980c751690821877d94d171bd1a545
  - url: https://github.com/postgres/postgres/tree/a3acb409025a2f8e2cb93346bbc1d87281f861fc
    reference_type: commit
    reference_id: a3acb409025a2f8e2cb93346bbc1d87281f861fc
  - url: https://github.com/postgres/postgres/tree/b69af3dda26104b54d4e728c6946edcc79a8ac61
    reference_type: commit
    reference_id: b69af3dda26104b54d4e728c6946edcc79a8ac61
  - url: https://github.com/postgres/postgres/tree/b764b26f2e0a0a57057f301ca87e6a604f5e708b
    reference_type: commit
    reference_id: b764b26f2e0a0a57057f301ca87e6a604f5e708b
  - url: https://github.com/postgres/postgres/tree/bbf5bcf587bdd6f8fe446456fe3a515a00772f3c
    reference_type: commit
    reference_id: bbf5bcf587bdd6f8fe446456fe3a515a00772f3c
  - url: https://github.com/postgres/postgres/tree/c0887b39dc5440babd935ab9cab84fbf80454389
    reference_type: commit
    reference_id: c0887b39dc5440babd935ab9cab84fbf80454389
  - url: https://github.com/postgres/postgres/tree/d484bc26013caedd0b210bddfcec43c2ab6fa649
    reference_type: commit
    reference_id: d484bc26013caedd0b210bddfcec43c2ab6fa649
  - url: https://github.com/postgres/postgres/tree/dbb09fd8e8c19c46f09a6f31b2d607239167181d
    reference_type: commit
    reference_id: dbb09fd8e8c19c46f09a6f31b2d607239167181d
  - url: https://github.com/postgres/postgres/tree/dd3ad2a4d7e8c7bcc34e6574787744b3524d28be
    reference_type: commit
    reference_id: dd3ad2a4d7e8c7bcc34e6574787744b3524d28be
  - url: https://github.com/postgres/postgres/tree/deb464a40852b381320264a2249b6f7641227db0
    reference_type: commit
    reference_id: deb464a40852b381320264a2249b6f7641227db0
  - url: https://github.com/postgres/postgres/tree/ea3bf34986032ba2760538dacbc144b1f6e300fd
    reference_type: commit
    reference_id: ea3bf34986032ba2760538dacbc144b1f6e300fd
