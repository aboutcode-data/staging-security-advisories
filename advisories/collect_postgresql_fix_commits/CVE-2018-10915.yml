advisory_id: CVE-2018-10915
datasource_id: collect_postgresql_fix_commits/CVE-2018-10915
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  9d3072d2db2edbc19603d8d65189a504cc4e4712:Last-minute updates for release notes.

  Security: CVE-2018-10915, CVE-2018-10925
  3fd77b1dccb8539d68a517711bfd29310ecc4c04:Last-minute updates for release notes.

  Security: CVE-2018-10915, CVE-2018-10925
  cd2490789e82d9cc0cc5a23e666394f21d0b498f:Last-minute updates for release notes.

  Security: CVE-2018-10915, CVE-2018-10925
  c54f04820a48c33ca15b24552eab29f5137ce462:Last-minute updates for release notes.

  Security: CVE-2018-10915, CVE-2018-10925
  ebeb8d53710ea140dd00eb6506cbe50db4e11dce:Last-minute updates for release notes.

  Security: CVE-2018-10915, CVE-2018-10925
  e0ee93053998b159e395deed7c42e02b1f921552:Last-minute updates for release notes.

  Security: CVE-2018-10915, CVE-2018-10925
  749839c4d53c60de2e51ef82a03f1084e3ec1f6c:Last-minute updates for release notes.

  Security: CVE-2018-10915, CVE-2018-10925
  ab5400469b5db281a4d804ef59b80fcef7c9fc93:Fix failure to reset libpq's state fully between connection attempts.

  The logic in PQconnectPoll() did not take care to ensure that all of
  a PGconn's internal state variables were reset before trying a new
  connection attempt.  If we got far enough in the connection sequence
  to have changed any of these variables, and then decided to try a new
  server address or server name, the new connection might be completed
  with some state that really only applied to the failed connection.

  While this has assorted bad consequences, the only one that is clearly
  a security issue is that password_needed didn't get reset, so that
  if the first server asked for a password and the second didn't,
  PQconnectionUsedPassword() would return an incorrect result.  This
  could be leveraged by unprivileged users of dblink or postgres_fdw
  to allow them to use server-side login credentials that they should
  not be able to use.

  Other notable problems include the possibility of forcing a v2-protocol
  connection to a server capable of supporting v3, or overriding
  "sslmode=prefer" to cause a non-encrypted connection to a server that
  would have accepted an encrypted one.  Those are certainly bugs but
  it's harder to paint them as security problems in themselves.  However,
  forcing a v2-protocol connection could result in libpq having a wrong
  idea of the server's standard_conforming_strings setting, which opens
  the door to SQL-injection attacks.  The extent to which that's actually
  a problem, given the prerequisite that the attacker needs control of
  the client's connection parameters, is unclear.

  These problems have existed for a long time, but became more easily
  exploitable in v10, both because it introduced easy ways to force libpq
  to abandon a connection attempt at a late stage and then try another one
  (rather than just giving up), and because it provided an easy way to
  specify multiple target hosts.

  Fix by rearranging PQconnectPoll's state machine to provide centralized
  places to reset state properly when moving to a new target host or when
  dropping and retrying a connection to the same host.

  Tom Lane, reviewed by Noah Misch.  Our thanks to Andrew Krasichkov
  for finding and reporting the problem.

  Security: CVE-2018-10915
  a8094d0fe73188e9ff05f210c11c4b251d1442f1:Fix failure to reset libpq's state fully between connection attempts.

  The logic in PQconnectPoll() did not take care to ensure that all of
  a PGconn's internal state variables were reset before trying a new
  connection attempt.  If we got far enough in the connection sequence
  to have changed any of these variables, and then decided to try a new
  server address or server name, the new connection might be completed
  with some state that really only applied to the failed connection.

  While this has assorted bad consequences, the only one that is clearly
  a security issue is that password_needed didn't get reset, so that
  if the first server asked for a password and the second didn't,
  PQconnectionUsedPassword() would return an incorrect result.  This
  could be leveraged by unprivileged users of dblink or postgres_fdw
  to allow them to use server-side login credentials that they should
  not be able to use.

  Other notable problems include the possibility of forcing a v2-protocol
  connection to a server capable of supporting v3, or overriding
  "sslmode=prefer" to cause a non-encrypted connection to a server that
  would have accepted an encrypted one.  Those are certainly bugs but
  it's harder to paint them as security problems in themselves.  However,
  forcing a v2-protocol connection could result in libpq having a wrong
  idea of the server's standard_conforming_strings setting, which opens
  the door to SQL-injection attacks.  The extent to which that's actually
  a problem, given the prerequisite that the attacker needs control of
  the client's connection parameters, is unclear.

  These problems have existed for a long time, but became more easily
  exploitable in v10, both because it introduced easy ways to force libpq
  to abandon a connection attempt at a late stage and then try another one
  (rather than just giving up), and because it provided an easy way to
  specify multiple target hosts.

  Fix by rearranging PQconnectPoll's state machine to provide centralized
  places to reset state properly when moving to a new target host or when
  dropping and retrying a connection to the same host.

  Tom Lane, reviewed by Noah Misch.  Our thanks to Andrew Krasichkov
  for finding and reporting the problem.

  Security: CVE-2018-10915
  7aabfd1d8cdde37f36988344d0e1cf84aa164760:Fix failure to reset libpq's state fully between connection attempts.

  The logic in PQconnectPoll() did not take care to ensure that all of
  a PGconn's internal state variables were reset before trying a new
  connection attempt.  If we got far enough in the connection sequence
  to have changed any of these variables, and then decided to try a new
  server address or server name, the new connection might be completed
  with some state that really only applied to the failed connection.

  While this has assorted bad consequences, the only one that is clearly
  a security issue is that password_needed didn't get reset, so that
  if the first server asked for a password and the second didn't,
  PQconnectionUsedPassword() would return an incorrect result.  This
  could be leveraged by unprivileged users of dblink or postgres_fdw
  to allow them to use server-side login credentials that they should
  not be able to use.

  Other notable problems include the possibility of forcing a v2-protocol
  connection to a server capable of supporting v3, or overriding
  "sslmode=prefer" to cause a non-encrypted connection to a server that
  would have accepted an encrypted one.  Those are certainly bugs but
  it's harder to paint them as security problems in themselves.  However,
  forcing a v2-protocol connection could result in libpq having a wrong
  idea of the server's standard_conforming_strings setting, which opens
  the door to SQL-injection attacks.  The extent to which that's actually
  a problem, given the prerequisite that the attacker needs control of
  the client's connection parameters, is unclear.

  These problems have existed for a long time, but became more easily
  exploitable in v10, both because it introduced easy ways to force libpq
  to abandon a connection attempt at a late stage and then try another one
  (rather than just giving up), and because it provided an easy way to
  specify multiple target hosts.

  Fix by rearranging PQconnectPoll's state machine to provide centralized
  places to reset state properly when moving to a new target host or when
  dropping and retrying a connection to the same host.

  Tom Lane, reviewed by Noah Misch.  Our thanks to Andrew Krasichkov
  for finding and reporting the problem.

  Security: CVE-2018-10915
  6de9766b8d56c292a2d446424b417817475a3e32:Fix failure to reset libpq's state fully between connection attempts.

  The logic in PQconnectPoll() did not take care to ensure that all of
  a PGconn's internal state variables were reset before trying a new
  connection attempt.  If we got far enough in the connection sequence
  to have changed any of these variables, and then decided to try a new
  server address or server name, the new connection might be completed
  with some state that really only applied to the failed connection.

  While this has assorted bad consequences, the only one that is clearly
  a security issue is that password_needed didn't get reset, so that
  if the first server asked for a password and the second didn't,
  PQconnectionUsedPassword() would return an incorrect result.  This
  could be leveraged by unprivileged users of dblink or postgres_fdw
  to allow them to use server-side login credentials that they should
  not be able to use.

  Other notable problems include the possibility of forcing a v2-protocol
  connection to a server capable of supporting v3, or overriding
  "sslmode=prefer" to cause a non-encrypted connection to a server that
  would have accepted an encrypted one.  Those are certainly bugs but
  it's harder to paint them as security problems in themselves.  However,
  forcing a v2-protocol connection could result in libpq having a wrong
  idea of the server's standard_conforming_strings setting, which opens
  the door to SQL-injection attacks.  The extent to which that's actually
  a problem, given the prerequisite that the attacker needs control of
  the client's connection parameters, is unclear.

  These problems have existed for a long time, but became more easily
  exploitable in v10, both because it introduced easy ways to force libpq
  to abandon a connection attempt at a late stage and then try another one
  (rather than just giving up), and because it provided an easy way to
  specify multiple target hosts.

  Fix by rearranging PQconnectPoll's state machine to provide centralized
  places to reset state properly when moving to a new target host or when
  dropping and retrying a connection to the same host.

  Tom Lane, reviewed by Noah Misch.  Our thanks to Andrew Krasichkov
  for finding and reporting the problem.

  Security: CVE-2018-10915
  243de06be96d6001d01f2ec7c4573aad8b657195:Fix failure to reset libpq's state fully between connection attempts.

  The logic in PQconnectPoll() did not take care to ensure that all of
  a PGconn's internal state variables were reset before trying a new
  connection attempt.  If we got far enough in the connection sequence
  to have changed any of these variables, and then decided to try a new
  server address or server name, the new connection might be completed
  with some state that really only applied to the failed connection.

  While this has assorted bad consequences, the only one that is clearly
  a security issue is that password_needed didn't get reset, so that
  if the first server asked for a password and the second didn't,
  PQconnectionUsedPassword() would return an incorrect result.  This
  could be leveraged by unprivileged users of dblink or postgres_fdw
  to allow them to use server-side login credentials that they should
  not be able to use.

  Other notable problems include the possibility of forcing a v2-protocol
  connection to a server capable of supporting v3, or overriding
  "sslmode=prefer" to cause a non-encrypted connection to a server that
  would have accepted an encrypted one.  Those are certainly bugs but
  it's harder to paint them as security problems in themselves.  However,
  forcing a v2-protocol connection could result in libpq having a wrong
  idea of the server's standard_conforming_strings setting, which opens
  the door to SQL-injection attacks.  The extent to which that's actually
  a problem, given the prerequisite that the attacker needs control of
  the client's connection parameters, is unclear.

  These problems have existed for a long time, but became more easily
  exploitable in v10, both because it introduced easy ways to force libpq
  to abandon a connection attempt at a late stage and then try another one
  (rather than just giving up), and because it provided an easy way to
  specify multiple target hosts.

  Fix by rearranging PQconnectPoll's state machine to provide centralized
  places to reset state properly when moving to a new target host or when
  dropping and retrying a connection to the same host.

  Tom Lane, reviewed by Noah Misch.  Our thanks to Andrew Krasichkov
  for finding and reporting the problem.

  Security: CVE-2018-10915
  d1c6a14bacfa5fe7690e2c71b1626dbc87a57355:Fix failure to reset libpq's state fully between connection attempts.

  The logic in PQconnectPoll() did not take care to ensure that all of
  a PGconn's internal state variables were reset before trying a new
  connection attempt.  If we got far enough in the connection sequence
  to have changed any of these variables, and then decided to try a new
  server address or server name, the new connection might be completed
  with some state that really only applied to the failed connection.

  While this has assorted bad consequences, the only one that is clearly
  a security issue is that password_needed didn't get reset, so that
  if the first server asked for a password and the second didn't,
  PQconnectionUsedPassword() would return an incorrect result.  This
  could be leveraged by unprivileged users of dblink or postgres_fdw
  to allow them to use server-side login credentials that they should
  not be able to use.

  Other notable problems include the possibility of forcing a v2-protocol
  connection to a server capable of supporting v3, or overriding
  "sslmode=prefer" to cause a non-encrypted connection to a server that
  would have accepted an encrypted one.  Those are certainly bugs but
  it's harder to paint them as security problems in themselves.  However,
  forcing a v2-protocol connection could result in libpq having a wrong
  idea of the server's standard_conforming_strings setting, which opens
  the door to SQL-injection attacks.  The extent to which that's actually
  a problem, given the prerequisite that the attacker needs control of
  the client's connection parameters, is unclear.

  These problems have existed for a long time, but became more easily
  exploitable in v10, both because it introduced easy ways to force libpq
  to abandon a connection attempt at a late stage and then try another one
  (rather than just giving up), and because it provided an easy way to
  specify multiple target hosts.

  Fix by rearranging PQconnectPoll's state machine to provide centralized
  places to reset state properly when moving to a new target host or when
  dropping and retrying a connection to the same host.

  Tom Lane, reviewed by Noah Misch.  Our thanks to Andrew Krasichkov
  for finding and reporting the problem.

  Security: CVE-2018-10915
  f6f735f78d9e05b757c96b036dfd31b1f9f77312:Fix failure to reset libpq's state fully between connection attempts.

  The logic in PQconnectPoll() did not take care to ensure that all of
  a PGconn's internal state variables were reset before trying a new
  connection attempt.  If we got far enough in the connection sequence
  to have changed any of these variables, and then decided to try a new
  server address or server name, the new connection might be completed
  with some state that really only applied to the failed connection.

  While this has assorted bad consequences, the only one that is clearly
  a security issue is that password_needed didn't get reset, so that
  if the first server asked for a password and the second didn't,
  PQconnectionUsedPassword() would return an incorrect result.  This
  could be leveraged by unprivileged users of dblink or postgres_fdw
  to allow them to use server-side login credentials that they should
  not be able to use.

  Other notable problems include the possibility of forcing a v2-protocol
  connection to a server capable of supporting v3, or overriding
  "sslmode=prefer" to cause a non-encrypted connection to a server that
  would have accepted an encrypted one.  Those are certainly bugs but
  it's harder to paint them as security problems in themselves.  However,
  forcing a v2-protocol connection could result in libpq having a wrong
  idea of the server's standard_conforming_strings setting, which opens
  the door to SQL-injection attacks.  The extent to which that's actually
  a problem, given the prerequisite that the attacker needs control of
  the client's connection parameters, is unclear.

  These problems have existed for a long time, but became more easily
  exploitable in v10, both because it introduced easy ways to force libpq
  to abandon a connection attempt at a late stage and then try another one
  (rather than just giving up), and because it provided an easy way to
  specify multiple target hosts.

  Fix by rearranging PQconnectPoll's state machine to provide centralized
  places to reset state properly when moving to a new target host or when
  dropping and retrying a connection to the same host.

  Tom Lane, reviewed by Noah Misch.  Our thanks to Andrew Krasichkov
  for finding and reporting the problem.

  Security: CVE-2018-10915
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9d3072d2db2edbc19603d8d65189a504cc4e4712
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 3fd77b1dccb8539d68a517711bfd29310ecc4c04
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: e0ee93053998b159e395deed7c42e02b1f921552
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 7aabfd1d8cdde37f36988344d0e1cf84aa164760
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: f6f735f78d9e05b757c96b036dfd31b1f9f77312
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: ebeb8d53710ea140dd00eb6506cbe50db4e11dce
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 243de06be96d6001d01f2ec7c4573aad8b657195
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: d1c6a14bacfa5fe7690e2c71b1626dbc87a57355
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 749839c4d53c60de2e51ef82a03f1084e3ec1f6c
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: c54f04820a48c33ca15b24552eab29f5137ce462
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a8094d0fe73188e9ff05f210c11c4b251d1442f1
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 6de9766b8d56c292a2d446424b417817475a3e32
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: cd2490789e82d9cc0cc5a23e666394f21d0b498f
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: ab5400469b5db281a4d804ef59b80fcef7c9fc93
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/243de06be96d6001d01f2ec7c4573aad8b657195
    reference_type: commit
    reference_id: 243de06be96d6001d01f2ec7c4573aad8b657195
  - url: https://github.com/postgres/postgres/tree/3fd77b1dccb8539d68a517711bfd29310ecc4c04
    reference_type: commit
    reference_id: 3fd77b1dccb8539d68a517711bfd29310ecc4c04
  - url: https://github.com/postgres/postgres/tree/6de9766b8d56c292a2d446424b417817475a3e32
    reference_type: commit
    reference_id: 6de9766b8d56c292a2d446424b417817475a3e32
  - url: https://github.com/postgres/postgres/tree/749839c4d53c60de2e51ef82a03f1084e3ec1f6c
    reference_type: commit
    reference_id: 749839c4d53c60de2e51ef82a03f1084e3ec1f6c
  - url: https://github.com/postgres/postgres/tree/7aabfd1d8cdde37f36988344d0e1cf84aa164760
    reference_type: commit
    reference_id: 7aabfd1d8cdde37f36988344d0e1cf84aa164760
  - url: https://github.com/postgres/postgres/tree/9d3072d2db2edbc19603d8d65189a504cc4e4712
    reference_type: commit
    reference_id: 9d3072d2db2edbc19603d8d65189a504cc4e4712
  - url: https://github.com/postgres/postgres/tree/a8094d0fe73188e9ff05f210c11c4b251d1442f1
    reference_type: commit
    reference_id: a8094d0fe73188e9ff05f210c11c4b251d1442f1
  - url: https://github.com/postgres/postgres/tree/ab5400469b5db281a4d804ef59b80fcef7c9fc93
    reference_type: commit
    reference_id: ab5400469b5db281a4d804ef59b80fcef7c9fc93
  - url: https://github.com/postgres/postgres/tree/c54f04820a48c33ca15b24552eab29f5137ce462
    reference_type: commit
    reference_id: c54f04820a48c33ca15b24552eab29f5137ce462
  - url: https://github.com/postgres/postgres/tree/cd2490789e82d9cc0cc5a23e666394f21d0b498f
    reference_type: commit
    reference_id: cd2490789e82d9cc0cc5a23e666394f21d0b498f
  - url: https://github.com/postgres/postgres/tree/d1c6a14bacfa5fe7690e2c71b1626dbc87a57355
    reference_type: commit
    reference_id: d1c6a14bacfa5fe7690e2c71b1626dbc87a57355
  - url: https://github.com/postgres/postgres/tree/e0ee93053998b159e395deed7c42e02b1f921552
    reference_type: commit
    reference_id: e0ee93053998b159e395deed7c42e02b1f921552
  - url: https://github.com/postgres/postgres/tree/ebeb8d53710ea140dd00eb6506cbe50db4e11dce
    reference_type: commit
    reference_id: ebeb8d53710ea140dd00eb6506cbe50db4e11dce
  - url: https://github.com/postgres/postgres/tree/f6f735f78d9e05b757c96b036dfd31b1f9f77312
    reference_type: commit
    reference_id: f6f735f78d9e05b757c96b036dfd31b1f9f77312
