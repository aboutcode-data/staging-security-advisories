advisory_id: CVE-2021-32028
datasource_id: collect_postgresql_fix_commits/CVE-2021-32028
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  cc6c63f8a26d9706bc4b256ac075401bb3d5f759:Last-minute updates for release notes.

  Security: CVE-2021-32027, CVE-2021-32028, CVE-2021-32029
  25387cc56d344eaa9545b8233496296cf6087477:Last-minute updates for release notes.

  Security: CVE-2021-32027, CVE-2021-32028, CVE-2021-32029
  6c1cfccf226645f4c01b4fee8df2c4e3392f2a32:Last-minute updates for release notes.

  Security: CVE-2021-32027, CVE-2021-32028, CVE-2021-32029
  a9c718bd2d35586da8ebdefa0b72fe7e0d1a725b:Last-minute updates for release notes.

  Security: CVE-2021-32027, CVE-2021-32028, CVE-2021-32029
  9b93a33f455579ee8953c32721c03ff9163b7f96:Last-minute updates for release notes.

  Security: CVE-2021-32027, CVE-2021-32028, CVE-2021-32029
  0fcb8e2e0154dedea5c3c7da6dd2cffb731aac06:Fix mishandling of resjunk columns in ON CONFLICT ... UPDATE tlists.

  It's unusual to have any resjunk columns in an ON CONFLICT ... UPDATE
  list, but it can happen when MULTIEXPR_SUBLINK SubPlans are present.
  If it happens, the ON CONFLICT UPDATE code path would end up storing
  tuples that include the values of the extra resjunk columns.  That's
  fairly harmless in the short run, but if new columns are added to
  the table then the values would become accessible, possibly leading
  to malfunctions if they don't match the datatypes of the new columns.

  This had escaped notice through a confluence of missing sanity checks,
  including

  * There's no cross-check that a tuple presented to heap_insert or
  heap_update matches the table rowtype.  While it's difficult to
  check that fully at reasonable cost, we can easily add assertions
  that there aren't too many columns.

  * The output-column-assignment cases in execExprInterp.c lacked
  any sanity checks on the output column numbers, which seems like
  an oversight considering there are plenty of assertion checks on
  input column numbers.  Add assertions there too.

  * We failed to apply nodeModifyTable's ExecCheckPlanOutput() to
  the ON CONFLICT UPDATE tlist.  That wouldn't have caught this
  specific error, since that function is chartered to ignore resjunk
  columns; but it sure seems like a bad omission now that we've seen
  this bug.

  In HEAD, the right way to fix this is to make the processing of
  ON CONFLICT UPDATE tlists work the same as regular UPDATE tlists
  now do, that is don't add "SET x = x" entries, and use
  ExecBuildUpdateProjection to evaluate the tlist and combine it with
  old values of the not-set columns.  This adds a little complication
  to ExecBuildUpdateProjection, but allows removal of a comparable
  amount of now-dead code from the planner.

  In the back branches, the most expedient solution seems to be to
  (a) use an output slot for the ON CONFLICT UPDATE projection that
  actually matches the target table, and then (b) invent a variant of
  ExecBuildProjectionInfo that can be told to not store values resulting
  from resjunk columns, so it doesn't try to store into nonexistent
  columns of the output slot.  (We can't simply ignore the resjunk columns
  altogether; they have to be evaluated for MULTIEXPR_SUBLINK to work.)
  This works back to v10.  In 9.6, projections work much differently and
  we can't cheaply give them such an option.  The 9.6 version of this
  patch works by inserting a JunkFilter when it's necessary to get rid
  of resjunk columns.

  In addition, v11 and up have the reverse problem when trying to
  perform ON CONFLICT UPDATE on a partitioned table.  Through a
  further oversight, adjust_partition_tlist() discarded resjunk columns
  when re-ordering the ON CONFLICT UPDATE tlist to match a partition.
  This accidentally prevented the storing-bogus-tuples problem, but
  at the cost that MULTIEXPR_SUBLINK cases didn't work, typically
  crashing if more than one row has to be updated.  Fix by preserving
  resjunk columns in that routine.  (I failed to resist the temptation
  to add more assertions there too, and to do some minor code
  beautification.)

  Per report from Andres Freund.  Back-patch to all supported branches.

  Security: CVE-2021-32028
  52a4413627319980843bb8f375f28c7f01c45e18:Fix mishandling of resjunk columns in ON CONFLICT ... UPDATE tlists.

  It's unusual to have any resjunk columns in an ON CONFLICT ... UPDATE
  list, but it can happen when MULTIEXPR_SUBLINK SubPlans are present.
  If it happens, the ON CONFLICT UPDATE code path would end up storing
  tuples that include the values of the extra resjunk columns.  That's
  fairly harmless in the short run, but if new columns are added to
  the table then the values would become accessible, possibly leading
  to malfunctions if they don't match the datatypes of the new columns.

  This had escaped notice through a confluence of missing sanity checks,
  including

  * There's no cross-check that a tuple presented to heap_insert or
  heap_update matches the table rowtype.  While it's difficult to
  check that fully at reasonable cost, we can easily add assertions
  that there aren't too many columns.

  * The output-column-assignment cases in execExprInterp.c lacked
  any sanity checks on the output column numbers, which seems like
  an oversight considering there are plenty of assertion checks on
  input column numbers.  Add assertions there too.

  * We failed to apply nodeModifyTable's ExecCheckPlanOutput() to
  the ON CONFLICT UPDATE tlist.  That wouldn't have caught this
  specific error, since that function is chartered to ignore resjunk
  columns; but it sure seems like a bad omission now that we've seen
  this bug.

  In HEAD, the right way to fix this is to make the processing of
  ON CONFLICT UPDATE tlists work the same as regular UPDATE tlists
  now do, that is don't add "SET x = x" entries, and use
  ExecBuildUpdateProjection to evaluate the tlist and combine it with
  old values of the not-set columns.  This adds a little complication
  to ExecBuildUpdateProjection, but allows removal of a comparable
  amount of now-dead code from the planner.

  In the back branches, the most expedient solution seems to be to
  (a) use an output slot for the ON CONFLICT UPDATE projection that
  actually matches the target table, and then (b) invent a variant of
  ExecBuildProjectionInfo that can be told to not store values resulting
  from resjunk columns, so it doesn't try to store into nonexistent
  columns of the output slot.  (We can't simply ignore the resjunk columns
  altogether; they have to be evaluated for MULTIEXPR_SUBLINK to work.)
  This works back to v10.  In 9.6, projections work much differently and
  we can't cheaply give them such an option.  The 9.6 version of this
  patch works by inserting a JunkFilter when it's necessary to get rid
  of resjunk columns.

  In addition, v11 and up have the reverse problem when trying to
  perform ON CONFLICT UPDATE on a partitioned table.  Through a
  further oversight, adjust_partition_tlist() discarded resjunk columns
  when re-ordering the ON CONFLICT UPDATE tlist to match a partition.
  This accidentally prevented the storing-bogus-tuples problem, but
  at the cost that MULTIEXPR_SUBLINK cases didn't work, typically
  crashing if more than one row has to be updated.  Fix by preserving
  resjunk columns in that routine.  (I failed to resist the temptation
  to add more assertions there too, and to do some minor code
  beautification.)

  Per report from Andres Freund.  Back-patch to all supported branches.

  Security: CVE-2021-32028
  049e1e2edb06854d7cd9460c22516efaa165fbf8:Fix mishandling of resjunk columns in ON CONFLICT ... UPDATE tlists.

  It's unusual to have any resjunk columns in an ON CONFLICT ... UPDATE
  list, but it can happen when MULTIEXPR_SUBLINK SubPlans are present.
  If it happens, the ON CONFLICT UPDATE code path would end up storing
  tuples that include the values of the extra resjunk columns.  That's
  fairly harmless in the short run, but if new columns are added to
  the table then the values would become accessible, possibly leading
  to malfunctions if they don't match the datatypes of the new columns.

  This had escaped notice through a confluence of missing sanity checks,
  including

  * There's no cross-check that a tuple presented to heap_insert or
  heap_update matches the table rowtype.  While it's difficult to
  check that fully at reasonable cost, we can easily add assertions
  that there aren't too many columns.

  * The output-column-assignment cases in execExprInterp.c lacked
  any sanity checks on the output column numbers, which seems like
  an oversight considering there are plenty of assertion checks on
  input column numbers.  Add assertions there too.

  * We failed to apply nodeModifyTable's ExecCheckPlanOutput() to
  the ON CONFLICT UPDATE tlist.  That wouldn't have caught this
  specific error, since that function is chartered to ignore resjunk
  columns; but it sure seems like a bad omission now that we've seen
  this bug.

  In HEAD, the right way to fix this is to make the processing of
  ON CONFLICT UPDATE tlists work the same as regular UPDATE tlists
  now do, that is don't add "SET x = x" entries, and use
  ExecBuildUpdateProjection to evaluate the tlist and combine it with
  old values of the not-set columns.  This adds a little complication
  to ExecBuildUpdateProjection, but allows removal of a comparable
  amount of now-dead code from the planner.

  In the back branches, the most expedient solution seems to be to
  (a) use an output slot for the ON CONFLICT UPDATE projection that
  actually matches the target table, and then (b) invent a variant of
  ExecBuildProjectionInfo that can be told to not store values resulting
  from resjunk columns, so it doesn't try to store into nonexistent
  columns of the output slot.  (We can't simply ignore the resjunk columns
  altogether; they have to be evaluated for MULTIEXPR_SUBLINK to work.)
  This works back to v10.  In 9.6, projections work much differently and
  we can't cheaply give them such an option.  The 9.6 version of this
  patch works by inserting a JunkFilter when it's necessary to get rid
  of resjunk columns.

  In addition, v11 and up have the reverse problem when trying to
  perform ON CONFLICT UPDATE on a partitioned table.  Through a
  further oversight, adjust_partition_tlist() discarded resjunk columns
  when re-ordering the ON CONFLICT UPDATE tlist to match a partition.
  This accidentally prevented the storing-bogus-tuples problem, but
  at the cost that MULTIEXPR_SUBLINK cases didn't work, typically
  crashing if more than one row has to be updated.  Fix by preserving
  resjunk columns in that routine.  (I failed to resist the temptation
  to add more assertions there too, and to do some minor code
  beautification.)

  Per report from Andres Freund.  Back-patch to all supported branches.

  Security: CVE-2021-32028
  b7d1f32ff6588be99844c140ec1aacb6e44f4b84:Fix mishandling of resjunk columns in ON CONFLICT ... UPDATE tlists.

  It's unusual to have any resjunk columns in an ON CONFLICT ... UPDATE
  list, but it can happen when MULTIEXPR_SUBLINK SubPlans are present.
  If it happens, the ON CONFLICT UPDATE code path would end up storing
  tuples that include the values of the extra resjunk columns.  That's
  fairly harmless in the short run, but if new columns are added to
  the table then the values would become accessible, possibly leading
  to malfunctions if they don't match the datatypes of the new columns.

  This had escaped notice through a confluence of missing sanity checks,
  including

  * There's no cross-check that a tuple presented to heap_insert or
  heap_update matches the table rowtype.  While it's difficult to
  check that fully at reasonable cost, we can easily add assertions
  that there aren't too many columns.

  * The output-column-assignment cases in execExprInterp.c lacked
  any sanity checks on the output column numbers, which seems like
  an oversight considering there are plenty of assertion checks on
  input column numbers.  Add assertions there too.

  * We failed to apply nodeModifyTable's ExecCheckPlanOutput() to
  the ON CONFLICT UPDATE tlist.  That wouldn't have caught this
  specific error, since that function is chartered to ignore resjunk
  columns; but it sure seems like a bad omission now that we've seen
  this bug.

  In HEAD, the right way to fix this is to make the processing of
  ON CONFLICT UPDATE tlists work the same as regular UPDATE tlists
  now do, that is don't add "SET x = x" entries, and use
  ExecBuildUpdateProjection to evaluate the tlist and combine it with
  old values of the not-set columns.  This adds a little complication
  to ExecBuildUpdateProjection, but allows removal of a comparable
  amount of now-dead code from the planner.

  In the back branches, the most expedient solution seems to be to
  (a) use an output slot for the ON CONFLICT UPDATE projection that
  actually matches the target table, and then (b) invent a variant of
  ExecBuildProjectionInfo that can be told to not store values resulting
  from resjunk columns, so it doesn't try to store into nonexistent
  columns of the output slot.  (We can't simply ignore the resjunk columns
  altogether; they have to be evaluated for MULTIEXPR_SUBLINK to work.)
  This works back to v10.  In 9.6, projections work much differently and
  we can't cheaply give them such an option.  The 9.6 version of this
  patch works by inserting a JunkFilter when it's necessary to get rid
  of resjunk columns.

  In addition, v11 and up have the reverse problem when trying to
  perform ON CONFLICT UPDATE on a partitioned table.  Through a
  further oversight, adjust_partition_tlist() discarded resjunk columns
  when re-ordering the ON CONFLICT UPDATE tlist to match a partition.
  This accidentally prevented the storing-bogus-tuples problem, but
  at the cost that MULTIEXPR_SUBLINK cases didn't work, typically
  crashing if more than one row has to be updated.  Fix by preserving
  resjunk columns in that routine.  (I failed to resist the temptation
  to add more assertions there too, and to do some minor code
  beautification.)

  Per report from Andres Freund.  Back-patch to all supported branches.

  Security: CVE-2021-32028
  a5fa3e0671474411ad81600a8f2b4800a4464afc:Fix mishandling of resjunk columns in ON CONFLICT ... UPDATE tlists.

  It's unusual to have any resjunk columns in an ON CONFLICT ... UPDATE
  list, but it can happen when MULTIEXPR_SUBLINK SubPlans are present.
  If it happens, the ON CONFLICT UPDATE code path would end up storing
  tuples that include the values of the extra resjunk columns.  That's
  fairly harmless in the short run, but if new columns are added to
  the table then the values would become accessible, possibly leading
  to malfunctions if they don't match the datatypes of the new columns.

  This had escaped notice through a confluence of missing sanity checks,
  including

  * There's no cross-check that a tuple presented to heap_insert or
  heap_update matches the table rowtype.  While it's difficult to
  check that fully at reasonable cost, we can easily add assertions
  that there aren't too many columns.

  * The output-column-assignment cases in execExprInterp.c lacked
  any sanity checks on the output column numbers, which seems like
  an oversight considering there are plenty of assertion checks on
  input column numbers.  Add assertions there too.

  * We failed to apply nodeModifyTable's ExecCheckPlanOutput() to
  the ON CONFLICT UPDATE tlist.  That wouldn't have caught this
  specific error, since that function is chartered to ignore resjunk
  columns; but it sure seems like a bad omission now that we've seen
  this bug.

  In HEAD, the right way to fix this is to make the processing of
  ON CONFLICT UPDATE tlists work the same as regular UPDATE tlists
  now do, that is don't add "SET x = x" entries, and use
  ExecBuildUpdateProjection to evaluate the tlist and combine it with
  old values of the not-set columns.  This adds a little complication
  to ExecBuildUpdateProjection, but allows removal of a comparable
  amount of now-dead code from the planner.

  In the back branches, the most expedient solution seems to be to
  (a) use an output slot for the ON CONFLICT UPDATE projection that
  actually matches the target table, and then (b) invent a variant of
  ExecBuildProjectionInfo that can be told to not store values resulting
  from resjunk columns, so it doesn't try to store into nonexistent
  columns of the output slot.  (We can't simply ignore the resjunk columns
  altogether; they have to be evaluated for MULTIEXPR_SUBLINK to work.)
  This works back to v10.  In 9.6, projections work much differently and
  we can't cheaply give them such an option.  The 9.6 version of this
  patch works by inserting a JunkFilter when it's necessary to get rid
  of resjunk columns.

  In addition, v11 and up have the reverse problem when trying to
  perform ON CONFLICT UPDATE on a partitioned table.  Through a
  further oversight, adjust_partition_tlist() discarded resjunk columns
  when re-ordering the ON CONFLICT UPDATE tlist to match a partition.
  This accidentally prevented the storing-bogus-tuples problem, but
  at the cost that MULTIEXPR_SUBLINK cases didn't work, typically
  crashing if more than one row has to be updated.  Fix by preserving
  resjunk columns in that routine.  (I failed to resist the temptation
  to add more assertions there too, and to do some minor code
  beautification.)

  Per report from Andres Freund.  Back-patch to all supported branches.

  Security: CVE-2021-32028
  4a8656a7ee0c155b0249376af58eb3fc3a90415f:Fix mishandling of resjunk columns in ON CONFLICT ... UPDATE tlists.

  It's unusual to have any resjunk columns in an ON CONFLICT ... UPDATE
  list, but it can happen when MULTIEXPR_SUBLINK SubPlans are present.
  If it happens, the ON CONFLICT UPDATE code path would end up storing
  tuples that include the values of the extra resjunk columns.  That's
  fairly harmless in the short run, but if new columns are added to
  the table then the values would become accessible, possibly leading
  to malfunctions if they don't match the datatypes of the new columns.

  This had escaped notice through a confluence of missing sanity checks,
  including

  * There's no cross-check that a tuple presented to heap_insert or
  heap_update matches the table rowtype.  While it's difficult to
  check that fully at reasonable cost, we can easily add assertions
  that there aren't too many columns.

  * The output-column-assignment cases in execExprInterp.c lacked
  any sanity checks on the output column numbers, which seems like
  an oversight considering there are plenty of assertion checks on
  input column numbers.  Add assertions there too.

  * We failed to apply nodeModifyTable's ExecCheckPlanOutput() to
  the ON CONFLICT UPDATE tlist.  That wouldn't have caught this
  specific error, since that function is chartered to ignore resjunk
  columns; but it sure seems like a bad omission now that we've seen
  this bug.

  In HEAD, the right way to fix this is to make the processing of
  ON CONFLICT UPDATE tlists work the same as regular UPDATE tlists
  now do, that is don't add "SET x = x" entries, and use
  ExecBuildUpdateProjection to evaluate the tlist and combine it with
  old values of the not-set columns.  This adds a little complication
  to ExecBuildUpdateProjection, but allows removal of a comparable
  amount of now-dead code from the planner.

  In the back branches, the most expedient solution seems to be to
  (a) use an output slot for the ON CONFLICT UPDATE projection that
  actually matches the target table, and then (b) invent a variant of
  ExecBuildProjectionInfo that can be told to not store values resulting
  from resjunk columns, so it doesn't try to store into nonexistent
  columns of the output slot.  (We can't simply ignore the resjunk columns
  altogether; they have to be evaluated for MULTIEXPR_SUBLINK to work.)
  This works back to v10.  In 9.6, projections work much differently and
  we can't cheaply give them such an option.  The 9.6 version of this
  patch works by inserting a JunkFilter when it's necessary to get rid
  of resjunk columns.

  In addition, v11 and up have the reverse problem when trying to
  perform ON CONFLICT UPDATE on a partitioned table.  Through a
  further oversight, adjust_partition_tlist() discarded resjunk columns
  when re-ordering the ON CONFLICT UPDATE tlist to match a partition.
  This accidentally prevented the storing-bogus-tuples problem, but
  at the cost that MULTIEXPR_SUBLINK cases didn't work, typically
  crashing if more than one row has to be updated.  Fix by preserving
  resjunk columns in that routine.  (I failed to resist the temptation
  to add more assertions there too, and to do some minor code
  beautification.)

  Per report from Andres Freund.  Back-patch to all supported branches.

  Security: CVE-2021-32028
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 6c1cfccf226645f4c01b4fee8df2c4e3392f2a32
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 25387cc56d344eaa9545b8233496296cf6087477
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 049e1e2edb06854d7cd9460c22516efaa165fbf8
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 0fcb8e2e0154dedea5c3c7da6dd2cffb731aac06
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a5fa3e0671474411ad81600a8f2b4800a4464afc
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9b93a33f455579ee8953c32721c03ff9163b7f96
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: cc6c63f8a26d9706bc4b256ac075401bb3d5f759
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 52a4413627319980843bb8f375f28c7f01c45e18
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a9c718bd2d35586da8ebdefa0b72fe7e0d1a725b
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: b7d1f32ff6588be99844c140ec1aacb6e44f4b84
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 4a8656a7ee0c155b0249376af58eb3fc3a90415f
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/049e1e2edb06854d7cd9460c22516efaa165fbf8
    reference_type: commit
    reference_id: 049e1e2edb06854d7cd9460c22516efaa165fbf8
  - url: https://github.com/postgres/postgres/tree/0fcb8e2e0154dedea5c3c7da6dd2cffb731aac06
    reference_type: commit
    reference_id: 0fcb8e2e0154dedea5c3c7da6dd2cffb731aac06
  - url: https://github.com/postgres/postgres/tree/25387cc56d344eaa9545b8233496296cf6087477
    reference_type: commit
    reference_id: 25387cc56d344eaa9545b8233496296cf6087477
  - url: https://github.com/postgres/postgres/tree/4a8656a7ee0c155b0249376af58eb3fc3a90415f
    reference_type: commit
    reference_id: 4a8656a7ee0c155b0249376af58eb3fc3a90415f
  - url: https://github.com/postgres/postgres/tree/52a4413627319980843bb8f375f28c7f01c45e18
    reference_type: commit
    reference_id: 52a4413627319980843bb8f375f28c7f01c45e18
  - url: https://github.com/postgres/postgres/tree/6c1cfccf226645f4c01b4fee8df2c4e3392f2a32
    reference_type: commit
    reference_id: 6c1cfccf226645f4c01b4fee8df2c4e3392f2a32
  - url: https://github.com/postgres/postgres/tree/9b93a33f455579ee8953c32721c03ff9163b7f96
    reference_type: commit
    reference_id: 9b93a33f455579ee8953c32721c03ff9163b7f96
  - url: https://github.com/postgres/postgres/tree/a5fa3e0671474411ad81600a8f2b4800a4464afc
    reference_type: commit
    reference_id: a5fa3e0671474411ad81600a8f2b4800a4464afc
  - url: https://github.com/postgres/postgres/tree/a9c718bd2d35586da8ebdefa0b72fe7e0d1a725b
    reference_type: commit
    reference_id: a9c718bd2d35586da8ebdefa0b72fe7e0d1a725b
  - url: https://github.com/postgres/postgres/tree/b7d1f32ff6588be99844c140ec1aacb6e44f4b84
    reference_type: commit
    reference_id: b7d1f32ff6588be99844c140ec1aacb6e44f4b84
  - url: https://github.com/postgres/postgres/tree/cc6c63f8a26d9706bc4b256ac075401bb3d5f759
    reference_type: commit
    reference_id: cc6c63f8a26d9706bc4b256ac075401bb3d5f759
