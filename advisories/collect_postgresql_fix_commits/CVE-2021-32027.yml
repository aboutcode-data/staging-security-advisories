advisory_id: CVE-2021-32027
datasource_id: collect_postgresql_fix_commits/CVE-2021-32027
datasource_url: https://github.com/postgres/postgres
aliases: []
summary: |
  cc6c63f8a26d9706bc4b256ac075401bb3d5f759:Last-minute updates for release notes.

  Security: CVE-2021-32027, CVE-2021-32028, CVE-2021-32029
  25387cc56d344eaa9545b8233496296cf6087477:Last-minute updates for release notes.

  Security: CVE-2021-32027, CVE-2021-32028, CVE-2021-32029
  6c1cfccf226645f4c01b4fee8df2c4e3392f2a32:Last-minute updates for release notes.

  Security: CVE-2021-32027, CVE-2021-32028, CVE-2021-32029
  a9c718bd2d35586da8ebdefa0b72fe7e0d1a725b:Last-minute updates for release notes.

  Security: CVE-2021-32027, CVE-2021-32028, CVE-2021-32029
  9b93a33f455579ee8953c32721c03ff9163b7f96:Last-minute updates for release notes.

  Security: CVE-2021-32027, CVE-2021-32028, CVE-2021-32029
  0c1caa48d3ccb7a5d1343b53aa32fcae45dc2d00:Prevent integer overflows in array subscripting calculations.

  While we were (mostly) careful about ensuring that the dimensions of
  arrays aren't large enough to cause integer overflow, the lower bound
  values were generally not checked.  This allows situations where
  lower_bound + dimension overflows an integer.  It seems that that's
  harmless so far as array reading is concerned, except that array
  elements with subscripts notionally exceeding INT_MAX are inaccessible.
  However, it confuses various array-assignment logic, resulting in a
  potential for memory stomps.

  Fix by adding checks that array lower bounds aren't large enough to
  cause lower_bound + dimension to overflow.  (Note: this results in
  disallowing cases where the last subscript position would be exactly
  INT_MAX.  In principle we could probably allow that, but there's a lot
  of code that computes lower_bound + dimension and would need adjustment.
  It seems doubtful that it's worth the trouble/risk to allow it.)

  Somewhat independently of that, array_set_element() was careless
  about possible overflow when checking the subscript of a fixed-length
  array, creating a different route to memory stomps.  Fix that too.

  Security: CVE-2021-32027
  2fb809d3e1927c0885ad80e18dd3a3aacd612b8b:Prevent integer overflows in array subscripting calculations.

  While we were (mostly) careful about ensuring that the dimensions of
  arrays aren't large enough to cause integer overflow, the lower bound
  values were generally not checked.  This allows situations where
  lower_bound + dimension overflows an integer.  It seems that that's
  harmless so far as array reading is concerned, except that array
  elements with subscripts notionally exceeding INT_MAX are inaccessible.
  However, it confuses various array-assignment logic, resulting in a
  potential for memory stomps.

  Fix by adding checks that array lower bounds aren't large enough to
  cause lower_bound + dimension to overflow.  (Note: this results in
  disallowing cases where the last subscript position would be exactly
  INT_MAX.  In principle we could probably allow that, but there's a lot
  of code that computes lower_bound + dimension and would need adjustment.
  It seems doubtful that it's worth the trouble/risk to allow it.)

  Somewhat independently of that, array_set_element() was careless
  about possible overflow when checking the subscript of a fixed-length
  array, creating a different route to memory stomps.  Fix that too.

  Security: CVE-2021-32027
  f02b9085ad2f6fefd9c5cdf85579cb9f0ff0f0ea:Prevent integer overflows in array subscripting calculations.

  While we were (mostly) careful about ensuring that the dimensions of
  arrays aren't large enough to cause integer overflow, the lower bound
  values were generally not checked.  This allows situations where
  lower_bound + dimension overflows an integer.  It seems that that's
  harmless so far as array reading is concerned, except that array
  elements with subscripts notionally exceeding INT_MAX are inaccessible.
  However, it confuses various array-assignment logic, resulting in a
  potential for memory stomps.

  Fix by adding checks that array lower bounds aren't large enough to
  cause lower_bound + dimension to overflow.  (Note: this results in
  disallowing cases where the last subscript position would be exactly
  INT_MAX.  In principle we could probably allow that, but there's a lot
  of code that computes lower_bound + dimension and would need adjustment.
  It seems doubtful that it's worth the trouble/risk to allow it.)

  Somewhat independently of that, array_set_element() was careless
  about possible overflow when checking the subscript of a fixed-length
  array, creating a different route to memory stomps.  Fix that too.

  Security: CVE-2021-32027
  06bfbe85409177bff7bc5376fb5fdd7a324227c3:Prevent integer overflows in array subscripting calculations.

  While we were (mostly) careful about ensuring that the dimensions of
  arrays aren't large enough to cause integer overflow, the lower bound
  values were generally not checked.  This allows situations where
  lower_bound + dimension overflows an integer.  It seems that that's
  harmless so far as array reading is concerned, except that array
  elements with subscripts notionally exceeding INT_MAX are inaccessible.
  However, it confuses various array-assignment logic, resulting in a
  potential for memory stomps.

  Fix by adding checks that array lower bounds aren't large enough to
  cause lower_bound + dimension to overflow.  (Note: this results in
  disallowing cases where the last subscript position would be exactly
  INT_MAX.  In principle we could probably allow that, but there's a lot
  of code that computes lower_bound + dimension and would need adjustment.
  It seems doubtful that it's worth the trouble/risk to allow it.)

  Somewhat independently of that, array_set_element() was careless
  about possible overflow when checking the subscript of a fixed-length
  array, creating a different route to memory stomps.  Fix that too.

  Security: CVE-2021-32027
  3b0f6a7ae5d812d9a70fc854d2e54d3657467e25:Prevent integer overflows in array subscripting calculations.

  While we were (mostly) careful about ensuring that the dimensions of
  arrays aren't large enough to cause integer overflow, the lower bound
  values were generally not checked.  This allows situations where
  lower_bound + dimension overflows an integer.  It seems that that's
  harmless so far as array reading is concerned, except that array
  elements with subscripts notionally exceeding INT_MAX are inaccessible.
  However, it confuses various array-assignment logic, resulting in a
  potential for memory stomps.

  Fix by adding checks that array lower bounds aren't large enough to
  cause lower_bound + dimension to overflow.  (Note: this results in
  disallowing cases where the last subscript position would be exactly
  INT_MAX.  In principle we could probably allow that, but there's a lot
  of code that computes lower_bound + dimension and would need adjustment.
  It seems doubtful that it's worth the trouble/risk to allow it.)

  Somewhat independently of that, array_set_element() was careless
  about possible overflow when checking the subscript of a fixed-length
  array, creating a different route to memory stomps.  Fix that too.

  Security: CVE-2021-32027
  467395bfdf33f1ccf67ca388ffdcc927271544cb:Prevent integer overflows in array subscripting calculations.

  While we were (mostly) careful about ensuring that the dimensions of
  arrays aren't large enough to cause integer overflow, the lower bound
  values were generally not checked.  This allows situations where
  lower_bound + dimension overflows an integer.  It seems that that's
  harmless so far as array reading is concerned, except that array
  elements with subscripts notionally exceeding INT_MAX are inaccessible.
  However, it confuses various array-assignment logic, resulting in a
  potential for memory stomps.

  Fix by adding checks that array lower bounds aren't large enough to
  cause lower_bound + dimension to overflow.  (Note: this results in
  disallowing cases where the last subscript position would be exactly
  INT_MAX.  In principle we could probably allow that, but there's a lot
  of code that computes lower_bound + dimension and would need adjustment.
  It seems doubtful that it's worth the trouble/risk to allow it.)

  Somewhat independently of that, array_set_element() was careless
  about possible overflow when checking the subscript of a fixed-length
  array, creating a different route to memory stomps.  Fix that too.

  Security: CVE-2021-32027
impacted_packages:
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 6c1cfccf226645f4c01b4fee8df2c4e3392f2a32
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 25387cc56d344eaa9545b8233496296cf6087477
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 06bfbe85409177bff7bc5376fb5fdd7a324227c3
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 467395bfdf33f1ccf67ca388ffdcc927271544cb
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 2fb809d3e1927c0885ad80e18dd3a3aacd612b8b
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 9b93a33f455579ee8953c32721c03ff9163b7f96
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 0c1caa48d3ccb7a5d1343b53aa32fcae45dc2d00
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: f02b9085ad2f6fefd9c5cdf85579cb9f0ff0f0ea
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: 3b0f6a7ae5d812d9a70fc854d2e54d3657467e25
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: cc6c63f8a26d9706bc4b256ac075401bb3d5f759
    introduced_in_commits: []
  - purl: pkg:github/postgres/postgres
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/postgres/postgres
        commit: a9c718bd2d35586da8ebdefa0b72fe7e0d1a725b
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/postgres/postgres/tree/06bfbe85409177bff7bc5376fb5fdd7a324227c3
    reference_type: commit
    reference_id: 06bfbe85409177bff7bc5376fb5fdd7a324227c3
  - url: https://github.com/postgres/postgres/tree/0c1caa48d3ccb7a5d1343b53aa32fcae45dc2d00
    reference_type: commit
    reference_id: 0c1caa48d3ccb7a5d1343b53aa32fcae45dc2d00
  - url: https://github.com/postgres/postgres/tree/25387cc56d344eaa9545b8233496296cf6087477
    reference_type: commit
    reference_id: 25387cc56d344eaa9545b8233496296cf6087477
  - url: https://github.com/postgres/postgres/tree/2fb809d3e1927c0885ad80e18dd3a3aacd612b8b
    reference_type: commit
    reference_id: 2fb809d3e1927c0885ad80e18dd3a3aacd612b8b
  - url: https://github.com/postgres/postgres/tree/3b0f6a7ae5d812d9a70fc854d2e54d3657467e25
    reference_type: commit
    reference_id: 3b0f6a7ae5d812d9a70fc854d2e54d3657467e25
  - url: https://github.com/postgres/postgres/tree/467395bfdf33f1ccf67ca388ffdcc927271544cb
    reference_type: commit
    reference_id: 467395bfdf33f1ccf67ca388ffdcc927271544cb
  - url: https://github.com/postgres/postgres/tree/6c1cfccf226645f4c01b4fee8df2c4e3392f2a32
    reference_type: commit
    reference_id: 6c1cfccf226645f4c01b4fee8df2c4e3392f2a32
  - url: https://github.com/postgres/postgres/tree/9b93a33f455579ee8953c32721c03ff9163b7f96
    reference_type: commit
    reference_id: 9b93a33f455579ee8953c32721c03ff9163b7f96
  - url: https://github.com/postgres/postgres/tree/a9c718bd2d35586da8ebdefa0b72fe7e0d1a725b
    reference_type: commit
    reference_id: a9c718bd2d35586da8ebdefa0b72fe7e0d1a725b
  - url: https://github.com/postgres/postgres/tree/cc6c63f8a26d9706bc4b256ac075401bb3d5f759
    reference_type: commit
    reference_id: cc6c63f8a26d9706bc4b256ac075401bb3d5f759
  - url: https://github.com/postgres/postgres/tree/f02b9085ad2f6fefd9c5cdf85579cb9f0ff0f0ea
    reference_type: commit
    reference_id: f02b9085ad2f6fefd9c5cdf85579cb9f0ff0f0ea
