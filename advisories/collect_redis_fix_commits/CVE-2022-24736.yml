advisory_id: CVE-2022-24736
datasource_id: collect_redis_fix_commits/CVE-2022-24736
datasource_url: https://github.com/redis/redis
aliases: []
summary: "89772ed827209c3dca376644498a235ef3edf692:Merge pull request #10651 from oranagra/meir_lua_readonly_tables\n\
  \n# Lua readonly tables\r\nThe PR adds support for readonly tables on Lua to prevent security\
  \ vulnerabilities:\r\n* (CVE-2022-24736) An attacker attempting to load a specially crafted\
  \ Lua script\r\n  can cause NULL pointer dereference which will result with a crash of the\r\
  \n  redis-server process. This issue affects all versions of Redis.\r\n* (CVE-2022-24735)\
  \ By exploiting weaknesses in the Lua script execution\r\n  environment, an attacker with\
  \ access to Redis can inject Lua code that will\r\n  execute with the (potentially higher)\
  \ privileges of another Redis user.\r\n\r\nThe PR is spitted into 4 commits.\r\n\r\n### Change\
  \ Lua to support readonly tables\r\n\r\nThis PR modifies the Lua interpreter code to support\
  \ a new flag on tables. The new flag indicating that the table is readonly and any attempt\
  \ to perform any writes on such a table will result in an error. The new feature can be turned\
  \ off and on using the new `lua_enablereadonlytable` Lua API. The new API can be used **only**\
  \ from C code. Changes to support this feature was taken from https://luau-lang.org/\r\n\r\
  \n### Change eval script to set user code on Lua registry\r\n\r\nToday, Redis wrap the user\
  \ Lua code with a Lua function. For example, assuming the user code is:\r\n\r\n```\r\nreturn\
  \ redis.call('ping')\r\n```\r\n\r\nThe actual code that would have sent to the Lua interpreter\
  \ was:\r\n\r\n```\r\nf_b3a02c833904802db9c34a3cf1292eee3246df3c() return redis.call('ping')\
  \ end\r\n```\r\n\r\nThe warped code would have been saved on the global dictionary with the\
  \ following name: `f_<script sha>` (in our example `f_b3a02c833904802db9c34a3cf1292eee3246df3c`).\
  \ This approach allows one user to easily override the implementation of another user code,\
  \ example:\r\n\r\n```\r\nf_b3a02c833904802db9c34a3cf1292eee3246df3c = function() return 'hacked'\
  \ end\r\n```\r\n\r\nRunning the above code will cause `evalsha b3a02c833904802db9c34a3cf1292eee3246df3c\
  \ 0` to return `hacked` although it should have returned `pong`. Another disadvantage is that\
  \ Redis basically runs code on the loading (compiling) phase without been aware of it. User\
  \ can do code injection like this:\r\n\r\n```\r\nreturn 1 end <run code on compling phase>\
  \ function() return 1\r\n```\r\n\r\nThe warped code will look like this and the entire `<run\
  \ code on compiling phase>` block will run outside of eval or evalsha context:\r\n\r\n```\r\
  \nf_<sha>() return 1 end <run code on compling phase> function() return 1 end\r\n```\r\n\r\
  \nThe commits puts the user code on a special Lua table called the registry. This table is\
  \ not accessible to the user so it can not be manipulated by him. Also there is no longer\
  \ a need to warp the user code so there is no risk in code injection which will cause running\
  \ code in the wrong context.\r\n\r\n### Use `lua_enablereadonlytable` to protect global tables\
  \ on eval and function\r\n\r\nThe commit uses the new `lua_enablereadonlytable` Lua API to\
  \ protect the global tables of both evals scripts and functions. For eval scripts, the implementation\
  \ is easy, We simply call `lua_enablereadonlytable` on the global table to turn it into a\
  \ readonly table.\r\n\r\nOn functions its more complected, we want to be able to switch globals\
  \ between load run and function run. To achieve this, we create a new empty table that acts\
  \ as the globals table for function, we control the actual globals using metatable manipulations.\
  \ Notice that even if the user gets a pointer to the original tables, all the tables are set\
  \ to be readonly (using `lua_enablereadonlytable` Lua API) so he can not change them. The\
  \ following better explains the solution:\r\n\r\n```\r\nGlobal table {} <- global table metatable\
  \ {.__index = __real_globals__}\r\n```\r\n\r\nThe `__real_globals__` is depends on the run\
  \ context (function load or function call).\r\n\r\nWhy is this solution needed and its not\
  \ enough to simply switch globals? When we run in the context of function load and create\
  \ our functions, our function gets the current globals that was set when they were created.\
  \ Replacing the globals after the creation will not effect them. This is why this trick it\
  \ mandatory.\r\n\r\n### Protect the rest of the global API and add an allowed list to the\
  \ provided API\r\n\r\nThe allowed list is done by setting a metatable on the global table\
  \ before initialising any library. The metatable set the `__newindex` field to a function\
  \ that check the allowed list before adding the field to the table. Fields which is not on\
  \ the\r\nallowed list are simply ignored.\r\n\r\nAfter initialisation phase is done we protect\
  \ the global table and each table that might be reachable from the global table. For each\
  \ table we also protect the table metatable if exists.\r\n\r\n### Performance\r\n\r\nPerformance\
  \ tests was done on a private computer and its only purpose is to show that this fix is not\
  \ causing any performance regression.\r\n\r\ncase 1: `return redis.call('ping')`\r\ncase 2:\
  \ `for i=1,10000000 do redis.call('ping') end`\r\n\r\n|                             | Unstable\
  \ eval | Unstable function | lua_readonly_tables eval | lua_readonly_tables function |\r\n\
  |-----------------------------|---------------|-------------------|--------------------------|------------------------------|\r\
  \n| case1 ops/sec               | 235904.70     | 236406.62         | 232180.16          \
  \     | 230574.14                   |\r\n| case1 avg latency ms        | 0.175         | 0.164\
  \             | 0.178                    | 0.149                        |\r\n| case2 total\
  \ time in seconds | 3.373         | 3.444s            | 3.268                   | 3.278  \
  \                      |\r\n\r\n### Breaking changes\r\n\r\n* `print` function was removed\
  \ from Lua because it can potentially cause the Redis processes to get stuck (if no one reads\
  \ from stdout). Users should use redis.log. An alternative is to override the `print` implementation\
  \ and print the message to the log file.\r\n\r\nAll the work by @MeirShpilraien, i'm just\
  \ publishing it."
impacted_packages:
  - purl: pkg:github/redis/redis
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/redis/redis
        commit: 89772ed827209c3dca376644498a235ef3edf692
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/redis/redis/tree/89772ed827209c3dca376644498a235ef3edf692
    reference_type: commit
    reference_id: 89772ed827209c3dca376644498a235ef3edf692
