advisory_id: CVE-2021-32626
datasource_id: collect_redis_fix_commits/CVE-2021-32626
datasource_url: https://github.com/redis/redis
aliases: []
summary: "a511af7c5e4c274925a2fa707c44e3e07ba9bee1:Clean Lua stack before parsing call reply\
  \ to avoid crash on a call with many arguments (#9809)\n\nThis commit 0f8b634cd (CVE-2021-32626\
  \ released in 6.2.6, 6.0.16, 5.0.14)\nfixes an invalid memory write issue by using `lua_checkstack`\
  \ API to make\nsure the Lua stack is not overflow. This fix was added on 3 places:\n1. `luaReplyToRedisReply`\n\
  2. `ldbRedis`\n3. `redisProtocolToLuaType`\n\nOn the first 2 functions, `lua_checkstack` is\
  \ handled gracefully while the\nlast is handled with an assert and a statement that this situation\
  \ can\nnot happened (only with misbehave module):\n\n> the Redis reply might be deep enough\
  \ to explode the LUA stack (notice\nthat currently there is no such command in Redis that\
  \ returns such a nested\nreply, but modules might do it)\n\nThe issue that was discovered\
  \ is that user arguments is also considered part\nof the stack, and so the following script\
  \ (for example) make the assertion reachable:\n```\nlocal a = {}\nfor i=1,7999 do\n    a[i]\
  \ = 1\nend\nreturn redis.call(\"lpush\", \"l\", unpack(a))\n```\n\nThis is a regression because\
  \ such a script would have worked before and now\nits crashing Redis. The solution is to clear\
  \ the function arguments from the Lua\nstack which makes the original assumption true and\
  \ the assertion unreachable.\n\n(cherry picked from commit 6b0b04f1b265c429bd19d6c99c9e7e2921723601)\n\
  93c1d31d97a995cd07a2c235b7a4e177f3c752cc:Clean Lua stack before parsing call reply to avoid\
  \ crash on a call with many arguments (#9809)\n\nThis commit 0f8b634cd (CVE-2021-32626 released\
  \ in 6.2.6, 6.0.16, 5.0.14)\nfixes an invalid memory write issue by using `lua_checkstack`\
  \ API to make\nsure the Lua stack is not overflow. This fix was added on 3 places:\n1. `luaReplyToRedisReply`\n\
  2. `ldbRedis`\n3. `redisProtocolToLuaType`\n\nOn the first 2 functions, `lua_checkstack` is\
  \ handled gracefully while the\nlast is handled with an assert and a statement that this situation\
  \ can\nnot happened (only with misbehave module):\n\n> the Redis reply might be deep enough\
  \ to explode the LUA stack (notice\nthat currently there is no such command in Redis that\
  \ returns such a nested\nreply, but modules might do it)\n\nThe issue that was discovered\
  \ is that user arguments is also considered part\nof the stack, and so the following script\
  \ (for example) make the assertion reachable:\n```\nlocal a = {}\nfor i=1,7999 do\n    a[i]\
  \ = 1\nend\nreturn redis.call(\"lpush\", \"l\", unpack(a))\n```\n\nThis is a regression because\
  \ such a script would have worked before and now\nits crashing Redis. The solution is to clear\
  \ the function arguments from the Lua\nstack which makes the original assumption true and\
  \ the assertion unreachable.\n\n(cherry picked from commit 6b0b04f1b265c429bd19d6c99c9e7e2921723601)\n\
  6b0b04f1b265c429bd19d6c99c9e7e2921723601:Clean Lua stack before parsing call reply to avoid\
  \ crash on a call with many arguments (#9809)\n\nThis commit 0f8b634cd (CVE-2021-32626 released\
  \ in 6.2.6, 6.0.16, 5.0.14)\r\nfixes an invalid memory write issue by using `lua_checkstack`\
  \ API to make\r\nsure the Lua stack is not overflow. This fix was added on 3 places:\r\n1.\
  \ `luaReplyToRedisReply`\r\n2. `ldbRedis`\r\n3. `redisProtocolToLuaType`\r\n\r\nOn the first\
  \ 2 functions, `lua_checkstack` is handled gracefully while the\r\nlast is handled with an\
  \ assert and a statement that this situation can\r\nnot happened (only with misbehave module):\r\
  \n\r\n> the Redis reply might be deep enough to explode the LUA stack (notice\r\nthat currently\
  \ there is no such command in Redis that returns such a nested\r\nreply, but modules might\
  \ do it)\r\n\r\nThe issue that was discovered is that user arguments is also considered part\r\
  \nof the stack, and so the following script (for example) make the assertion reachable:\r\n\
  ```\r\nlocal a = {}\r\nfor i=1,7999 do\r\n    a[i] = 1\r\nend \r\nreturn redis.call(\"lpush\"\
  , \"l\", unpack(a))\r\n```\r\n\r\nThis is a regression because such a script would have worked\
  \ before and now\r\nits crashing Redis. The solution is to clear the function arguments from\
  \ the Lua\r\nstack which makes the original assumption true and the assertion unreachable.\n\
  0f8b634cd5cdfd77696d34d744dfc25fa97f3b73:Fix invalid memory write on lua stack overflow (CVE-2021-32626)\
  \ (#9591)\n\nWhen LUA call our C code, by default, the LUA stack has room for 10\r\nelements.\
  \ In most cases, this is more than enough but sometimes it's not\r\nand the caller must verify\
  \ the LUA stack size before he pushes elements.\r\n\r\nOn 3 places in the code, there was\
  \ no verification of the LUA stack size.\r\nOn specific inputs this missing verification could\
  \ have lead to invalid\r\nmemory write:\r\n1. On 'luaReplyToRedisReply', one might return\
  \ a nested reply that will\r\n   explode the LUA stack.\r\n2. On 'redisProtocolToLuaType',\
  \ the Redis reply might be deep enough\r\n   to explode the LUA stack (notice that currently\
  \ there is no such\r\n   command in Redis that returns such a nested reply, but modules might\r\
  \n   do it)\r\n3. On 'ldbRedis', one might give a command with enough arguments to\r\n   explode\
  \ the LUA stack (all the arguments will be pushed to the LUA\r\n   stack)\r\n\r\nThis commit\
  \ is solving all those 3 issues by calling 'lua_checkstack' and\r\nverify that there is enough\
  \ room in the LUA stack to push elements. In\r\ncase 'lua_checkstack' returns an error (there\
  \ is not enough room in the\r\nLUA stack and it's not possible to increase the stack), we\
  \ will do the\r\nfollowing:\r\n1. On 'luaReplyToRedisReply', we will return an error to the\
  \ user.\r\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\r\n   scenario\
  \ is rare because it can only happen with a module).\r\n3. On 'ldbRedis', we return an error.\n\
  8f241ab3b8095186d008dbf78f0af90918f129bc:Fix invalid memory write on lua stack overflow {CVE-2021-32626}\n\
  \nWhen LUA call our C code, by default, the LUA stack has room for 20\nelements. In most cases,\
  \ this is more than enough but sometimes it's not\nand the caller must verify the LUA stack\
  \ size before he pushes elements.\n\nOn 3 places in the code, there was no verification of\
  \ the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\n\
  memory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n \
  \  explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n\
     to explode the LUA stack (notice that currently there is no such\n   command in Redis that\
  \ returns such a nested reply, but modules might\n   do it)\n3. On 'ldbRedis', one might give\
  \ a command with enough arguments to\n   explode the LUA stack (all the arguments will be\
  \ pushed to the LUA\n   stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack'\
  \ and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack'\
  \ returns an error (there is not enough room in the\nLUA stack and it's not possible to increase\
  \ the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an\
  \ error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n\
  \   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return\
  \ an error.\n666ed7facf4524bf6d19b11b20faa2cf93fdf591:Fix invalid memory write on lua stack\
  \ overflow {CVE-2021-32626}\n\nWhen LUA call our C code, by default, the LUA stack has room\
  \ for 20\nelements. In most cases, this is more than enough but sometimes it's not\nand the\
  \ caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code,\
  \ there was no verification of the LUA stack size.\nOn specific inputs this missing verification\
  \ could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return\
  \ a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the\
  \ Redis reply might be deep enough\n   to explode the LUA stack (notice that currently there\
  \ is no such\n   command in Redis that returns such a nested reply, but modules might\n   do\
  \ it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n   explode the\
  \ LUA stack (all the arguments will be pushed to the LUA\n   stack)\n\nThis commit is solving\
  \ all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in\
  \ the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not\
  \ enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\n\
  following:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType'\
  \ we will exit with panic (we assume this\n   scenario is rare because it can only happen\
  \ with a module).\n3. On 'ldbRedis', we return an error.\na4b813d8b844094fcd77c511af596866043b20c8:Fix\
  \ invalid memory write on lua stack overflow {CVE-2021-32626}\n\nWhen LUA call our C code,\
  \ by default, the LUA stack has room for 20\nelements. In most cases, this is more than enough\
  \ but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\
  \nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs\
  \ this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply',\
  \ one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType',\
  \ the Redis reply might be deep enough\n   to explode the LUA stack (notice that currently\
  \ there is no such\n   command in Redis that returns such a nested reply, but modules might\n\
     do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n   explode\
  \ the LUA stack (all the arguments will be pushed to the LUA\n   stack)\n\nThis commit is\
  \ solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough\
  \ room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there\
  \ is not enough room in the\nLUA stack and it's not possible to increase the stack), we will\
  \ do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n\
  2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare\
  \ because it can only happen with a module).\n3. On 'ldbRedis', we return an error.\n\n(cherry\
  \ picked from commit d32a3f74f2a343846b50920e95754a955c1a10a9)"
impacted_packages:
  - purl: pkg:github/redis/redis
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/redis/redis
        commit: 8f241ab3b8095186d008dbf78f0af90918f129bc
    introduced_in_commits: []
  - purl: pkg:github/redis/redis
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/redis/redis
        commit: 6b0b04f1b265c429bd19d6c99c9e7e2921723601
    introduced_in_commits: []
  - purl: pkg:github/redis/redis
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/redis/redis
        commit: a4b813d8b844094fcd77c511af596866043b20c8
    introduced_in_commits: []
  - purl: pkg:github/redis/redis
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/redis/redis
        commit: 93c1d31d97a995cd07a2c235b7a4e177f3c752cc
    introduced_in_commits: []
  - purl: pkg:github/redis/redis
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/redis/redis
        commit: 666ed7facf4524bf6d19b11b20faa2cf93fdf591
    introduced_in_commits: []
  - purl: pkg:github/redis/redis
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/redis/redis
        commit: a511af7c5e4c274925a2fa707c44e3e07ba9bee1
    introduced_in_commits: []
  - purl: pkg:github/redis/redis
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/redis/redis
        commit: 0f8b634cd5cdfd77696d34d744dfc25fa97f3b73
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/redis/redis/tree/0f8b634cd5cdfd77696d34d744dfc25fa97f3b73
    reference_type: commit
    reference_id: 0f8b634cd5cdfd77696d34d744dfc25fa97f3b73
  - url: https://github.com/redis/redis/tree/666ed7facf4524bf6d19b11b20faa2cf93fdf591
    reference_type: commit
    reference_id: 666ed7facf4524bf6d19b11b20faa2cf93fdf591
  - url: https://github.com/redis/redis/tree/6b0b04f1b265c429bd19d6c99c9e7e2921723601
    reference_type: commit
    reference_id: 6b0b04f1b265c429bd19d6c99c9e7e2921723601
  - url: https://github.com/redis/redis/tree/8f241ab3b8095186d008dbf78f0af90918f129bc
    reference_type: commit
    reference_id: 8f241ab3b8095186d008dbf78f0af90918f129bc
  - url: https://github.com/redis/redis/tree/93c1d31d97a995cd07a2c235b7a4e177f3c752cc
    reference_type: commit
    reference_id: 93c1d31d97a995cd07a2c235b7a4e177f3c752cc
  - url: https://github.com/redis/redis/tree/a4b813d8b844094fcd77c511af596866043b20c8
    reference_type: commit
    reference_id: a4b813d8b844094fcd77c511af596866043b20c8
  - url: https://github.com/redis/redis/tree/a511af7c5e4c274925a2fa707c44e3e07ba9bee1
    reference_type: commit
    reference_id: a511af7c5e4c274925a2fa707c44e3e07ba9bee1
