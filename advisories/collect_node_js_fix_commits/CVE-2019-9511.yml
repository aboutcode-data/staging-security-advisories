advisory_id: CVE-2019-9511
datasource_id: collect_node_js_fix_commits/CVE-2019-9511
datasource_url: https://github.com/nodejs/node
aliases: []
summary: |
  affa23bc88849f962e6fd784852c3db242bfeb19:2019-08-15, Version 8.16.1 'Carbon' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29152
  004e2b759ffff2dff4b0d45c630e3305350b41df:2019-08-15, Version 10.16.3 'Dubnium' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29148
  5744b466c45d5324c60f122b02681813d4496749:2019-08-15, Version 8.16.1 'Carbon' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29152
  75657ee41677d56a498e298b01d049aef5bf199f:2019-08-15, Version 10.16.3 'Dubnium' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29148
  6d687f7af8c23c44d8ae56374d84a07ec792dac2:http2: pause input processing if sending output

  If we are waiting for the ability to send more output, we should not
  process more input. This commit a) makes us send output earlier,
  during processing of input, if we accumulate a lot and b) allows
  interrupting the call into nghttp2 that processes input data
  and resuming it at a later time, if we do find ourselves in a position
  where we are waiting to be able to send more output.

  This is part of mitigating CVE-2019-9511/CVE-2019-9517.

  Backport-PR-URL: https://github.com/nodejs/node/pull/29124
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  854dba649e826cacfd7e682d567a70b388b52184:http2: stop reading from socket if writes are in progress

  If a write to the underlying socket finishes asynchronously, that
  means that we cannot write any more data at that point without waiting
  for it to finish. If this happens, we should also not be producing any
  more input.

  This is part of mitigating CVE-2019-9511/CVE-2019-9517.

  Backport-PR-URL: https://github.com/nodejs/node/pull/29124
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  c152449012e21dbf1c3e8bd2081600b9f3858549:http2: pause input processing if sending output

  If we are waiting for the ability to send more output, we should not
  process more input. This commit a) makes us send output earlier,
  during processing of input, if we accumulate a lot and b) allows
  interrupting the call into nghttp2 that processes input data
  and resuming it at a later time, if we do find ourselves in a position
  where we are waiting to be able to send more output.

  This is part of mitigating CVE-2019-9511/CVE-2019-9517.

  Backport-PR-URL: https://github.com/nodejs/node/pull/29123
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  0ce699c7b120ae7c672f4ffd0dc1562db3dae0a7:http2: stop reading from socket if writes are in progress

  If a write to the underlying socket finishes asynchronously, that
  means that we cannot write any more data at that point without waiting
  for it to finish. If this happens, we should also not be producing any
  more input.

  This is part of mitigating CVE-2019-9511/CVE-2019-9517.

  Backport-PR-URL: https://github.com/nodejs/node/pull/29123
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  edc2e5be34abe45b6d2e0dbccecb1771ecf82286:2019-08-15, Version 12.8.1 (Current)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29133
  787378879acfb212ed4ff824bf9f767a24a5cb43:2019-08-15, Version 12.8.1 (Current)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29133
  bbb4769cc12a285ff79a4fb7a344fdf0605e3298:http2: pause input processing if sending output

  If we are waiting for the ability to send more output, we should not
  process more input. This commit a) makes us send output earlier,
  during processing of input, if we accumulate a lot and b) allows
  interrupting the call into nghttp2 that processes input data
  and resuming it at a later time, if we do find ourselves in a position
  where we are waiting to be able to send more output.

  This is part of mitigating CVE-2019-9511/CVE-2019-9517.

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  f64515b05e72cb4889278874b0d08439f9f06fa0:http2: stop reading from socket if writes are in progress

  If a write to the underlying socket finishes asynchronously, that
  means that we cannot write any more data at that point without waiting
  for it to finish. If this happens, we should also not be producing any
  more input.

  This is part of mitigating CVE-2019-9511/CVE-2019-9517.

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  8a4a1931b8b98242abb590936c31f0c20dd2e08f:http2: pause input processing if sending output

  If we are waiting for the ability to send more output, we should not
  process more input. This commit a) makes us send output earlier,
  during processing of input, if we accumulate a lot and b) allows
  interrupting the call into nghttp2 that processes input data
  and resuming it at a later time, if we do find ourselves in a position
  where we are waiting to be able to send more output.

  This is part of mitigating CVE-2019-9511/CVE-2019-9517.

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  ba624b6766fffc11fc9a387feee58be2c5e1d8b8:http2: stop reading from socket if writes are in progress

  If a write to the underlying socket finishes asynchronously, that
  means that we cannot write any more data at that point without waiting
  for it to finish. If this happens, we should also not be producing any
  more input.

  This is part of mitigating CVE-2019-9511/CVE-2019-9517.

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
impacted_packages:
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 75657ee41677d56a498e298b01d049aef5bf199f
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 0ce699c7b120ae7c672f4ffd0dc1562db3dae0a7
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: c152449012e21dbf1c3e8bd2081600b9f3858549
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 787378879acfb212ed4ff824bf9f767a24a5cb43
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 8a4a1931b8b98242abb590936c31f0c20dd2e08f
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: edc2e5be34abe45b6d2e0dbccecb1771ecf82286
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 6d687f7af8c23c44d8ae56374d84a07ec792dac2
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: bbb4769cc12a285ff79a4fb7a344fdf0605e3298
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 854dba649e826cacfd7e682d567a70b388b52184
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: f64515b05e72cb4889278874b0d08439f9f06fa0
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: affa23bc88849f962e6fd784852c3db242bfeb19
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 5744b466c45d5324c60f122b02681813d4496749
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: ba624b6766fffc11fc9a387feee58be2c5e1d8b8
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 004e2b759ffff2dff4b0d45c630e3305350b41df
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/nodejs/node/tree/004e2b759ffff2dff4b0d45c630e3305350b41df
    reference_type: commit
    reference_id: 004e2b759ffff2dff4b0d45c630e3305350b41df
  - url: https://github.com/nodejs/node/tree/0ce699c7b120ae7c672f4ffd0dc1562db3dae0a7
    reference_type: commit
    reference_id: 0ce699c7b120ae7c672f4ffd0dc1562db3dae0a7
  - url: https://github.com/nodejs/node/tree/5744b466c45d5324c60f122b02681813d4496749
    reference_type: commit
    reference_id: 5744b466c45d5324c60f122b02681813d4496749
  - url: https://github.com/nodejs/node/tree/6d687f7af8c23c44d8ae56374d84a07ec792dac2
    reference_type: commit
    reference_id: 6d687f7af8c23c44d8ae56374d84a07ec792dac2
  - url: https://github.com/nodejs/node/tree/75657ee41677d56a498e298b01d049aef5bf199f
    reference_type: commit
    reference_id: 75657ee41677d56a498e298b01d049aef5bf199f
  - url: https://github.com/nodejs/node/tree/787378879acfb212ed4ff824bf9f767a24a5cb43
    reference_type: commit
    reference_id: 787378879acfb212ed4ff824bf9f767a24a5cb43
  - url: https://github.com/nodejs/node/tree/854dba649e826cacfd7e682d567a70b388b52184
    reference_type: commit
    reference_id: 854dba649e826cacfd7e682d567a70b388b52184
  - url: https://github.com/nodejs/node/tree/8a4a1931b8b98242abb590936c31f0c20dd2e08f
    reference_type: commit
    reference_id: 8a4a1931b8b98242abb590936c31f0c20dd2e08f
  - url: https://github.com/nodejs/node/tree/affa23bc88849f962e6fd784852c3db242bfeb19
    reference_type: commit
    reference_id: affa23bc88849f962e6fd784852c3db242bfeb19
  - url: https://github.com/nodejs/node/tree/ba624b6766fffc11fc9a387feee58be2c5e1d8b8
    reference_type: commit
    reference_id: ba624b6766fffc11fc9a387feee58be2c5e1d8b8
  - url: https://github.com/nodejs/node/tree/bbb4769cc12a285ff79a4fb7a344fdf0605e3298
    reference_type: commit
    reference_id: bbb4769cc12a285ff79a4fb7a344fdf0605e3298
  - url: https://github.com/nodejs/node/tree/c152449012e21dbf1c3e8bd2081600b9f3858549
    reference_type: commit
    reference_id: c152449012e21dbf1c3e8bd2081600b9f3858549
  - url: https://github.com/nodejs/node/tree/edc2e5be34abe45b6d2e0dbccecb1771ecf82286
    reference_type: commit
    reference_id: edc2e5be34abe45b6d2e0dbccecb1771ecf82286
  - url: https://github.com/nodejs/node/tree/f64515b05e72cb4889278874b0d08439f9f06fa0
    reference_type: commit
    reference_id: f64515b05e72cb4889278874b0d08439f9f06fa0
