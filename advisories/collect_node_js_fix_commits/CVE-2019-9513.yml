advisory_id: CVE-2019-9513
datasource_id: collect_node_js_fix_commits/CVE-2019-9513
datasource_url: https://github.com/nodejs/node
aliases: []
summary: |
  affa23bc88849f962e6fd784852c3db242bfeb19:2019-08-15, Version 8.16.1 'Carbon' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29152
  004e2b759ffff2dff4b0d45c630e3305350b41df:2019-08-15, Version 10.16.3 'Dubnium' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29148
  5744b466c45d5324c60f122b02681813d4496749:2019-08-15, Version 8.16.1 'Carbon' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29152
  75657ee41677d56a498e298b01d049aef5bf199f:2019-08-15, Version 10.16.3 'Dubnium' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29148
  7de642b6f98dfa3347ae5ea9268e683a02cc42b1:http2: do not create ArrayBuffers when no DATA received

  Lazily allocate `ArrayBuffer`s for the contents of DATA frames.
  Creating `ArrayBuffer`s is, sadly, not a cheap operation with V8.

  This is part of performance improvements to mitigate CVE-2019-9513.

  Together with the previous commit, these changes improve throughput
  in the adversarial case by about 100 %, and there is little more
  that we can do besides artificially limiting the rate of incoming
  metadata frames (i.e. after this patch, CPU usage is virtually
  exclusively in libnghttp2).

  [This backport also applies changes from 83e1b9744317 and required
  some manual work due to the lack of `AllocatedBuffer` on v10.x.
  More work was necessary for v8.x, including copying utilities
  for `util.h` from more recent Node.js versions.]

  Refs: https://github.com/nodejs/node/pull/26201

  Backport-PR-URL: https://github.com/nodejs/node/pull/29124
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  dd60d3561a029f862a988d90a0e5ec261e8c3e5d:http2: only call into JS when necessary for session events

  For some JS events, it only makes sense to call into JS when there
  are listeners for the event in question.

  The overhead is noticeable if a lot of these events are emitted during
  the lifetime of a session. To reduce this overhead, keep track of
  whether any/how many JS listeners are present, and if there are none,
  skip calls into JS altogether.

  This is part of performance improvements to mitigate CVE-2019-9513.

  Backport-PR-URL: https://github.com/nodejs/node/pull/29124
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  7f11465572888340b4c7b399c1f46598d1c4ea50:http2: do not create ArrayBuffers when no DATA received

  Lazily allocate `ArrayBuffer`s for the contents of DATA frames.
  Creating `ArrayBuffer`s is, sadly, not a cheap operation with V8.

  This is part of performance improvements to mitigate CVE-2019-9513.

  Together with the previous commit, these changes improve throughput
  in the adversarial case by about 100 %, and there is little more
  that we can do besides artificially limiting the rate of incoming
  metadata frames (i.e. after this patch, CPU usage is virtually
  exclusively in libnghttp2).

  [This backport also applies changes from 83e1b9744317 and required
  some manual work due to the lack of `AllocatedBuffer` on v10.x.]

  Refs: https://github.com/nodejs/node/pull/26201

  Backport-PR-URL: https://github.com/nodejs/node/pull/29123
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  2eb914ff5f1f3ddcbe91c50c5b0ae3fe565e2bba:http2: only call into JS when necessary for session events

  For some JS events, it only makes sense to call into JS when there
  are listeners for the event in question.

  The overhead is noticeable if a lot of these events are emitted during
  the lifetime of a session. To reduce this overhead, keep track of
  whether any/how many JS listeners are present, and if there are none,
  skip calls into JS altogether.

  This is part of performance improvements to mitigate CVE-2019-9513.

  Backport-PR-URL: https://github.com/nodejs/node/pull/29123
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  edc2e5be34abe45b6d2e0dbccecb1771ecf82286:2019-08-15, Version 12.8.1 (Current)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29133
  787378879acfb212ed4ff824bf9f767a24a5cb43:2019-08-15, Version 12.8.1 (Current)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29133
  88726f2384f3b3b50e103984f31bbbc6881d7ab1:http2: do not create ArrayBuffers when no DATA received

  Lazily allocate `ArrayBuffer`s for the contents of DATA frames.
  Creating `ArrayBuffer`s is, sadly, not a cheap operation with V8.

  This is part of performance improvements to mitigate CVE-2019-9513.

  Together with the previous commit, these changes improve throughput
  in the adversarial case by about 100 %, and there is little more
  that we can do besides artificially limiting the rate of incoming
  metadata frames (i.e. after this patch, CPU usage is virtually
  exclusively in libnghttp2).

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  530004ef32333520812c5cecf8f768cecf9a4392:http2: only call into JS when necessary for session events

  For some JS events, it only makes sense to call into JS when there
  are listeners for the event in question.

  The overhead is noticeable if a lot of these events are emitted during
  the lifetime of a session. To reduce this overhead, keep track of
  whether any/how many JS listeners are present, and if there are none,
  skip calls into JS altogether.

  This is part of performance improvements to mitigate CVE-2019-9513.

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  599eee0990c98ef0e6cc32f1c9dbf2f35b63a923:http2: do not create ArrayBuffers when no DATA received

  Lazily allocate `ArrayBuffer`s for the contents of DATA frames.
  Creating `ArrayBuffer`s is, sadly, not a cheap operation with V8.

  This is part of performance improvements to mitigate CVE-2019-9513.

  Together with the previous commit, these changes improve throughput
  in the adversarial case by about 100 %, and there is little more
  that we can do besides artificially limiting the rate of incoming
  metadata frames (i.e. after this patch, CPU usage is virtually
  exclusively in libnghttp2).

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  c44ee7a14a400c8bdc80b31848234f5f55351690:http2: only call into JS when necessary for session events

  For some JS events, it only makes sense to call into JS when there
  are listeners for the event in question.

  The overhead is noticeable if a lot of these events are emitted during
  the lifetime of a session. To reduce this overhead, keep track of
  whether any/how many JS listeners are present, and if there are none,
  skip calls into JS altogether.

  This is part of performance improvements to mitigate CVE-2019-9513.

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
impacted_packages:
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 75657ee41677d56a498e298b01d049aef5bf199f
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 599eee0990c98ef0e6cc32f1c9dbf2f35b63a923
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 530004ef32333520812c5cecf8f768cecf9a4392
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: c44ee7a14a400c8bdc80b31848234f5f55351690
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 787378879acfb212ed4ff824bf9f767a24a5cb43
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: edc2e5be34abe45b6d2e0dbccecb1771ecf82286
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 7de642b6f98dfa3347ae5ea9268e683a02cc42b1
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 88726f2384f3b3b50e103984f31bbbc6881d7ab1
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 7f11465572888340b4c7b399c1f46598d1c4ea50
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: dd60d3561a029f862a988d90a0e5ec261e8c3e5d
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: affa23bc88849f962e6fd784852c3db242bfeb19
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 5744b466c45d5324c60f122b02681813d4496749
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 004e2b759ffff2dff4b0d45c630e3305350b41df
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 2eb914ff5f1f3ddcbe91c50c5b0ae3fe565e2bba
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/nodejs/node/tree/004e2b759ffff2dff4b0d45c630e3305350b41df
    reference_type: commit
    reference_id: 004e2b759ffff2dff4b0d45c630e3305350b41df
  - url: https://github.com/nodejs/node/tree/2eb914ff5f1f3ddcbe91c50c5b0ae3fe565e2bba
    reference_type: commit
    reference_id: 2eb914ff5f1f3ddcbe91c50c5b0ae3fe565e2bba
  - url: https://github.com/nodejs/node/tree/530004ef32333520812c5cecf8f768cecf9a4392
    reference_type: commit
    reference_id: 530004ef32333520812c5cecf8f768cecf9a4392
  - url: https://github.com/nodejs/node/tree/5744b466c45d5324c60f122b02681813d4496749
    reference_type: commit
    reference_id: 5744b466c45d5324c60f122b02681813d4496749
  - url: https://github.com/nodejs/node/tree/599eee0990c98ef0e6cc32f1c9dbf2f35b63a923
    reference_type: commit
    reference_id: 599eee0990c98ef0e6cc32f1c9dbf2f35b63a923
  - url: https://github.com/nodejs/node/tree/75657ee41677d56a498e298b01d049aef5bf199f
    reference_type: commit
    reference_id: 75657ee41677d56a498e298b01d049aef5bf199f
  - url: https://github.com/nodejs/node/tree/787378879acfb212ed4ff824bf9f767a24a5cb43
    reference_type: commit
    reference_id: 787378879acfb212ed4ff824bf9f767a24a5cb43
  - url: https://github.com/nodejs/node/tree/7de642b6f98dfa3347ae5ea9268e683a02cc42b1
    reference_type: commit
    reference_id: 7de642b6f98dfa3347ae5ea9268e683a02cc42b1
  - url: https://github.com/nodejs/node/tree/7f11465572888340b4c7b399c1f46598d1c4ea50
    reference_type: commit
    reference_id: 7f11465572888340b4c7b399c1f46598d1c4ea50
  - url: https://github.com/nodejs/node/tree/88726f2384f3b3b50e103984f31bbbc6881d7ab1
    reference_type: commit
    reference_id: 88726f2384f3b3b50e103984f31bbbc6881d7ab1
  - url: https://github.com/nodejs/node/tree/affa23bc88849f962e6fd784852c3db242bfeb19
    reference_type: commit
    reference_id: affa23bc88849f962e6fd784852c3db242bfeb19
  - url: https://github.com/nodejs/node/tree/c44ee7a14a400c8bdc80b31848234f5f55351690
    reference_type: commit
    reference_id: c44ee7a14a400c8bdc80b31848234f5f55351690
  - url: https://github.com/nodejs/node/tree/dd60d3561a029f862a988d90a0e5ec261e8c3e5d
    reference_type: commit
    reference_id: dd60d3561a029f862a988d90a0e5ec261e8c3e5d
  - url: https://github.com/nodejs/node/tree/edc2e5be34abe45b6d2e0dbccecb1771ecf82286
    reference_type: commit
    reference_id: edc2e5be34abe45b6d2e0dbccecb1771ecf82286
