advisory_id: CVE-2019-9518
datasource_id: collect_node_js_fix_commits/CVE-2019-9518
datasource_url: https://github.com/nodejs/node
aliases: []
summary: |
  d8da265c81fb27925f744986bc9c7592d8ed24cc:http2: treat non-EOF empty frames like other invalid frames

  Use the existing mechanism that we have to keep track of invalid frames
  for treating this specific kind of invalid frame.

  The commit that originally introduced this check was 695e38be69a780417,
  which was supposed to proected against CVE-2019-9518, which in turn
  was specifically about a *flood* of empty data frames. While these are
  still invalid frames either way, it makes sense to be forgiving here
  and just treat them like other invalid frames, i.e. to allow a small
  (configurable) number of them.

  Fixes: https://github.com/nodejs/node/issues/37849

  PR-URL: https://github.com/nodejs/node/pull/37875
  Backport-PR-URL: https://github.com/nodejs/node/pull/38673
  Reviewed-By: Matteo Collina <matteo.collina@gmail.com>
  Reviewed-By: Colin Ihrig <cjihrig@gmail.com>
  1c043272ea775621156bfa4e78718108803b3315:http2: treat non-EOF empty frames like other invalid frames

  Use the existing mechanism that we have to keep track of invalid frames
  for treating this specific kind of invalid frame.

  The commit that originally introduced this check was 695e38be69a780417,
  which was supposed to proected against CVE-2019-9518, which in turn
  was specifically about a *flood* of empty data frames. While these are
  still invalid frames either way, it makes sense to be forgiving here
  and just treat them like other invalid frames, i.e. to allow a small
  (configurable) number of them.

  Fixes: https://github.com/nodejs/node/issues/37849

  PR-URL: https://github.com/nodejs/node/pull/37875
  Reviewed-By: Matteo Collina <matteo.collina@gmail.com>
  Reviewed-By: Colin Ihrig <cjihrig@gmail.com>
  87aa3f1add031361a7bf86a3044c22a66d8cc47e:http2: treat non-EOF empty frames like other invalid frames

  Use the existing mechanism that we have to keep track of invalid frames
  for treating this specific kind of invalid frame.

  The commit that originally introduced this check was 695e38be69a780417,
  which was supposed to proected against CVE-2019-9518, which in turn
  was specifically about a *flood* of empty data frames. While these are
  still invalid frames either way, it makes sense to be forgiving here
  and just treat them like other invalid frames, i.e. to allow a small
  (configurable) number of them.

  Fixes: https://github.com/nodejs/node/issues/37849

  PR-URL: https://github.com/nodejs/node/pull/37875
  Reviewed-By: Matteo Collina <matteo.collina@gmail.com>
  Reviewed-By: Colin Ihrig <cjihrig@gmail.com>
  affa23bc88849f962e6fd784852c3db242bfeb19:2019-08-15, Version 8.16.1 'Carbon' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29152
  004e2b759ffff2dff4b0d45c630e3305350b41df:2019-08-15, Version 10.16.3 'Dubnium' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29148
  5744b466c45d5324c60f122b02681813d4496749:2019-08-15, Version 8.16.1 'Carbon' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29152
  75657ee41677d56a498e298b01d049aef5bf199f:2019-08-15, Version 10.16.3 'Dubnium' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29148
  a3191689ddd8ac7ade7b309840d87f99438f867f:http2: consider 0-length non-end DATA frames an error

  This is intended to mitigate CVE-2019-9518.

  Backport-PR-URL: https://github.com/nodejs/node/pull/29124
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  17357d37a9eba4ac1cbafe8628bf12cc900bc642:http2: consider 0-length non-end DATA frames an error

  This is intended to mitigate CVE-2019-9518.

  Backport-PR-URL: https://github.com/nodejs/node/pull/29123
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  edc2e5be34abe45b6d2e0dbccecb1771ecf82286:2019-08-15, Version 12.8.1 (Current)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29133
  787378879acfb212ed4ff824bf9f767a24a5cb43:2019-08-15, Version 12.8.1 (Current)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29133
  ba332df5d2b7c8932378e0bf1c1937665bba1df2:http2: consider 0-length non-end DATA frames an error

  This is intended to mitigate CVE-2019-9518.

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  695e38be69a780417eef32db744528c3c78d6b0b:http2: consider 0-length non-end DATA frames an error

  This is intended to mitigate CVE-2019-9518.

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
impacted_packages:
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: d8da265c81fb27925f744986bc9c7592d8ed24cc
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 75657ee41677d56a498e298b01d049aef5bf199f
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 1c043272ea775621156bfa4e78718108803b3315
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: ba332df5d2b7c8932378e0bf1c1937665bba1df2
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 17357d37a9eba4ac1cbafe8628bf12cc900bc642
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 787378879acfb212ed4ff824bf9f767a24a5cb43
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: a3191689ddd8ac7ade7b309840d87f99438f867f
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: edc2e5be34abe45b6d2e0dbccecb1771ecf82286
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 695e38be69a780417eef32db744528c3c78d6b0b
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 87aa3f1add031361a7bf86a3044c22a66d8cc47e
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: affa23bc88849f962e6fd784852c3db242bfeb19
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 5744b466c45d5324c60f122b02681813d4496749
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 004e2b759ffff2dff4b0d45c630e3305350b41df
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/nodejs/node/tree/004e2b759ffff2dff4b0d45c630e3305350b41df
    reference_type: commit
    reference_id: 004e2b759ffff2dff4b0d45c630e3305350b41df
  - url: https://github.com/nodejs/node/tree/17357d37a9eba4ac1cbafe8628bf12cc900bc642
    reference_type: commit
    reference_id: 17357d37a9eba4ac1cbafe8628bf12cc900bc642
  - url: https://github.com/nodejs/node/tree/1c043272ea775621156bfa4e78718108803b3315
    reference_type: commit
    reference_id: 1c043272ea775621156bfa4e78718108803b3315
  - url: https://github.com/nodejs/node/tree/5744b466c45d5324c60f122b02681813d4496749
    reference_type: commit
    reference_id: 5744b466c45d5324c60f122b02681813d4496749
  - url: https://github.com/nodejs/node/tree/695e38be69a780417eef32db744528c3c78d6b0b
    reference_type: commit
    reference_id: 695e38be69a780417eef32db744528c3c78d6b0b
  - url: https://github.com/nodejs/node/tree/75657ee41677d56a498e298b01d049aef5bf199f
    reference_type: commit
    reference_id: 75657ee41677d56a498e298b01d049aef5bf199f
  - url: https://github.com/nodejs/node/tree/787378879acfb212ed4ff824bf9f767a24a5cb43
    reference_type: commit
    reference_id: 787378879acfb212ed4ff824bf9f767a24a5cb43
  - url: https://github.com/nodejs/node/tree/87aa3f1add031361a7bf86a3044c22a66d8cc47e
    reference_type: commit
    reference_id: 87aa3f1add031361a7bf86a3044c22a66d8cc47e
  - url: https://github.com/nodejs/node/tree/a3191689ddd8ac7ade7b309840d87f99438f867f
    reference_type: commit
    reference_id: a3191689ddd8ac7ade7b309840d87f99438f867f
  - url: https://github.com/nodejs/node/tree/affa23bc88849f962e6fd784852c3db242bfeb19
    reference_type: commit
    reference_id: affa23bc88849f962e6fd784852c3db242bfeb19
  - url: https://github.com/nodejs/node/tree/ba332df5d2b7c8932378e0bf1c1937665bba1df2
    reference_type: commit
    reference_id: ba332df5d2b7c8932378e0bf1c1937665bba1df2
  - url: https://github.com/nodejs/node/tree/d8da265c81fb27925f744986bc9c7592d8ed24cc
    reference_type: commit
    reference_id: d8da265c81fb27925f744986bc9c7592d8ed24cc
  - url: https://github.com/nodejs/node/tree/edc2e5be34abe45b6d2e0dbccecb1771ecf82286
    reference_type: commit
    reference_id: edc2e5be34abe45b6d2e0dbccecb1771ecf82286
