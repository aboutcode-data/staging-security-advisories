advisory_id: CVE-2019-9516
datasource_id: collect_node_js_fix_commits/CVE-2019-9516
datasource_url: https://github.com/nodejs/node
aliases: []
summary: |
  affa23bc88849f962e6fd784852c3db242bfeb19:2019-08-15, Version 8.16.1 'Carbon' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29152
  004e2b759ffff2dff4b0d45c630e3305350b41df:2019-08-15, Version 10.16.3 'Dubnium' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29148
  5744b466c45d5324c60f122b02681813d4496749:2019-08-15, Version 8.16.1 'Carbon' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29152
  75657ee41677d56a498e298b01d049aef5bf199f:2019-08-15, Version 10.16.3 'Dubnium' (LTS)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29148
  10f05b65c4c84c21e203271301dc5187253c66dc:http2: handle 0-length headers better

  Ignore headers with 0-length names and track memory for headers
  the way we track it for other HTTP/2 session memory too.

  This is intended to mitigate CVE-2019-9516.

  Backport-PR-URL: https://github.com/nodejs/node/pull/29124
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  f4242e24f9f4fb185909f040cbd2dd889d79439b:http2: handle 0-length headers better

  Ignore headers with 0-length names and track memory for headers
  the way we track it for other HTTP/2 session memory too.

  This is intended to mitigate CVE-2019-9516.

  Backport-PR-URL: https://github.com/nodejs/node/pull/29123
  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  edc2e5be34abe45b6d2e0dbccecb1771ecf82286:2019-08-15, Version 12.8.1 (Current)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29133
  787378879acfb212ed4ff824bf9f767a24a5cb43:2019-08-15, Version 12.8.1 (Current)

  This is a security release.

  Notable changes:

  Node.js, as well as many other implementations of HTTP/2, have been
  found vulnerable to Denial of Service attacks.
  See https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md
  for more information.

  Vulnerabilities fixed:

  * CVE-2019-9511 “Data Dribble”: The attacker requests a large amount of
    data from a specified resource over multiple streams. They manipulate
    window size and stream priority to force the server to queue the data
    in 1-byte chunks. Depending on how efficiently this data is queued,
    this can consume excess CPU, memory, or both, potentially leading to a
    denial of service.
  * CVE-2019-9512 “Ping Flood”: The attacker sends continual pings to an
    HTTP/2 peer, causing the peer to build an internal queue of responses.
    Depending on how efficiently this data is queued, this can consume
    excess CPU, memory, or both, potentially leading to a denial of
    service.
  * CVE-2019-9513 “Resource Loop”: The attacker creates multiple request
    streams and continually shuffles the priority of the streams in a way
    that causes substantial churn to the priority tree. This can consume
    excess CPU, potentially leading to a denial of service.
  * CVE-2019-9514 “Reset Flood”: The attacker opens a number of streams
    and sends an invalid request over each stream that should solicit a
    stream of RST_STREAM frames from the peer. Depending on how the peer
    queues the RST_STREAM frames, this can consume excess memory, CPU,or
    both, potentially leading to a denial of service.
  * CVE-2019-9515 “Settings Flood”: The attacker sends a stream of
    SETTINGS frames to the peer. Since the RFC requires that the peer
    reply with one acknowledgement per SETTINGS frame, an empty SETTINGS
    frame is almost equivalent in behavior to a ping. Depending on how
    efficiently this data is queued, this can consume excess CPU, memory,
    or both, potentially leading to a denial of service.
  * CVE-2019-9516 “0-Length Headers Leak”: The attacker sends a stream of
    headers with a 0-length header name and 0-length header value,
    optionally Huffman encoded into 1-byte or greater headers. Some
    implementations allocate memory for these headers and keep the
    allocation alive until the session dies. This can consume excess
    memory, potentially leading to a denial of service.
  * CVE-2019-9517 “Internal Data Buffering”: The attacker opens the HTTP/2
    window so the peer can send without constraint; however, they leave
    the TCP window closed so the peer cannot actually write (many of) the
    bytes on the wire. The attacker then sends a stream of requests for a
    large response object. Depending on how the servers queue the
    responses, this can consume excess memory, CPU, or both, potentially
    leading to a denial of service.
  * CVE-2019-9518 “Empty Frames Flood”: The attacker sends a stream of
    frames with an empty payload and without the end-of-stream flag. These
    frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The
    peer spends time processing each frame disproportionate to attack
    bandwidth. This can consume excess CPU, potentially leading to a
    denial of service. (Discovered by Piotr Sikora of Google)

  PR-URL: https://github.com/nodejs/node/pull/29133
  4f10ac3623ce19e2e124f1fca51a678077b6ce04:http2: handle 0-length headers better

  Ignore headers with 0-length names and track memory for headers
  the way we track it for other HTTP/2 session memory too.

  This is intended to mitigate CVE-2019-9516.

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
  b4cfa521b8b0fbe5ee5815fcac3614cc0960f7d9:http2: handle 0-length headers better

  Ignore headers with 0-length names and track memory for headers
  the way we track it for other HTTP/2 session memory too.

  This is intended to mitigate CVE-2019-9516.

  PR-URL: https://github.com/nodejs/node/pull/29122
  Reviewed-By: Rich Trott <rtrott@gmail.com>
  Reviewed-By: James M Snell <jasnell@gmail.com>
impacted_packages:
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 75657ee41677d56a498e298b01d049aef5bf199f
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: f4242e24f9f4fb185909f040cbd2dd889d79439b
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 787378879acfb212ed4ff824bf9f767a24a5cb43
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 4f10ac3623ce19e2e124f1fca51a678077b6ce04
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: edc2e5be34abe45b6d2e0dbccecb1771ecf82286
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: b4cfa521b8b0fbe5ee5815fcac3614cc0960f7d9
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: affa23bc88849f962e6fd784852c3db242bfeb19
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 5744b466c45d5324c60f122b02681813d4496749
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 10f05b65c4c84c21e203271301dc5187253c66dc
    introduced_in_commits: []
  - purl: pkg:github/nodejs/node
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/nodejs/node
        commit: 004e2b759ffff2dff4b0d45c630e3305350b41df
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/nodejs/node/tree/004e2b759ffff2dff4b0d45c630e3305350b41df
    reference_type: commit
    reference_id: 004e2b759ffff2dff4b0d45c630e3305350b41df
  - url: https://github.com/nodejs/node/tree/10f05b65c4c84c21e203271301dc5187253c66dc
    reference_type: commit
    reference_id: 10f05b65c4c84c21e203271301dc5187253c66dc
  - url: https://github.com/nodejs/node/tree/4f10ac3623ce19e2e124f1fca51a678077b6ce04
    reference_type: commit
    reference_id: 4f10ac3623ce19e2e124f1fca51a678077b6ce04
  - url: https://github.com/nodejs/node/tree/5744b466c45d5324c60f122b02681813d4496749
    reference_type: commit
    reference_id: 5744b466c45d5324c60f122b02681813d4496749
  - url: https://github.com/nodejs/node/tree/75657ee41677d56a498e298b01d049aef5bf199f
    reference_type: commit
    reference_id: 75657ee41677d56a498e298b01d049aef5bf199f
  - url: https://github.com/nodejs/node/tree/787378879acfb212ed4ff824bf9f767a24a5cb43
    reference_type: commit
    reference_id: 787378879acfb212ed4ff824bf9f767a24a5cb43
  - url: https://github.com/nodejs/node/tree/affa23bc88849f962e6fd784852c3db242bfeb19
    reference_type: commit
    reference_id: affa23bc88849f962e6fd784852c3db242bfeb19
  - url: https://github.com/nodejs/node/tree/b4cfa521b8b0fbe5ee5815fcac3614cc0960f7d9
    reference_type: commit
    reference_id: b4cfa521b8b0fbe5ee5815fcac3614cc0960f7d9
  - url: https://github.com/nodejs/node/tree/edc2e5be34abe45b6d2e0dbccecb1771ecf82286
    reference_type: commit
    reference_id: edc2e5be34abe45b6d2e0dbccecb1771ecf82286
  - url: https://github.com/nodejs/node/tree/f4242e24f9f4fb185909f040cbd2dd889d79439b
    reference_type: commit
    reference_id: f4242e24f9f4fb185909f040cbd2dd889d79439b
