advisory_id: GHSA-qvc4-78gw-pv8p
datasource_id: github_osv_importer_v2/GHSA-qvc4-78gw-pv8p
datasource_url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2023/04/GHSA-qvc4-78gw-pv8p/GHSA-qvc4-78gw-pv8p.json
aliases: []
summary: |
  Adverserial use of `make_bitflags!` macro can cause undefined behavior
  The macro relied on an expression of the form `Enum::Variant` always being a
  variant of the enum. However, it may also be an associated integer constant, in
  which case there's no guarantee that the value of said constant consists only of
  bits valid for this bitflag type.

  Thus, code like this could create an invalid `BitFlags<Test>`, which would cause
  iterating over it to trigger undefined behavior. As the debug formatter
  internally iterates over the value, it is also affected.

  ```rust
  use enumflags2::{bitflags, make_bitflags};

  #[bitflags]
  #[repr(u8)]
  #[derive(Copy, Clone, Debug)]
  enum Test {
      A = 1,
      B = 2,
  }

  impl Test {
      const C: u8 = 69;
  }

  fn main() {
      let x = make_bitflags!(Test::{C});
      // printing or iterating over x is UB
  }
  ```
impacted_packages: []
severities:
  - score: MODERATE
    scoring_system: generic_textual
    scoring_elements:
    published_at: None
    url:
weaknesses: []
references:
  - url: https://github.com/meithecatte/enumflags2
    reference_type:
    reference_id:
  - url: https://github.com/meithecatte/enumflags2/releases/tag/v0.7.7
    reference_type:
    reference_id:
  - url: https://rustsec.org/advisories/RUSTSEC-2023-0035.html
    reference_type:
    reference_id:
