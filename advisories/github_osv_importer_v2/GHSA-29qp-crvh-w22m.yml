advisory_id: GHSA-29qp-crvh-w22m
datasource_id: github_osv_importer_v2/GHSA-29qp-crvh-w22m
datasource_url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2025/01/GHSA-29qp-crvh-w22m/GHSA-29qp-crvh-w22m.json
aliases: []
summary: |
  Withdrawn Advisory: github.com/hashicorp/yamux's DefaultConfig has dangerous defaults causing hung Read
  ## Withdrawn Advisory
  This advisory has been withdrawn because further research determined that `github.com/hashicorp/yamux` was not vulnerable to denial of service in the manner described. This link is maintained to preserve external references.

  ## Original Description
  The default values for Session.config.KeepAliveInterval and Session.config.ConnectionWriteTimeout of 30s and 10s create the possibility for timed out writes that most aren't handling in their readers.

  Calls to Stream.Read on one side of a connection will hang until the underlying Session is closed if the corresponding Stream.Write call on the other side it's waiting for returns with ErrConnectionWriteTimeout. This happens in the case of network congestion between the two sides.

  If you keep Session.sendCh full (fixed capacity of 64) for ConnectionWriteTimeout, but for less than the KeepAliveInterval + ConnectionWriteTimeout (which would kill the Session), Stream.Write will return ErrConnectionWriteTimeout. The state of the underlying Session or Stream is not modified. When this happens, the other side's Stream.Read call that's waiting for that write will never return because there's no timeout for this edge-case.

  Since no keep alive timed out, you can continue to use the Session once the network congestion is resolved, but that Stream.Read call will only return when the Session closes or the response shows up. Since the write call on the other side timed out the call to Stream.Read will never return.

  Any conditions that cause network writes to stall for 10-30 seconds can trigger this Denial of Service- extremely high CPU contention on either side of the connection, BGP reconvergence, etc. To resolve the Denial of Service issue, you have to re-establish the connections, which will usually require a hard restart of the service on either end of the connection.
impacted_packages: []
severities:
  - score: '6.6'
    scoring_system: cvssv4
    scoring_elements: CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:N/VI:N/VA:H/SC:N/SI:N/SA:N/E:U
    published_at: None
    url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2025/01/GHSA-29qp-crvh-w22m/GHSA-29qp-crvh-w22m.json
  - score: MODERATE
    scoring_system: generic_textual
    scoring_elements:
    published_at: None
    url:
weaknesses:
  - CWE-770
references:
  - url: https://github.com/golang/vulndb/issues/3408
    reference_type:
    reference_id:
  - url: https://github.com/golang/vulndb/issues/3453
    reference_type:
    reference_id:
  - url: https://github.com/hashicorp/yamux
    reference_type:
    reference_id:
  - url: https://github.com/hashicorp/yamux/issues/142
    reference_type:
    reference_id:
  - url: https://github.com/hashicorp/yamux/pull/143
    reference_type:
    reference_id:
