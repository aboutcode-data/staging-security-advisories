advisory_id: GHSA-w7fw-mjwx-w883
datasource_id: github_osv_importer_v2/GHSA-w7fw-mjwx-w883
datasource_url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2026/02/GHSA-w7fw-mjwx-w883/GHSA-w7fw-mjwx-w883.json
aliases:
  - CVE-2026-2391
summary: |
  qs's arrayLimit bypass in comma parsing allows denial of service
  ### Summary
  The `arrayLimit` option in qs does not enforce limits for comma-separated values when `comma: true` is enabled, allowing attackers to cause denial-of-service via memory exhaustion. This is a bypass of the array limit enforcement, similar to the bracket notation bypass addressed in GHSA-6rw7-vpxm-498p (CVE-2025-15284).

  ### Details
  When the `comma` option is set to `true` (not the default, but configurable in applications), qs allows parsing comma-separated strings as arrays (e.g., `?param=a,b,c` becomes `['a', 'b', 'c']`). However, the limit check for `arrayLimit` (default: 20) and the optional throwOnLimitExceeded occur after the comma-handling logic in `parseArrayValue`, enabling a bypass. This permits creation of arbitrarily large arrays from a single parameter, leading to excessive memory allocation.

  **Vulnerable code** (lib/parse.js: lines ~40-50):
  ```js
  if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
      return val.split(',');
  }

  if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
      throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
  }

  return val;
  ```
  The `split(',')` returns the array immediately, skipping the subsequent limit check. Downstream merging via `utils.combine` does not prevent allocation, even if it marks overflows for sparse arrays.This discrepancy allows attackers to send a single parameter with millions of commas (e.g., `?param=,,,,,,,,...`), allocating massive arrays in memory without triggering limits. It bypasses the intent of `arrayLimit`, which is enforced correctly for indexed (`a[0]=`) and bracket (`a[]=`) notations (the latter fixed in v6.14.1 per GHSA-6rw7-vpxm-498p).

  ### PoC
  **Test 1 - Basic bypass:**
  ```
  npm install qs
  ```

  ```js
  const qs = require('qs');

  const payload = 'a=' + ','.repeat(25);  // 26 elements after split (bypasses arrayLimit: 5)
  const options = { comma: true, arrayLimit: 5, throwOnLimitExceeded: true };

  try {
    const result = qs.parse(payload, options);
    console.log(result.a.length);  // Outputs: 26 (bypass successful)
  } catch (e) {
    console.log('Limit enforced:', e.message);  // Not thrown
  }
  ```
  **Configuration:**
  - `comma: true`
  - `arrayLimit: 5`
  - `throwOnLimitExceeded: true`

  Expected: Throws "Array limit exceeded" error.
  Actual: Parses successfully, creating an array of length 26.


  ### Impact
  Denial of Service (DoS) via memory exhaustion.

  ### Suggested Fix
  Move the `arrayLimit` check before the comma split in `parseArrayValue`, and enforce it on the resulting array length. Use `currentArrayLength` (already calculated upstream) for consistency with bracket notation fixes.

  **Current code** (lib/parse.js: lines ~40-50):
  ```js
  if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
      return val.split(',');
  }

  if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
      throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
  }

  return val;
  ```

  **Fixed code:**
  ```js
  if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
      const splitArray = val.split(',');
      if (splitArray.length > options.arrayLimit - currentArrayLength) {  // Check against remaining limit
          if (options.throwOnLimitExceeded) {
              throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
          } else {
              // Optionally convert to object or truncate, per README
              return splitArray.slice(0, options.arrayLimit - currentArrayLength);
          }
      }
      return splitArray;
  }

  if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
      throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
  }

  return val;
  ```
  This aligns behavior with indexed and bracket notations, reuses `currentArrayLength`, and respects `throwOnLimitExceeded`. Update README to note the consistent enforcement.
impacted_packages:
  - purl: pkg:npm/qs
    affected_versions: vers:npm/<=6.14.1
    fixed_versions: vers:npm/6.14.2
    fixed_in_commits: []
    introduced_in_commits: []
severities:
  - score: '3.7'
    scoring_system: cvssv3.1
    scoring_elements: CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L
    published_at: None
    url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2026/02/GHSA-w7fw-mjwx-w883/GHSA-w7fw-mjwx-w883.json
  - score: LOW
    scoring_system: generic_textual
    scoring_elements:
    published_at: None
    url:
weaknesses:
  - CWE-20
references:
  - url: https://github.com/ljharb/qs
    reference_type:
    reference_id:
  - url: https://github.com/ljharb/qs/commit/f6a7abff1f13d644db9b05fe4f2c98ada6bf8482
    reference_type:
    reference_id:
  - url: https://github.com/ljharb/qs/security/advisories/GHSA-w7fw-mjwx-w883
    reference_type:
    reference_id:
  - url: https://nvd.nist.gov/vuln/detail/CVE-2026-2391
    reference_type:
    reference_id:
