advisory_id: GHSA-c3m3-c39q-pv23
datasource_id: github_osv_importer_v2/GHSA-c3m3-c39q-pv23
datasource_url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2021/08/GHSA-c3m3-c39q-pv23/GHSA-c3m3-c39q-pv23.json
aliases:
  - CVE-2019-15543
summary: |
  Out of bounds write in slice-deque
  Affected versions of this crate entered a corrupted state if mem::size_of::<T>() % allocation_granularity() != 0 and a specific allocation pattern was used: sufficiently shifting the deque elements over the mirrored page boundary.

  This allows an attacker that controls controls both element insertion and removal to corrupt the deque, such that reading elements from it would read bytes corresponding to other elements in the deque. (e.g. a read of T could read some bytes from one value and some bytes from an adjacent one, resulting in a T whose value representation is not meaningful). This is undefined behavior.

  The flaw was corrected by using a pair of pointers to track the head and tail of the deque instead of a pair of indices. This pair of pointers are represented using a Rust slice.
impacted_packages: []
severities:
  - score: '9.8'
    scoring_system: cvssv3.1
    scoring_elements: CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
    published_at: None
    url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2021/08/GHSA-c3m3-c39q-pv23/GHSA-c3m3-c39q-pv23.json
  - score: CRITICAL
    scoring_system: generic_textual
    scoring_elements:
    published_at: None
    url:
weaknesses:
  - CWE-787
references:
  - url: https://github.com/gnzlbg/slice_deque
    reference_type:
    reference_id:
  - url: https://github.com/gnzlbg/slice_deque/issues/57
    reference_type:
    reference_id:
  - url: https://rustsec.org/advisories/RUSTSEC-2019-0002.html
    reference_type:
    reference_id:
  - url: https://nvd.nist.gov/vuln/detail/CVE-2019-15543
    reference_type:
    reference_id: CVE-2019-15543
