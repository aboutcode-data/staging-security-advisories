advisory_id: linux/CVE-2025-38349
datasource_id: debian_importer_v2/linux/CVE-2025-38349
datasource_url: https://security-tracker.debian.org/tracker/CVE-2025-38349
aliases:
  - CVE-2025-38349
summary: "In the Linux kernel, the following vulnerability has been resolved:  eventpoll: don't\
  \ decrement ep refcount while still holding the ep mutex  Jann Horn points out that epoll\
  \ is decrementing the ep refcount and then doing a      mutex_unlock(&ep->mtx);  afterwards.\
  \ That's very wrong, because it can lead to a use-after-free.  That pattern is actually fine\
  \ for the very last reference, because the code in question will delay the actual call to\
  \ \"ep_free(ep)\" until after it has unlocked the mutex.  But it's wrong for the much subtler\
  \ \"next to last\" case when somebody *else* may also be dropping their reference and free\
  \ the ep while we're still using the mutex.  Note that this is true even if that other user\
  \ is also using the same ep mutex: mutexes, unlike spinlocks, can not be used for object ownership,\
  \ even if they guarantee mutual exclusion.  A mutex \"unlock\" operation is not atomic, and\
  \ as one user is still accessing the mutex as part of unlocking it, another user can come\
  \ in and get the now released mutex and free the data structure while the first user is still\
  \ cleaning up.  See our mutex documentation in Documentation/locking/mutex-design.rst, in\
  \ particular the section [1] about semantics:  \t\"mutex_unlock() may access the mutex structure\
  \ even after it has \t internally released the lock already - so it's not safe for \t another\
  \ context to acquire the mutex and assume that the \t mutex_unlock() context is not using\
  \ the structure anymore\"  So if we drop our ep ref before the mutex unlock, but we weren't\
  \ the last one, we may then unlock the mutex, another user comes in, drops _their_ reference\
  \ and releases the 'ep' as it now has no users - all while the mutex_unlock() is still accessing\
  \ it.  Fix this by simply moving the ep refcount dropping to outside the mutex: the refcount\
  \ itself is atomic, and doesn't need mutex protection (that's the whole _point_ of refcounts:\
  \ unlike mutexes, they are inherently about object lifetimes)."
impacted_packages:
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.1.159-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/0
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/5.10.223-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.12-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.16.3-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.12.63-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.12.41-1
    fixed_in_commits: []
    introduced_in_commits: []
severities: []
weaknesses: []
references: []
