advisory_id: linux/CVE-2025-71089
datasource_id: debian_importer_v2/linux/CVE-2025-71089
datasource_url: https://security-tracker.debian.org/tracker/CVE-2025-71089
aliases:
  - CVE-2025-71089
summary: 'In the Linux kernel, the following vulnerability has been resolved:  iommu: disable
  SVA when CONFIG_X86 is set  Patch series "Fix stale IOTLB entries for kernel address space",
  v7.  This proposes a fix for a security vulnerability related to IOMMU Shared Virtual Addressing
  (SVA).  In an SVA context, an IOMMU can cache kernel page table entries.  When a kernel page
  table page is freed and reallocated for another purpose, the IOMMU might still hold stale,
  incorrect entries.  This can be exploited to cause a use-after-free or write-after-free condition,
  potentially leading to privilege escalation or data corruption.  This solution introduces
  a deferred freeing mechanism for kernel page table pages, which provides a safe window to
  notify the IOMMU to invalidate its caches before the page is reused.   This patch (of 8):  In
  the IOMMU Shared Virtual Addressing (SVA) context, the IOMMU hardware shares and walks the
  CPU''s page tables.  The x86 architecture maps the kernel''s virtual address space into the
  upper portion of every process''s page table.  Consequently, in an SVA context, the IOMMU
  hardware can walk and cache kernel page table entries.  The Linux kernel currently lacks a
  notification mechanism for kernel page table changes, specifically when page table pages are
  freed and reused.  The IOMMU driver is only notified of changes to user virtual address mappings.  This
  can cause the IOMMU''s internal caches to retain stale entries for kernel VA.  Use-After-Free
  (UAF) and Write-After-Free (WAF) conditions arise when kernel page table pages are freed and
  later reallocated.  The IOMMU could misinterpret the new data as valid page table entries.  The
  IOMMU might then walk into attacker-controlled memory, leading to arbitrary physical memory
  DMA access or privilege escalation.  This is also a Write-After-Free issue, as the IOMMU will
  potentially continue to write Accessed and Dirty bits to the freed memory while attempting
  to walk the stale page tables.  Currently, SVA contexts are unprivileged and cannot access
  kernel mappings.  However, the IOMMU will still walk kernel-only page tables all the way down
  to the leaf entries, where it realizes the mapping is for the kernel and errors out.  This
  means the IOMMU still caches these intermediate page table entries, making the described vulnerability
  a real concern.  Disable SVA on x86 architecture until the IOMMU can receive notification
  to flush the paging cache before freeing the CPU kernel page table pages.'
impacted_packages:
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions: vers:deb/5.10.223-1|6.1.159-1
    fixed_versions: vers:deb/6.18.12-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions: vers:deb/5.10.223-1|6.1.159-1
    fixed_versions: vers:deb/6.18.5-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions: vers:deb/5.10.223-1|6.1.159-1
    fixed_versions: vers:deb/6.18.13-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions: vers:deb/5.10.223-1|6.1.159-1
    fixed_versions: vers:deb/6.12.63-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions: vers:deb/5.10.223-1|6.1.159-1
    fixed_versions: vers:deb/6.12.69-1
    fixed_in_commits: []
    introduced_in_commits: []
severities: []
weaknesses: []
references: []
