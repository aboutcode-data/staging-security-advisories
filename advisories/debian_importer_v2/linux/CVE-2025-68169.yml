advisory_id: linux/CVE-2025-68169
datasource_id: debian_importer_v2/linux/CVE-2025-68169
datasource_url: https://security-tracker.debian.org/tracker/CVE-2025-68169
aliases:
  - CVE-2025-68169
summary: 'In the Linux kernel, the following vulnerability has been resolved:  netpoll: Fix
  deadlock in memory allocation under spinlock  Fix a AA deadlock in refill_skbs() where memory
  allocation while holding skb_pool->lock can trigger a recursive lock acquisition attempt.  The
  deadlock scenario occurs when the system is under severe memory pressure:  1. refill_skbs()
  acquires skb_pool->lock (spinlock) 2. alloc_skb() is called while holding the lock 3. Memory
  allocator fails and calls slab_out_of_memory() 4. This triggers printk() for the OOM warning
  5. The console output path calls netpoll_send_udp() 6. netpoll_send_udp() attempts to acquire
  the same skb_pool->lock 7. Deadlock: the lock is already held by the same CPU  Call stack:   refill_skbs()     spin_lock_irqsave(&skb_pool->lock)    <-
  lock acquired     __alloc_skb()       kmem_cache_alloc_node_noprof()         slab_out_of_memory()           printk()             console_flush_all()               netpoll_send_udp()                 skb_dequeue()                   spin_lock_irqsave(&skb_pool->lock)     <-
  deadlock attempt  This bug was exposed by commit 248f6571fd4c51 ("netpoll: Optimize skb refilling
  on critical path") which removed refill_skbs() from the critical path (where nested printk
  was being deferred), letting nested printk being called from inside refill_skbs()  Refactor
  refill_skbs() to never allocate memory while holding the spinlock.  Another possible solution
  to fix this problem is protecting the refill_skbs() from nested printks, basically calling
  printk_deferred_{enter,exit}() in refill_skbs(), then, any nested pr_warn() would be deferred.  I
  prefer this approach, given I _think_ it might be a good idea to move the alloc_skb() from
  GFP_ATOMIC to GFP_KERNEL in the future, so, having the alloc_skb() outside of the lock will
  be necessary step.  There is a possible TOCTOU issue when checking for the pool length, and
  queueing the new allocated skb, but, this is not an issue, given that an extra SKB in the
  pool is harmless and it will be eventually used.'
impacted_packages:
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.1.159-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/0
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/5.10.223-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.12-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.17.8-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.13-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.12.63-1
    fixed_in_commits: []
    introduced_in_commits: []
severities: []
weaknesses: []
references: []
