advisory_id: linux/CVE-2026-23114
datasource_id: debian_importer_v2/linux/CVE-2026-23114
datasource_url: https://security-tracker.debian.org/tracker/CVE-2026-23114
aliases:
  - CVE-2026-23114
summary: 'In the Linux kernel, the following vulnerability has been resolved:  arm64/fpsimd:
  ptrace: Fix SVE writes on !SME systems  When SVE is supported but SME is not supported, a
  ptrace write to the NT_ARM_SVE regset can place the tracee into an invalid state where (non-streaming)
  SVE register data is stored in FP_STATE_SVE format but TIF_SVE is clear. This can result in
  a later warning from fpsimd_restore_current_state(), e.g.    WARNING: CPU: 0 PID: 7214 at
  arch/arm64/kernel/fpsimd.c:383 fpsimd_restore_current_state+0x50c/0x748  When this happens,
  fpsimd_restore_current_state() will set TIF_SVE, placing the task into the correct state.
  This occurs before any other check of TIF_SVE can possibly occur, as other checks of TIF_SVE
  only happen while the FPSIMD/SVE/SME state is live. Thus, aside from the warning, there is
  no functional issue.  This bug was introduced during rework to error handling in commit:    9f8bf718f2923
  ("arm64/fpsimd: ptrace: Gracefully handle errors")  ... where the setting of TIF_SVE was moved
  into a block which is only executed when system_supports_sme() is true.  Fix this by removing
  the system_supports_sme() check. This ensures that TIF_SVE is set for (SVE-formatted) writes
  to NT_ARM_SVE, at the cost of unconditionally manipulating the tracee''s saved svcr value.
  The manipulation of svcr is benign and inexpensive, and we already do similar elsewhere (e.g.
  during signal handling), so I don''t think it''s worth guarding this with system_supports_sme()
  checks.  Aside from the above, there is no functional change. The ''type'' argument to sve_set_common()
  is only set to ARM64_VEC_SME (in ssve_set())) when system_supports_sme(), so the ARM64_VEC_SME
  case in the switch statement is still unreachable when !system_supports_sme(). When CONFIG_ARM64_SME=n,
  the only caller of sve_set_common() is sve_set(), and the compiler can constant-fold for the
  case where type is ARM64_VEC_SVE, removing the logic for other cases.'
impacted_packages:
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.1.159-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/0
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/5.10.223-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.12-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.8-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.12.63-1
    fixed_in_commits: []
    introduced_in_commits: []
severities: []
weaknesses: []
references: []
