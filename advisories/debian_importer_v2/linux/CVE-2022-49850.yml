advisory_id: linux/CVE-2022-49850
datasource_id: debian_importer_v2/linux/CVE-2022-49850
datasource_url: https://security-tracker.debian.org/tracker/CVE-2022-49850
aliases:
  - CVE-2022-49850
summary: 'In the Linux kernel, the following vulnerability has been resolved:  nilfs2: fix deadlock
  in nilfs_count_free_blocks()  A semaphore deadlock can occur if nilfs_get_block() detects
  metadata corruption while locating data blocks and a superblock writeback occurs at the same
  time:  task 1                               task 2 ------                               ------
  * A file operation * nilfs_truncate()   nilfs_get_block()     down_read(rwsem A) <--     nilfs_bmap_lookup_contig()       ...                            generic_shutdown_super()                                        nilfs_put_super()                                          *
  Prepare to write superblock *                                          down_write(rwsem B)
  <--                                          nilfs_cleanup_super()       * Detect b-tree corruption
  *         nilfs_set_log_cursor()       nilfs_bmap_convert_error()             nilfs_count_free_blocks()         __nilfs_error()                        down_read(rwsem
  A) <--           nilfs_set_error()             down_write(rwsem B) <--                             ***
  DEADLOCK ***  Here, nilfs_get_block() readlocks rwsem A (= NILFS_MDT(dat_inode)->mi_sem) and
  then calls nilfs_bmap_lookup_contig(), but if it fails due to metadata corruption, __nilfs_error()
  is called from nilfs_bmap_convert_error() inside the lock section.  Since __nilfs_error()
  calls nilfs_set_error() unless the filesystem is read-only and nilfs_set_error() attempts
  to writelock rwsem B (= nilfs->ns_sem) to write back superblock exclusively, hierarchical
  lock acquisition occurs in the order rwsem A -> rwsem B.  Now, if another task starts updating
  the superblock, it may writelock rwsem B during the lock sequence above, and can deadlock
  trying to readlock rwsem A in nilfs_count_free_blocks().  However, there is actually no need
  to take rwsem A in nilfs_count_free_blocks() because it, within the lock section, only reads
  a single integer data on a shared struct with nilfs_sufile_get_ncleansegs().  This has been
  the case after commit aa474a220180 ("nilfs2: add local variable to cache the number of clean
  segments"), that is, even before this bug was introduced.  So, this resolves the deadlock
  problem by just not taking the semaphore in nilfs_count_free_blocks().'
impacted_packages:
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.1.159-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.0.10-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/5.10.223-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/5.10.158-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.12-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.15-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.12.63-1
    fixed_in_commits: []
    introduced_in_commits: []
severities: []
weaknesses: []
references: []
