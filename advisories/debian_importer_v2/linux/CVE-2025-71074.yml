advisory_id: linux/CVE-2025-71074
datasource_id: debian_importer_v2/linux/CVE-2025-71074
datasource_url: https://security-tracker.debian.org/tracker/CVE-2025-71074
aliases:
  - CVE-2025-71074
summary: "In the Linux kernel, the following vulnerability has been resolved:  functionfs: fix\
  \ the open/removal races  ffs_epfile_open() can race with removal, ending up with file->private_data\
  \ pointing to freed object.  There is a total count of opened files on functionfs (both ep0\
  \ and dynamic ones) and when it hits zero, dynamic files get removed. Unfortunately, that\
  \ removal can happen while another thread is in ffs_epfile_open(), but has not incremented\
  \ the count yet. In that case open will succeed, leaving us with UAF on any subsequent read()\
  \ or write().  The root cause is that ffs->opened is misused; atomic_dec_and_test() vs. atomic_add_return()\
  \ is not a good idea, when object remains visible all along.  To untangle that \t* serialize\
  \ openers on ffs->mutex (both for ep0 and for dynamic files) \t* have dynamic ones use atomic_inc_not_zero()\
  \ and fail if we had zero ->opened; in that case the file we are opening is doomed. \t* have\
  \ the inodes of dynamic files marked on removal (from the callback of simple_recursive_removal())\
  \ - clear ->i_private there. \t* have open of dynamic ones verify they hadn't been already\
  \ removed, along with checking that state is FFS_ACTIVE."
impacted_packages: []
severities: []
weaknesses: []
references: []
