advisory_id: linux/CVE-2026-23016
datasource_id: debian_importer_v2/linux/CVE-2026-23016
datasource_url: https://security-tracker.debian.org/tracker/CVE-2026-23016
aliases:
  - CVE-2026-23016
summary: 'In the Linux kernel, the following vulnerability has been resolved:  inet: frags:
  drop fraglist conntrack references  Jakub added a warning in nf_conntrack_cleanup_net_list()
  to make debugging leaked skbs/conntrack references more obvious.  syzbot reports this as triggering,
  and I can also reproduce this via ip_defrag.sh selftest:   conntrack cleanup blocked for 60s  WARNING:
  net/netfilter/nf_conntrack_core.c:2512  [..]  conntrack clenups gets stuck because there are
  skbs with still hold nf_conn references via their frag_list.     net.core.skb_defer_max=0
  makes the hang disappear.  Eric Dumazet points out that skb_release_head_state() doesn''t
  follow the fraglist.  ip_defrag.sh can only reproduce this problem since commit 6471658dc66c
  ("udp: use skb_attempt_defer_free()"), but AFAICS this problem could happen with TCP as well
  if pmtu discovery is off.  The relevant problem path for udp is: 1. netns emits fragmented
  packets 2. nf_defrag_v6_hook reassembles them (in output hook) 3. reassembled skb is tracked
  (skb owns nf_conn reference) 4. ip6_output refragments 5. refragmented packets also own nf_conn
  reference (ip6_fragment    calls ip6_copy_metadata()) 6. on input path, nf_defrag_v6_hook
  skips defragmentation: the    fragments already have skb->nf_conn attached 7. skbs are reassembled
  via ipv6_frag_rcv() 8. skb_consume_udp -> skb_attempt_defer_free() -> skb ends up    in pcpu
  freelist, but still has nf_conn reference.  Possible solutions:  1 let defrag engine drop
  nf_conn entry, OR  2 export kick_defer_list_purge() and call it from the conntrack    netns
  exit callback, OR  3 add skb_has_frag_list() check to skb_attempt_defer_free()  2 & 3 also
  solve ip_defrag.sh hang but share same drawback:  Such reassembled skbs, queued to socket,
  can prevent conntrack module removal until userspace has consumed the packet. While both tcp
  and udp stack do call nf_reset_ct() before placing skb on socket queue, that function doesn''t
  iterate frag_list skbs.  Therefore drop nf_conn entries when they are placed in defrag queue.
  Keep the nf_conn entry of the first (offset 0) skb so that reassembled skb retains nf_conn
  entry for sake of TX path.  Note that fixes tag is incorrect; it points to the commit introducing
  the ''ip_defrag.sh reproducible problem'': no need to backport this patch to every stable
  kernel.'
impacted_packages:
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.1.159-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/0
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/5.10.223-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.12-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.8-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.13-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.12.63-1
    fixed_in_commits: []
    introduced_in_commits: []
severities: []
weaknesses: []
references: []
