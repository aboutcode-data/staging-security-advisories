advisory_id: linux/CVE-2023-54180
datasource_id: debian_importer_v2/linux/CVE-2023-54180
datasource_url: https://security-tracker.debian.org/tracker/CVE-2023-54180
aliases:
  - CVE-2023-54180
summary: "In the Linux kernel, the following vulnerability has been resolved:  btrfs: handle\
  \ case when repair happens with dev-replace  [BUG] There is a bug report that a BUG_ON() in\
  \ btrfs_repair_io_failure() (originally repair_io_failure() in v6.0 kernel) got triggered\
  \ when replacing a unreliable disk:    BTRFS warning (device sda1): csum failed root 257 ino\
  \ 2397453 off 39624704 csum 0xb0d18c75 expected csum 0x4dae9c5e mirror 3   kernel BUG at fs/btrfs/extent_io.c:2380!\
  \   invalid opcode: 0000 [#1] PREEMPT SMP NOPTI   CPU: 9 PID: 3614331 Comm: kworker/u257:2\
  \ Tainted: G           OE      6.0.0-5-amd64 #1  Debian 6.0.10-2   Hardware name: Micro-Star\
  \ International Co., Ltd. MS-7C60/TRX40 PRO WIFI (MS-7C60), BIOS 2.70 07/01/2021   Workqueue:\
  \ btrfs-endio btrfs_end_bio_work [btrfs]   RIP: 0010:repair_io_failure+0x24a/0x260 [btrfs]\
  \   Call Trace:    <TASK>    clean_io_failure+0x14d/0x180 [btrfs]    end_bio_extent_readpage+0x412/0x6e0\
  \ [btrfs]    ? __switch_to+0x106/0x420    process_one_work+0x1c7/0x380    worker_thread+0x4d/0x380\
  \    ? rescuer_thread+0x3a0/0x3a0    kthread+0xe9/0x110    ? kthread_complete_and_exit+0x20/0x20\
  \    ret_from_fork+0x22/0x30  [CAUSE]  Before the BUG_ON(), we got some read errors from the\
  \ replace target first, note the mirror number (3, which is beyond RAID1 duplication, thus\
  \ it's read from the replace target device).  Then at the BUG_ON() location, we are trying\
  \ to writeback the repaired sectors back the failed device.  The check looks like this:  \t\
  \tret = btrfs_map_block(fs_info, BTRFS_MAP_WRITE, logical, \t\t\t\t      &map_length, &bioc,\
  \ mirror_num); \t\tif (ret) \t\t\tgoto out_counter_dec; \t\tBUG_ON(mirror_num != bioc->mirror_num);\
  \  But inside btrfs_map_block(), we can modify bioc->mirror_num especially for dev-replace:\
  \  \tif (dev_replace_is_ongoing && mirror_num == map->num_stripes + 1 && \t    !need_full_stripe(op)\
  \ && dev_replace->tgtdev != NULL) { \t\tret = get_extra_mirror_from_replace(fs_info, logical,\
  \ *length, \t\t\t\t\t\t    dev_replace->srcdev->devid, \t\t\t\t\t\t    &mirror_num, \t\t\t\
  \t\t    &physical_to_patch_in_first_stripe); \t\tpatch_the_first_stripe_for_dev_replace =\
  \ 1; \t}  Thus if we're repairing the replace target device, we're going to trigger that BUG_ON().\
  \  But in reality, the read failure from the replace target device may be that, our replace\
  \ hasn't reached the range we're reading, thus we're reading garbage, but with replace running,\
  \ the range would be properly filled later.  Thus in that case, we don't need to do anything\
  \ but let the replace routine to handle it.  [FIX] Instead of a BUG_ON(), just skip the repair\
  \ if we're repairing the device replace target device."
impacted_packages:
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions: vers:deb/5.10.223-1
    fixed_versions: vers:deb/6.1.159-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions: vers:deb/5.10.223-1
    fixed_versions: vers:deb/6.1.7-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions: vers:deb/5.10.223-1
    fixed_versions: vers:deb/6.18.12-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions: vers:deb/5.10.223-1
    fixed_versions: vers:deb/6.12.63-1
    fixed_in_commits: []
    introduced_in_commits: []
severities: []
weaknesses: []
references: []
