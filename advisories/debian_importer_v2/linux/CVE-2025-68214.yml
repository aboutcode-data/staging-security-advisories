advisory_id: linux/CVE-2025-68214
datasource_id: debian_importer_v2/linux/CVE-2025-68214
datasource_url: https://security-tracker.debian.org/tracker/CVE-2025-68214
aliases:
  - CVE-2025-68214
summary: "In the Linux kernel, the following vulnerability has been resolved:  timers: Fix NULL\
  \ function pointer race in timer_shutdown_sync()  There is a race condition between timer_shutdown_sync()\
  \ and timer expiration that can lead to hitting a WARN_ON in expire_timers().  The issue occurs\
  \ when timer_shutdown_sync() clears the timer function to NULL while the timer is still running\
  \ on another CPU. The race scenario looks like this:  CPU0\t\t\t\t\tCPU1 \t\t\t\t\t<SOFTIRQ>\
  \ \t\t\t\t\tlock_timer_base() \t\t\t\t\texpire_timers() \t\t\t\t\tbase->running_timer = timer;\
  \ \t\t\t\t\tunlock_timer_base() \t\t\t\t\t[call_timer_fn enter] \t\t\t\t\tmod_timer() \t\t\
  \t\t\t... timer_shutdown_sync() lock_timer_base() // For now, will not detach the timer but\
  \ only clear its function to NULL if (base->running_timer != timer) \tret = detach_if_pending(timer,\
  \ base, true); if (shutdown) \ttimer->function = NULL; unlock_timer_base() \t\t\t\t\t[call_timer_fn\
  \ exit] \t\t\t\t\tlock_timer_base() \t\t\t\t\tbase->running_timer = NULL; \t\t\t\t\tunlock_timer_base()\
  \ \t\t\t\t\t... \t\t\t\t\t// Now timer is pending while its function set to NULL. \t\t\t\t\
  \t// next timer trigger \t\t\t\t\t<SOFTIRQ> \t\t\t\t\texpire_timers() \t\t\t\t\tWARN_ON_ONCE(!fn)\
  \ // hit \t\t\t\t\t... lock_timer_base() // Now timer will detach if (base->running_timer\
  \ != timer) \tret = detach_if_pending(timer, base, true); if (shutdown) \ttimer->function\
  \ = NULL; unlock_timer_base()  The problem is that timer_shutdown_sync() clears the timer\
  \ function regardless of whether the timer is currently running. This can leave a pending\
  \ timer with a NULL function pointer, which triggers the WARN_ON_ONCE(!fn) check in expire_timers().\
  \  Fix this by only clearing the timer function when actually detaching the timer. If the\
  \ timer is running, leave the function pointer intact, which is safe because the timer will\
  \ be properly detached when it finishes running."
impacted_packages:
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.1.159-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/5.10.223-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/0
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.12-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.17.10-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.18.13-1
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/linux?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/6.12.63-1
    fixed_in_commits: []
    introduced_in_commits: []
severities: []
weaknesses: []
references: []
