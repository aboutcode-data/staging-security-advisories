advisory_id: rust-wasmtime/CVE-2026-27195
datasource_id: debian_importer_v2/rust-wasmtime/CVE-2026-27195
datasource_url: https://security-tracker.debian.org/tracker/CVE-2026-27195
aliases:
  - CVE-2026-27195
summary: 'Wasmtime is a runtime for WebAssembly. Starting with Wasmtime 39.0.0, the `component-model-async`
  feature became the default, which brought with it a new implementation of `[Typed]Func::call_async`
  which made it capable of calling async-typed guest export functions.  However, that implementation
  had a bug leading to a panic under certain circumstances: First, the host embedding calls
  `[Typed]Func::call_async` on a function exported by a component, polling the returned `Future`
  once. Second, the component function yields control to the async runtime (e.g. Tokio), e.g.
  due to a call to host function registered using `LinkerInstance::func_wrap_async` which yields,
  or due an epoch interruption. Third, the host embedding drops the `Future` after polling it
  once.  This leaves the component instance in a non-reenterable state since the call never
  had a chance to complete. Fourth, the host embedding calls `[Typed]Func::call_async` again,
  polling the returned `Future`.  Since the component instance cannot be entered at this point,
  the call traps, but not before allocating a task and thread for the call. Fifth, the host
  embedding ignores the trap and drops the `Future`.  This panics due to the runtime attempting
  to dispose of the task created above, which panics since the thread has not yet exited. When
  a host embedder using the affected versions of Wasmtime calls `wasmtime::component::[Typed]Func::call_async`
  on a guest export and then drops the returned future without waiting for it to resolve, and
  then does so again with the same component instance, Wasmtime will panic. Embeddings that
  have the `component-model-async` compile-time feature disabled are unaffected. Wasmtime 40.0.4
  and 41.0.4 have been patched to fix this issue. Versions 42.0.0 and later are not affected.
  If an embedding is not actually using any component-model-async features then disabling the
  `component-model-async` Cargo feature can work around this issue. This issue can also be worked
  around by either ensuring every `call_async` future is awaited until it completes or refraining
  from using the `Store` again after dropping a not-yet-resolved `call_async` future.'
impacted_packages:
  - purl: pkg:deb/debian/rust-wasmtime?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/29.0.1+dfsg-8
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/rust-wasmtime?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/0
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/rust-wasmtime?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/36.0.5+dfsg-4
    fixed_in_commits: []
    introduced_in_commits: []
  - purl: pkg:deb/debian/rust-wasmtime?distro=trixie
    affected_versions:
    fixed_versions: vers:deb/26.0.1+dfsg-3
    fixed_in_commits: []
    introduced_in_commits: []
severities: []
weaknesses: []
references: []
