advisory_id: linux-6.1/CVE-2026-23074
datasource_id: debian_importer_v2/linux-6.1/CVE-2026-23074
datasource_url: https://security-tracker.debian.org/tracker/CVE-2026-23074
aliases:
  - CVE-2026-23074
summary: 'In the Linux kernel, the following vulnerability has been resolved:  net/sched: Enforce
  that teql can only be used as root qdisc  Design intent of teql is that it is only supposed
  to be used as root qdisc. We need to check for that constraint.  Although not important, I
  will describe the scenario that unearthed this issue for the curious.  GangMin Kim <km.kim1503@gmail.com>
  managed to concot a scenario as follows:  ROOT qdisc 1:0 (QFQ)   ├── class 1:1 (weight=15,
  lmax=16384) netem with delay 6.4s   └── class 1:2 (weight=1, lmax=1514) teql  GangMin sends
  a packet which is enqueued to 1:1 (netem). Any invocation of dequeue by QFQ from this class
  will not return a packet until after 6.4s. In the meantime, a second packet is sent and it
  lands on 1:2. teql''s enqueue will return success and this will activate class 1:2. Main issue
  is that teql only updates the parent visible qlen (sch->q.qlen) at dequeue. Since QFQ will
  only call dequeue if peek succeeds (and teql''s peek always returns NULL), dequeue will never
  be called and thus the qlen will remain as 0. With that in mind, when GangMin updates 1:2''s
  lmax value, the qfq_change_class calls qfq_deact_rm_from_agg. Since the child qdisc''s qlen
  was not incremented, qfq fails to deactivate the class, but still frees its pointers from
  the aggregate. So when the first packet is rescheduled after 6.4 seconds (netem''s delay),
  a dangling pointer is accessed causing GangMin''s causing a UAF.'
impacted_packages: []
severities: []
weaknesses: []
references: []
