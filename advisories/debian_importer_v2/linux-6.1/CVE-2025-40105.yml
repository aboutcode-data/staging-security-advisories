advisory_id: linux-6.1/CVE-2025-40105
datasource_id: debian_importer_v2/linux-6.1/CVE-2025-40105
datasource_url: https://security-tracker.debian.org/tracker/CVE-2025-40105
aliases:
  - CVE-2025-40105
summary: 'In the Linux kernel, the following vulnerability has been resolved:  vfs: Don''t leak
  disconnected dentries on umount  When user calls open_by_handle_at() on some inode that is
  not cached, we will create disconnected dentry for it. If such dentry is a directory, exportfs_decode_fh_raw()
  will then try to connect this dentry to the dentry tree through reconnect_path(). It may happen
  for various reasons (such as corrupted fs or race with rename) that the call to lookup_one_unlocked()
  in reconnect_one() will fail to find the dentry we are trying to reconnect and instead create
  a new dentry under the parent. Now this dentry will not be marked as disconnected although
  the parent still may well be disconnected (at least in case this inconsistency happened because
  the fs is corrupted and .. doesn''t point to the real parent directory). This creates inconsistency
  in disconnected flags but AFAICS it was mostly harmless. At least until commit f1ee616214cb
  ("VFS: don''t keep disconnected dentries on d_anon") which removed adding of most disconnected
  dentries to sb->s_anon list. Thus after this commit cleanup of disconnected dentries implicitely
  relies on the fact that dput() will immediately reclaim such dentries. However when some leaf
  dentry isn''t marked as disconnected, as in the scenario described above, the reclaim doesn''t
  happen and the dentries are "leaked". Memory reclaim can eventually reclaim them but otherwise
  they stay in memory and if umount comes first, we hit infamous "Busy inodes after unmount"
  bug. Make sure all dentries created under a disconnected parent are marked as disconnected
  as well.'
impacted_packages: []
severities: []
weaknesses: []
references: []
