advisory_id: linux-6.1/CVE-2025-38681
datasource_id: debian_importer_v2/linux-6.1/CVE-2025-38681
datasource_url: https://security-tracker.debian.org/tracker/CVE-2025-38681
aliases:
  - CVE-2025-38681
summary: 'In the Linux kernel, the following vulnerability has been resolved:  mm/ptdump: take
  the memory hotplug lock inside ptdump_walk_pgd()  Memory hot remove unmaps and tears down
  various kernel page table regions as required.  The ptdump code can race with concurrent modifications
  of the kernel page tables.  When leaf entries are modified concurrently, the dump code may
  log stale or inconsistent information for a VA range, but this is otherwise not harmful.  But
  when intermediate levels of kernel page table are freed, the dump code will continue to use
  memory that has been freed and potentially reallocated for another purpose.  In such cases,
  the ptdump code may dereference bogus addresses, leading to a number of potential problems.  To
  avoid the above mentioned race condition, platforms such as arm64, riscv and s390 take memory
  hotplug lock, while dumping kernel page table via the sysfs interface /sys/kernel/debug/kernel_page_tables.  Similar
  race condition exists while checking for pages that might have been marked W+X via /sys/kernel/debug/kernel_page_tables/check_wx_pages
  which in turn calls ptdump_check_wx().  Instead of solving this race condition again, let''s
  just move the memory hotplug lock inside generic ptdump_check_wx() which will benefit both
  the scenarios.  Drop get_online_mems() and put_online_mems() combination from all existing
  platform ptdump code paths.'
impacted_packages: []
severities: []
weaknesses: []
references: []
