advisory_id: linux-6.1/CVE-2025-68194
datasource_id: debian_importer_v2/linux-6.1/CVE-2025-68194
datasource_url: https://security-tracker.debian.org/tracker/CVE-2025-68194
aliases:
  - CVE-2025-68194
summary: 'In the Linux kernel, the following vulnerability has been resolved:  media: imon:
  make send_packet() more robust  syzbot is reporting that imon has three problems which result
  in hung tasks due to forever holding device lock [1].  First problem is that when usb_rx_callback_intf0()
  once got -EPROTO error after ictx->dev_present_intf0 became true, usb_rx_callback_intf0()
  resubmits urb after printk(), and resubmitted urb causes usb_rx_callback_intf0() to again
  get -EPROTO error. This results in printk() flooding (RCU stalls).  Alan Stern commented [2]
  that    In theory it''s okay to resubmit _if_ the driver has a robust   error-recovery scheme
  (such as giving up after some fixed limit on the   number of errors or after some fixed time
  has elapsed, perhaps with a   time delay to prevent a flood of errors).  Most drivers don''t
  bother to   do this; they simply give up right away.  This makes them more   vulnerable to
  short-term noise interference during USB transfers, but in   reality such interference is
  quite rare.  There''s nothing really wrong   with giving up right away.  but imon has a poor
  error-recovery scheme which just retries forever; this behavior should be fixed.  Since I''m
  not sure whether it is safe for imon users to give up upon any error code, this patch takes
  care of only union of error codes chosen from modules in drivers/media/rc/ directory which
  handle -EPROTO error (i.e. ir_toy, mceusb and igorplugusb).  Second problem is that when usb_rx_callback_intf0()
  once got -EPROTO error before ictx->dev_present_intf0 becomes true, usb_rx_callback_intf0()
  always resubmits urb due to commit 8791d63af0cf ("[media] imon: don''t wedge hardware after
  early callbacks"). Move the ictx->dev_present_intf0 test introduced by commit 6f6b90c9231a
  ("[media] imon: don''t parse scancodes until intf configured") to immediately before imon_incoming_packet(),
  or the first problem explained above happens without printk() flooding (i.e. hung task).  Third
  problem is that when usb_rx_callback_intf0() is not called for some reason (e.g. flaky hardware;
  the reproducer for this problem sometimes prevents usb_rx_callback_intf0() from being called),
  wait_for_completion_interruptible() in send_packet() never returns (i.e. hung task). As a
  workaround for such situation, change send_packet() to wait for completion with timeout of
  10 seconds.'
impacted_packages: []
severities: []
weaknesses: []
references: []
