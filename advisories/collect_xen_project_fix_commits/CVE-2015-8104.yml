advisory_id: CVE-2015-8104
datasource_id: collect_xen_project_fix_commits/CVE-2015-8104
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  dc9d9aa62ddeb14abd5672690d30789829f58f7e:x86/pv: Correct the auditing of guest breakpoint addresses

  The use of access_ok() is buggy, because it permits access to the compat
  translation area.  64bit PV guests don't use the XLAT area, but on AMD
  hardware, the DBEXT feature allows a breakpoint to match up to a 4G aligned
  region, allowing the breakpoint to reach outside of the XLAT area.

  Prior to c/s cda16c1bb223 ("x86: mirror compat argument translation area for
  32-bit PV"), the live GDT was within 4G of the XLAT area.

  All together, this allowed a malicious 64bit PV guest on AMD hardware to place
  a breakpoint over the live GDT, and trigger a #DB livelock (CVE-2015-8104).

  Introduce breakpoint_addr_ok() and explain why __addr_ok() happens to be an
  appropriate check in this case.

  For Xen 4.14 and later, this is a latent bug because the XLAT area has moved
  to be on its own with nothing interesting adjacent.  For Xen 4.13 and older on
  AMD hardware, this fixes a PV-trigger-able DoS.

  This is part of XSA-444 / CVE-2023-34328.

  Fixes: 65e355490817 ("x86/PV: support data breakpoint extension registers")
  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  4a4daf6bddbe8a741329df5cc8768f7dec664aed:x86/pv: Correct the auditing of guest breakpoint addresses

  The use of access_ok() is buggy, because it permits access to the compat
  translation area.  64bit PV guests don't use the XLAT area, but on AMD
  hardware, the DBEXT feature allows a breakpoint to match up to a 4G aligned
  region, allowing the breakpoint to reach outside of the XLAT area.

  Prior to c/s cda16c1bb223 ("x86: mirror compat argument translation area for
  32-bit PV"), the live GDT was within 4G of the XLAT area.

  All together, this allowed a malicious 64bit PV guest on AMD hardware to place
  a breakpoint over the live GDT, and trigger a #DB livelock (CVE-2015-8104).

  Introduce breakpoint_addr_ok() and explain why __addr_ok() happens to be an
  appropriate check in this case.

  For Xen 4.14 and later, this is a latent bug because the XLAT area has moved
  to be on its own with nothing interesting adjacent.  For Xen 4.13 and older on
  AMD hardware, this fixes a PV-trigger-able DoS.

  This is part of XSA-444 / CVE-2023-34328.

  Fixes: 65e355490817 ("x86/PV: support data breakpoint extension registers")
  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  (cherry picked from commit dc9d9aa62ddeb14abd5672690d30789829f58f7e)
  29efce0f8f10e381417a61f2f9988b40d4f6bcf0:x86/pv: Correct the auditing of guest breakpoint addresses

  The use of access_ok() is buggy, because it permits access to the compat
  translation area.  64bit PV guests don't use the XLAT area, but on AMD
  hardware, the DBEXT feature allows a breakpoint to match up to a 4G aligned
  region, allowing the breakpoint to reach outside of the XLAT area.

  Prior to c/s cda16c1bb223 ("x86: mirror compat argument translation area for
  32-bit PV"), the live GDT was within 4G of the XLAT area.

  All together, this allowed a malicious 64bit PV guest on AMD hardware to place
  a breakpoint over the live GDT, and trigger a #DB livelock (CVE-2015-8104).

  Introduce breakpoint_addr_ok() and explain why __addr_ok() happens to be an
  appropriate check in this case.

  For Xen 4.14 and later, this is a latent bug because the XLAT area has moved
  to be on its own with nothing interesting adjacent.  For Xen 4.13 and older on
  AMD hardware, this fixes a PV-trigger-able DoS.

  This is part of XSA-444 / CVE-2023-34328.

  Fixes: 65e355490817 ("x86/PV: support data breakpoint extension registers")
  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  (cherry picked from commit dc9d9aa62ddeb14abd5672690d30789829f58f7e)
  0b56bed864ca9b572473957f0254aefa797216f2:x86/pv: Correct the auditing of guest breakpoint addresses

  The use of access_ok() is buggy, because it permits access to the compat
  translation area.  64bit PV guests don't use the XLAT area, but on AMD
  hardware, the DBEXT feature allows a breakpoint to match up to a 4G aligned
  region, allowing the breakpoint to reach outside of the XLAT area.

  Prior to c/s cda16c1bb223 ("x86: mirror compat argument translation area for
  32-bit PV"), the live GDT was within 4G of the XLAT area.

  All together, this allowed a malicious 64bit PV guest on AMD hardware to place
  a breakpoint over the live GDT, and trigger a #DB livelock (CVE-2015-8104).

  Introduce breakpoint_addr_ok() and explain why __addr_ok() happens to be an
  appropriate check in this case.

  For Xen 4.14 and later, this is a latent bug because the XLAT area has moved
  to be on its own with nothing interesting adjacent.  For Xen 4.13 and older on
  AMD hardware, this fixes a PV-trigger-able DoS.

  This is part of XSA-444 / CVE-2023-34328.

  Fixes: 65e355490817 ("x86/PV: support data breakpoint extension registers")
  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  (cherry picked from commit dc9d9aa62ddeb14abd5672690d30789829f58f7e)
  fd1e4cc4d1d100337931b6f6dc50ed0b9766968a:x86/HVM: always intercept #AC and #DB

  Both being benign exceptions, and both being possible to get triggered
  by exception delivery, this is required to prevent a guest from locking
  up a CPU (resulting from no other VM exits occurring once getting into
  such a loop).

  The specific scenarios:

  1) #AC may be raised during exception delivery if the handler is set to
  be a ring-3 one by a 32-bit guest, and the stack is misaligned.

  This is CVE-2015-5307 / XSA-156.

  Reported-by: Benjamin Serebrin <serebrin@google.com>

  2) #DB may be raised during exception delivery when a breakpoint got
  placed on a data structure involved in delivering the exception. This
  can result in an endless loop when a 64-bit guest uses a non-zero IST
  for the vector 1 IDT entry, but even without use of IST the time it
  takes until a contributory fault would get raised (results depending
  on the handler) may be quite long.

  This is CVE-2015-8104 / XSA-156.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Tested-by: Andrew Cooper <andrew.cooper3@citrix.com>
  master commit: bd2239d9fa975a1ee5bcd27c218ae042cd0a57bc
  master date: 2015-11-10 12:03:08 +0100
  26b09fa24faff16b3795b3d47088b17727a4e670:x86/HVM: always intercept #AC and #DB

  Both being benign exceptions, and both being possible to get triggered
  by exception delivery, this is required to prevent a guest from locking
  up a CPU (resulting from no other VM exits occurring once getting into
  such a loop).

  The specific scenarios:

  1) #AC may be raised during exception delivery if the handler is set to
  be a ring-3 one by a 32-bit guest, and the stack is misaligned.

  This is CVE-2015-5307 / XSA-156.

  Reported-by: Benjamin Serebrin <serebrin@google.com>

  2) #DB may be raised during exception delivery when a breakpoint got
  placed on a data structure involved in delivering the exception. This
  can result in an endless loop when a 64-bit guest uses a non-zero IST
  for the vector 1 IDT entry, but even without use of IST the time it
  takes until a contributory fault would get raised (results depending
  on the handler) may be quite long.

  This is CVE-2015-8104 / XSA-156.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Tested-by: Andrew Cooper <andrew.cooper3@citrix.com>
  master commit: bd2239d9fa975a1ee5bcd27c218ae042cd0a57bc
  master date: 2015-11-10 12:03:08 +0100
  6d8233dc06f75150ab6f7a3a4df1fd815d148b4d:x86/HVM: always intercept #AC and #DB

  Both being benign exceptions, and both being possible to get triggered
  by exception delivery, this is required to prevent a guest from locking
  up a CPU (resulting from no other VM exits occurring once getting into
  such a loop).

  The specific scenarios:

  1) #AC may be raised during exception delivery if the handler is set to
  be a ring-3 one by a 32-bit guest, and the stack is misaligned.

  This is CVE-2015-5307 / XSA-156.

  Reported-by: Benjamin Serebrin <serebrin@google.com>

  2) #DB may be raised during exception delivery when a breakpoint got
  placed on a data structure involved in delivering the exception. This
  can result in an endless loop when a 64-bit guest uses a non-zero IST
  for the vector 1 IDT entry, but even without use of IST the time it
  takes until a contributory fault would get raised (results depending
  on the handler) may be quite long.

  This is CVE-2015-8104 / XSA-156.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Tested-by: Andrew Cooper <andrew.cooper3@citrix.com>
  master commit: bd2239d9fa975a1ee5bcd27c218ae042cd0a57bc
  master date: 2015-11-10 12:03:08 +0100
  e3b0c81ba143939282d99d7cdc041f95bae9c917:x86/HVM: always intercept #AC and #DB

  Both being benign exceptions, and both being possible to get triggered
  by exception delivery, this is required to prevent a guest from locking
  up a CPU (resulting from no other VM exits occurring once getting into
  such a loop).

  The specific scenarios:

  1) #AC may be raised during exception delivery if the handler is set to
  be a ring-3 one by a 32-bit guest, and the stack is misaligned.

  This is CVE-2015-5307 / XSA-156.

  Reported-by: Benjamin Serebrin <serebrin@google.com>

  2) #DB may be raised during exception delivery when a breakpoint got
  placed on a data structure involved in delivering the exception. This
  can result in an endless loop when a 64-bit guest uses a non-zero IST
  for the vector 1 IDT entry, but even without use of IST the time it
  takes until a contributory fault would get raised (results depending
  on the handler) may be quite long.

  This is CVE-2015-8104 / XSA-156.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Tested-by: Andrew Cooper <andrew.cooper3@citrix.com>
  master commit: bd2239d9fa975a1ee5bcd27c218ae042cd0a57bc
  master date: 2015-11-10 12:03:08 +0100
  bd2239d9fa975a1ee5bcd27c218ae042cd0a57bc:x86/HVM: always intercept #AC and #DB

  Both being benign exceptions, and both being possible to get triggered
  by exception delivery, this is required to prevent a guest from locking
  up a CPU (resulting from no other VM exits occurring once getting into
  such a loop).

  The specific scenarios:

  1) #AC may be raised during exception delivery if the handler is set to
  be a ring-3 one by a 32-bit guest, and the stack is misaligned.

  This is CVE-2015-5307 / XSA-156.

  Reported-by: Benjamin Serebrin <serebrin@google.com>

  2) #DB may be raised during exception delivery when a breakpoint got
  placed on a data structure involved in delivering the exception. This
  can result in an endless loop when a 64-bit guest uses a non-zero IST
  for the vector 1 IDT entry, but even without use of IST the time it
  takes until a contributory fault would get raised (results depending
  on the handler) may be quite long.

  This is CVE-2015-8104 / XSA-156.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Tested-by: Andrew Cooper <andrew.cooper3@citrix.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: bd2239d9fa975a1ee5bcd27c218ae042cd0a57bc
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 0b56bed864ca9b572473957f0254aefa797216f2
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: e3b0c81ba143939282d99d7cdc041f95bae9c917
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 6d8233dc06f75150ab6f7a3a4df1fd815d148b4d
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 26b09fa24faff16b3795b3d47088b17727a4e670
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 4a4daf6bddbe8a741329df5cc8768f7dec664aed
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: dc9d9aa62ddeb14abd5672690d30789829f58f7e
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: fd1e4cc4d1d100337931b6f6dc50ed0b9766968a
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 29efce0f8f10e381417a61f2f9988b40d4f6bcf0
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/0b56bed864ca9b572473957f0254aefa797216f2
    reference_type: commit
    reference_id: 0b56bed864ca9b572473957f0254aefa797216f2
  - url: https://github.com/xen-project/xen/tree/26b09fa24faff16b3795b3d47088b17727a4e670
    reference_type: commit
    reference_id: 26b09fa24faff16b3795b3d47088b17727a4e670
  - url: https://github.com/xen-project/xen/tree/29efce0f8f10e381417a61f2f9988b40d4f6bcf0
    reference_type: commit
    reference_id: 29efce0f8f10e381417a61f2f9988b40d4f6bcf0
  - url: https://github.com/xen-project/xen/tree/4a4daf6bddbe8a741329df5cc8768f7dec664aed
    reference_type: commit
    reference_id: 4a4daf6bddbe8a741329df5cc8768f7dec664aed
  - url: https://github.com/xen-project/xen/tree/6d8233dc06f75150ab6f7a3a4df1fd815d148b4d
    reference_type: commit
    reference_id: 6d8233dc06f75150ab6f7a3a4df1fd815d148b4d
  - url: https://github.com/xen-project/xen/tree/bd2239d9fa975a1ee5bcd27c218ae042cd0a57bc
    reference_type: commit
    reference_id: bd2239d9fa975a1ee5bcd27c218ae042cd0a57bc
  - url: https://github.com/xen-project/xen/tree/dc9d9aa62ddeb14abd5672690d30789829f58f7e
    reference_type: commit
    reference_id: dc9d9aa62ddeb14abd5672690d30789829f58f7e
  - url: https://github.com/xen-project/xen/tree/e3b0c81ba143939282d99d7cdc041f95bae9c917
    reference_type: commit
    reference_id: e3b0c81ba143939282d99d7cdc041f95bae9c917
  - url: https://github.com/xen-project/xen/tree/fd1e4cc4d1d100337931b6f6dc50ed0b9766968a
    reference_type: commit
    reference_id: fd1e4cc4d1d100337931b6f6dc50ed0b9766968a
