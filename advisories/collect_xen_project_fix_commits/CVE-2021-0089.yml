advisory_id: CVE-2021-0089
datasource_id: collect_xen_project_fix_commits/CVE-2021-0089
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  7937627baf95e3f142639df7cb750658ca1871f3:x86/spec-ctrl: Protect against Speculative Code Store Bypass

  Modern x86 processors have far-better-than-architecturally-guaranteed self
  modifying code detection.  Typically, when a write hits an instruction in
  flight, a Machine Clear occurs to flush stale content in the frontend and
  backend.

  For self modifying code, before a write which hits an instruction in flight
  retires, the frontend can speculatively decode and execute the old instruction
  stream.  Speculation of this form can suffer from type confusion in registers,
  and potentially leak data.

  Furthermore, updates are typically byte-wise, rather than atomic.  Depending
  on timing, speculation can race ahead multiple times between individual
  writes, and execute the transiently-malformed instruction stream.

  Xen has stubs which are used in certain cases for emulation purposes.  Inhibit
  speculation between updating the stub and executing it.

  This is XSA-375 / CVE-2021-0089.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  (cherry picked from commit 45f59ed8865318bb0356954bad067f329677ce9e)
  99f2c4672368481307a52c24ff1a630a7451ba5a:x86/spec-ctrl: Protect against Speculative Code Store Bypass

  Modern x86 processors have far-better-than-architecturally-guaranteed self
  modifying code detection.  Typically, when a write hits an instruction in
  flight, a Machine Clear occurs to flush stale content in the frontend and
  backend.

  For self modifying code, before a write which hits an instruction in flight
  retires, the frontend can speculatively decode and execute the old instruction
  stream.  Speculation of this form can suffer from type confusion in registers,
  and potentially leak data.

  Furthermore, updates are typically byte-wise, rather than atomic.  Depending
  on timing, speculation can race ahead multiple times between individual
  writes, and execute the transiently-malformed instruction stream.

  Xen has stubs which are used in certain cases for emulation purposes.  Inhibit
  speculation between updating the stub and executing it.

  This is XSA-375 / CVE-2021-0089.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  (cherry picked from commit 45f59ed8865318bb0356954bad067f329677ce9e)
  97af34f9c36cb77132d91dfbc0cf8d502185764d:x86/spec-ctrl: Protect against Speculative Code Store Bypass

  Modern x86 processors have far-better-than-architecturally-guaranteed self
  modifying code detection.  Typically, when a write hits an instruction in
  flight, a Machine Clear occurs to flush stale content in the frontend and
  backend.

  For self modifying code, before a write which hits an instruction in flight
  retires, the frontend can speculatively decode and execute the old instruction
  stream.  Speculation of this form can suffer from type confusion in registers,
  and potentially leak data.

  Furthermore, updates are typically byte-wise, rather than atomic.  Depending
  on timing, speculation can race ahead multiple times between individual
  writes, and execute the transiently-malformed instruction stream.

  Xen has stubs which are used in certain cases for emulation purposes.  Inhibit
  speculation between updating the stub and executing it.

  This is XSA-375 / CVE-2021-0089.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  (cherry picked from commit 45f59ed8865318bb0356954bad067f329677ce9e)
  fcf98eff7321a5ed8d9b4fccf44cde8ad7e2ec7e:x86/spec-ctrl: Protect against Speculative Code Store Bypass

  Modern x86 processors have far-better-than-architecturally-guaranteed self
  modifying code detection.  Typically, when a write hits an instruction in
  flight, a Machine Clear occurs to flush stale content in the frontend and
  backend.

  For self modifying code, before a write which hits an instruction in flight
  retires, the frontend can speculatively decode and execute the old instruction
  stream.  Speculation of this form can suffer from type confusion in registers,
  and potentially leak data.

  Furthermore, updates are typically byte-wise, rather than atomic.  Depending
  on timing, speculation can race ahead multiple times between individual
  writes, and execute the transiently-malformed instruction stream.

  Xen has stubs which are used in certain cases for emulation purposes.  Inhibit
  speculation between updating the stub and executing it.

  This is XSA-375 / CVE-2021-0089.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  (cherry picked from commit 45f59ed8865318bb0356954bad067f329677ce9e)
  894636d192368b130146311af2e539346c6fd650:x86/spec-ctrl: Protect against Speculative Code Store Bypass

  Modern x86 processors have far-better-than-architecturally-guaranteed self
  modifying code detection.  Typically, when a write hits an instruction in
  flight, a Machine Clear occurs to flush stale content in the frontend and
  backend.

  For self modifying code, before a write which hits an instruction in flight
  retires, the frontend can speculatively decode and execute the old instruction
  stream.  Speculation of this form can suffer from type confusion in registers,
  and potentially leak data.

  Furthermore, updates are typically byte-wise, rather than atomic.  Depending
  on timing, speculation can race ahead multiple times between individual
  writes, and execute the transiently-malformed instruction stream.

  Xen has stubs which are used in certain cases for emulation purposes.  Inhibit
  speculation between updating the stub and executing it.

  This is XSA-375 / CVE-2021-0089.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  (cherry picked from commit 45f59ed8865318bb0356954bad067f329677ce9e)
  45f59ed8865318bb0356954bad067f329677ce9e:x86/spec-ctrl: Protect against Speculative Code Store Bypass

  Modern x86 processors have far-better-than-architecturally-guaranteed self
  modifying code detection.  Typically, when a write hits an instruction in
  flight, a Machine Clear occurs to flush stale content in the frontend and
  backend.

  For self modifying code, before a write which hits an instruction in flight
  retires, the frontend can speculatively decode and execute the old instruction
  stream.  Speculation of this form can suffer from type confusion in registers,
  and potentially leak data.

  Furthermore, updates are typically byte-wise, rather than atomic.  Depending
  on timing, speculation can race ahead multiple times between individual
  writes, and execute the transiently-malformed instruction stream.

  Xen has stubs which are used in certain cases for emulation purposes.  Inhibit
  speculation between updating the stub and executing it.

  This is XSA-375 / CVE-2021-0089.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 99f2c4672368481307a52c24ff1a630a7451ba5a
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 7937627baf95e3f142639df7cb750658ca1871f3
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 894636d192368b130146311af2e539346c6fd650
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 97af34f9c36cb77132d91dfbc0cf8d502185764d
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: fcf98eff7321a5ed8d9b4fccf44cde8ad7e2ec7e
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 45f59ed8865318bb0356954bad067f329677ce9e
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/45f59ed8865318bb0356954bad067f329677ce9e
    reference_type: commit
    reference_id: 45f59ed8865318bb0356954bad067f329677ce9e
  - url: https://github.com/xen-project/xen/tree/7937627baf95e3f142639df7cb750658ca1871f3
    reference_type: commit
    reference_id: 7937627baf95e3f142639df7cb750658ca1871f3
  - url: https://github.com/xen-project/xen/tree/894636d192368b130146311af2e539346c6fd650
    reference_type: commit
    reference_id: 894636d192368b130146311af2e539346c6fd650
  - url: https://github.com/xen-project/xen/tree/97af34f9c36cb77132d91dfbc0cf8d502185764d
    reference_type: commit
    reference_id: 97af34f9c36cb77132d91dfbc0cf8d502185764d
  - url: https://github.com/xen-project/xen/tree/99f2c4672368481307a52c24ff1a630a7451ba5a
    reference_type: commit
    reference_id: 99f2c4672368481307a52c24ff1a630a7451ba5a
  - url: https://github.com/xen-project/xen/tree/fcf98eff7321a5ed8d9b4fccf44cde8ad7e2ec7e
    reference_type: commit
    reference_id: fcf98eff7321a5ed8d9b4fccf44cde8ad7e2ec7e
