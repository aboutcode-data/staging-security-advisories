advisory_id: CVE-2016-9377
datasource_id: collect_xen_project_fix_commits/CVE-2016-9377
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  34fbae790c98966903d7f97c6f46622ea842ab55:x86/emul: correct the IDT entry calculation in inject_swint()

  The logic, as introduced in c/s 36ebf14ebe "x86/emulate: support for emulating
  software event injection" is buggy.  The size of an IDT entry depends on long
  mode being active, not the width of the code segment currently in use.

  In particular, this means that a compatibility code segment which hits
  emulation for software event injection will end up using an incorrect offset
  in the IDT for DPL/Presence checking.  In practice, this only occurs on old
  AMD hardware lacking NRip support; all newer AMD hardware, and all Intel
  hardware bypass this path in the emulator.

  While here, fix a minor issue with reading the IDT entry.  The return value
  from ops->read() wasn't checked, but in reality the only failure case is if a
  pagefault occurs.  This is not a realistic problem as the kernel will almost
  certainly crash with a double fault if this setup actually occured.

  This is CVE-2016-9377 / part of XSA-196.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 255e8fe95f22ded5186fd75244ffcfb9d5dbc855
  master date: 2016-11-22 13:50:49 +0100
  c03035b2af292e9054e3e0e0e99e560817b33681:x86/emul: correct the IDT entry calculation in inject_swint()

  The logic, as introduced in c/s 36ebf14ebe "x86/emulate: support for emulating
  software event injection" is buggy.  The size of an IDT entry depends on long
  mode being active, not the width of the code segment currently in use.

  In particular, this means that a compatibility code segment which hits
  emulation for software event injection will end up using an incorrect offset
  in the IDT for DPL/Presence checking.  In practice, this only occurs on old
  AMD hardware lacking NRip support; all newer AMD hardware, and all Intel
  hardware bypass this path in the emulator.

  While here, fix a minor issue with reading the IDT entry.  The return value
  from ops->read() wasn't checked, but in reality the only failure case is if a
  pagefault occurs.  This is not a realistic problem as the kernel will almost
  certainly crash with a double fault if this setup actually occured.

  This is CVE-2016-9377 / part of XSA-196.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 255e8fe95f22ded5186fd75244ffcfb9d5dbc855
  master date: 2016-11-22 13:50:49 +0100
  98eaf9ce737dbc72df0c8e15fa5962c428ed637a:x86/emul: correct the IDT entry calculation in inject_swint()

  The logic, as introduced in c/s 36ebf14ebe "x86/emulate: support for emulating
  software event injection" is buggy.  The size of an IDT entry depends on long
  mode being active, not the width of the code segment currently in use.

  In particular, this means that a compatibility code segment which hits
  emulation for software event injection will end up using an incorrect offset
  in the IDT for DPL/Presence checking.  In practice, this only occurs on old
  AMD hardware lacking NRip support; all newer AMD hardware, and all Intel
  hardware bypass this path in the emulator.

  While here, fix a minor issue with reading the IDT entry.  The return value
  from ops->read() wasn't checked, but in reality the only failure case is if a
  pagefault occurs.  This is not a realistic problem as the kernel will almost
  certainly crash with a double fault if this setup actually occured.

  This is CVE-2016-9377 / part of XSA-196.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 255e8fe95f22ded5186fd75244ffcfb9d5dbc855
  master date: 2016-11-22 13:50:49 +0100
  255e8fe95f22ded5186fd75244ffcfb9d5dbc855:x86/emul: correct the IDT entry calculation in inject_swint()

  The logic, as introduced in c/s 36ebf14ebe "x86/emulate: support for emulating
  software event injection" is buggy.  The size of an IDT entry depends on long
  mode being active, not the width of the code segment currently in use.

  In particular, this means that a compatibility code segment which hits
  emulation for software event injection will end up using an incorrect offset
  in the IDT for DPL/Presence checking.  In practice, this only occurs on old
  AMD hardware lacking NRip support; all newer AMD hardware, and all Intel
  hardware bypass this path in the emulator.

  While here, fix a minor issue with reading the IDT entry.  The return value
  from ops->read() wasn't checked, but in reality the only failure case is if a
  pagefault occurs.  This is not a realistic problem as the kernel will almost
  certainly crash with a double fault if this setup actually occured.

  This is CVE-2016-9377 / part of XSA-196.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: c03035b2af292e9054e3e0e0e99e560817b33681
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 34fbae790c98966903d7f97c6f46622ea842ab55
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 255e8fe95f22ded5186fd75244ffcfb9d5dbc855
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 98eaf9ce737dbc72df0c8e15fa5962c428ed637a
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/255e8fe95f22ded5186fd75244ffcfb9d5dbc855
    reference_type: commit
    reference_id: 255e8fe95f22ded5186fd75244ffcfb9d5dbc855
  - url: https://github.com/xen-project/xen/tree/34fbae790c98966903d7f97c6f46622ea842ab55
    reference_type: commit
    reference_id: 34fbae790c98966903d7f97c6f46622ea842ab55
  - url: https://github.com/xen-project/xen/tree/98eaf9ce737dbc72df0c8e15fa5962c428ed637a
    reference_type: commit
    reference_id: 98eaf9ce737dbc72df0c8e15fa5962c428ed637a
  - url: https://github.com/xen-project/xen/tree/c03035b2af292e9054e3e0e0e99e560817b33681
    reference_type: commit
    reference_id: c03035b2af292e9054e3e0e0e99e560817b33681
