advisory_id: CVE-2021-28692
datasource_id: collect_xen_project_fix_commits/CVE-2021-28692
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  944da2f5b8530433aeaa46493db48f3ddb0aa302:AMD/IOMMU: drop command completion timeout

  First and foremost - such timeouts were not signaled to callers, making
  them believe they're fine to e.g. free previously unmapped pages.

  Mirror VT-d's behavior: A fixed number of loop iterations is not a
  suitable way to detect timeouts in an environment (CPU and bus speeds)
  independent manner anyway. Furthermore, leaving an in-progress operation
  pending when it appears to take too long is problematic: If a command
  completed later, the signaling of its completion may instead be
  understood to signal a subsequently started command's completion.

  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area. Allow callers to specify
  a non-default timeout bias for this logging, using the same values as
  VT-d does, which in particular means a (by default) much larger value
  for device IO TLB invalidation.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit e4fee66043120c954fc309bbb37813604c1c0eb7)
  9f8bf2a7ddab2a5c874072cfa430ffae9772de1d:AMD/IOMMU: wait for command slot to be available

  No caller cared about send_iommu_command() indicating unavailability of
  a slot. Hence if a sufficient number prior commands timed out, we did
  blindly assume that the requested command was submitted to the IOMMU
  when really it wasn't. This could mean both a hanging system (waiting
  for a command to complete that was never seen by the IOMMU) or blindly
  propagating success back to callers, making them believe they're fine
  to e.g. free previously unmapped pages.

  Fold the three involved functions into one, add spin waiting for an
  available slot along the lines of VT-d's qinval_next_index(), and as a
  consequence drop all error indicator return types/values.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit c4e44343579e2c3304d676404d81b2b9bd893c5b)
  dc3e5441867de26b921c4e10241fb8ad1c9d3fad:VT-d: eliminate flush related timeouts

  Leaving an in-progress operation pending when it appears to take too
  long is problematic: If e.g. a QI command completed later, the write to
  the "poll slot" may instead be understood to signal a subsequently
  started command's completion. Also our accounting of the timeout period
  was actually wrong: We included the time it took for the command to
  actually make it to the front of the queue, which could be heavily
  affected by guests other than the one for which the flush is being
  performed.

  Do away with all timeout detection on all flush related code paths.
  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area.

  Additionally log (once) if qinval_next_index() didn't immediately find
  an available slot. Together with the earlier change sizing the queue(s)
  dynamically, we should now have a guarantee that with our fully
  synchronous model any demand for slots can actually be satisfied.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit 7c893abc4ee7e9af62297ba6fd5f27c89d0f33f5)
  89d3cc62a50475a63a388487b8d4b574dfd426a5:AMD/IOMMU: size command buffer dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait command).  There can be one
  such pair of commands pending per CPU. To ensure that under all normal
  circumstances a slot is always available when one is requested, size the
  command ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit df242851ddc93ac0b0a3a20ecab34acc29e3b36b)
  37518c21cf97b2d333403f994a772cbbbe5bedfc:VT-d: size qinval queue dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait descriptor).  There can be
  one such pair of requests pending per CPU. To ensure that under all
  normal circumstances a slot is always available when one is requested,
  size the queue ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit cbfa62bb140c8f10a0ae96db3ce06e22b3b9d302)
  d024fe144d072ec1e3c7e03a7992a147cfdbd35e:AMD/IOMMU: drop command completion timeout

  First and foremost - such timeouts were not signaled to callers, making
  them believe they're fine to e.g. free previously unmapped pages.

  Mirror VT-d's behavior: A fixed number of loop iterations is not a
  suitable way to detect timeouts in an environment (CPU and bus speeds)
  independent manner anyway. Furthermore, leaving an in-progress operation
  pending when it appears to take too long is problematic: If a command
  completed later, the signaling of its completion may instead be
  understood to signal a subsequently started command's completion.

  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area. Allow callers to specify
  a non-default timeout bias for this logging, using the same values as
  VT-d does, which in particular means a (by default) much larger value
  for device IO TLB invalidation.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit e4fee66043120c954fc309bbb37813604c1c0eb7)
  e5f3be9d6ef53d4dfef0f7a550ce6cd93b9629e2:AMD/IOMMU: wait for command slot to be available

  No caller cared about send_iommu_command() indicating unavailability of
  a slot. Hence if a sufficient number prior commands timed out, we did
  blindly assume that the requested command was submitted to the IOMMU
  when really it wasn't. This could mean both a hanging system (waiting
  for a command to complete that was never seen by the IOMMU) or blindly
  propagating success back to callers, making them believe they're fine
  to e.g. free previously unmapped pages.

  Fold the three involved functions into one, add spin waiting for an
  available slot along the lines of VT-d's qinval_next_index(), and as a
  consequence drop all error indicator return types/values.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit c4e44343579e2c3304d676404d81b2b9bd893c5b)
  e318c1330fbfb3388bdb8e5501a0ab89d6aa5a5a:VT-d: eliminate flush related timeouts

  Leaving an in-progress operation pending when it appears to take too
  long is problematic: If e.g. a QI command completed later, the write to
  the "poll slot" may instead be understood to signal a subsequently
  started command's completion. Also our accounting of the timeout period
  was actually wrong: We included the time it took for the command to
  actually make it to the front of the queue, which could be heavily
  affected by guests other than the one for which the flush is being
  performed.

  Do away with all timeout detection on all flush related code paths.
  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area.

  Additionally log (once) if qinval_next_index() didn't immediately find
  an available slot. Together with the earlier change sizing the queue(s)
  dynamically, we should now have a guarantee that with our fully
  synchronous model any demand for slots can actually be satisfied.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit 7c893abc4ee7e9af62297ba6fd5f27c89d0f33f5)
  ced413bdfddbfbaf72caf79333962fe199bea6d9:AMD/IOMMU: size command buffer dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait command).  There can be one
  such pair of commands pending per CPU. To ensure that under all normal
  circumstances a slot is always available when one is requested, size the
  command ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit df242851ddc93ac0b0a3a20ecab34acc29e3b36b)
  95d23c7563636e6304931a559b6610387ef2bf4b:VT-d: size qinval queue dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait descriptor).  There can be
  one such pair of requests pending per CPU. To ensure that under all
  normal circumstances a slot is always available when one is requested,
  size the queue ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit cbfa62bb140c8f10a0ae96db3ce06e22b3b9d302)
  f7993297b3469f4396af8ed14ba376982cabd64b:AMD/IOMMU: drop command completion timeout

  First and foremost - such timeouts were not signaled to callers, making
  them believe they're fine to e.g. free previously unmapped pages.

  Mirror VT-d's behavior: A fixed number of loop iterations is not a
  suitable way to detect timeouts in an environment (CPU and bus speeds)
  independent manner anyway. Furthermore, leaving an in-progress operation
  pending when it appears to take too long is problematic: If a command
  completed later, the signaling of its completion may instead be
  understood to signal a subsequently started command's completion.

  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area. Allow callers to specify
  a non-default timeout bias for this logging, using the same values as
  VT-d does, which in particular means a (by default) much larger value
  for device IO TLB invalidation.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit e4fee66043120c954fc309bbb37813604c1c0eb7)
  0a3eb9bbc2188f36692a570c85816c6d3d0da697:AMD/IOMMU: wait for command slot to be available

  No caller cared about send_iommu_command() indicating unavailability of
  a slot. Hence if a sufficient number prior commands timed out, we did
  blindly assume that the requested command was submitted to the IOMMU
  when really it wasn't. This could mean both a hanging system (waiting
  for a command to complete that was never seen by the IOMMU) or blindly
  propagating success back to callers, making them believe they're fine
  to e.g. free previously unmapped pages.

  Fold the three involved functions into one, add spin waiting for an
  available slot along the lines of VT-d's qinval_next_index(), and as a
  consequence drop all error indicator return types/values.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit c4e44343579e2c3304d676404d81b2b9bd893c5b)
  d3d8a298f7fd27371414fc771786c2a0f1564152:VT-d: eliminate flush related timeouts

  Leaving an in-progress operation pending when it appears to take too
  long is problematic: If e.g. a QI command completed later, the write to
  the "poll slot" may instead be understood to signal a subsequently
  started command's completion. Also our accounting of the timeout period
  was actually wrong: We included the time it took for the command to
  actually make it to the front of the queue, which could be heavily
  affected by guests other than the one for which the flush is being
  performed.

  Do away with all timeout detection on all flush related code paths.
  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area.

  Additionally log (once) if qinval_next_index() didn't immediately find
  an available slot. Together with the earlier change sizing the queue(s)
  dynamically, we should now have a guarantee that with our fully
  synchronous model any demand for slots can actually be satisfied.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit 7c893abc4ee7e9af62297ba6fd5f27c89d0f33f5)
  83c0f6bbb25769b9ac711ea6b218d5ee858a360e:AMD/IOMMU: size command buffer dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait command).  There can be one
  such pair of commands pending per CPU. To ensure that under all normal
  circumstances a slot is always available when one is requested, size the
  command ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit df242851ddc93ac0b0a3a20ecab34acc29e3b36b)
  9e3c8b1448d50a3154882a686719f8acc0dad6e7:VT-d: size qinval queue dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait descriptor).  There can be
  one such pair of requests pending per CPU. To ensure that under all
  normal circumstances a slot is always available when one is requested,
  size the queue ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit cbfa62bb140c8f10a0ae96db3ce06e22b3b9d302)
  51278ce831a8fcc4ffb4c841e3442de3fd4ea76b:AMD/IOMMU: drop command completion timeout

  First and foremost - such timeouts were not signaled to callers, making
  them believe they're fine to e.g. free previously unmapped pages.

  Mirror VT-d's behavior: A fixed number of loop iterations is not a
  suitable way to detect timeouts in an environment (CPU and bus speeds)
  independent manner anyway. Furthermore, leaving an in-progress operation
  pending when it appears to take too long is problematic: If a command
  completed later, the signaling of its completion may instead be
  understood to signal a subsequently started command's completion.

  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area. Allow callers to specify
  a non-default timeout bias for this logging, using the same values as
  VT-d does, which in particular means a (by default) much larger value
  for device IO TLB invalidation.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit e4fee66043120c954fc309bbb37813604c1c0eb7)
  766b1f447314dd5e8f14c540440cbfc080f3b998:AMD/IOMMU: wait for command slot to be available

  No caller cared about send_iommu_command() indicating unavailability of
  a slot. Hence if a sufficient number prior commands timed out, we did
  blindly assume that the requested command was submitted to the IOMMU
  when really it wasn't. This could mean both a hanging system (waiting
  for a command to complete that was never seen by the IOMMU) or blindly
  propagating success back to callers, making them believe they're fine
  to e.g. free previously unmapped pages.

  Fold the three involved functions into one, add spin waiting for an
  available slot along the lines of VT-d's qinval_next_index(), and as a
  consequence drop all error indicator return types/values.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit c4e44343579e2c3304d676404d81b2b9bd893c5b)
  e5bce3a74bacfe570233d61e57d31438d21fafd5:VT-d: eliminate flush related timeouts

  Leaving an in-progress operation pending when it appears to take too
  long is problematic: If e.g. a QI command completed later, the write to
  the "poll slot" may instead be understood to signal a subsequently
  started command's completion. Also our accounting of the timeout period
  was actually wrong: We included the time it took for the command to
  actually make it to the front of the queue, which could be heavily
  affected by guests other than the one for which the flush is being
  performed.

  Do away with all timeout detection on all flush related code paths.
  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area.

  Additionally log (once) if qinval_next_index() didn't immediately find
  an available slot. Together with the earlier change sizing the queue(s)
  dynamically, we should now have a guarantee that with our fully
  synchronous model any demand for slots can actually be satisfied.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit 7c893abc4ee7e9af62297ba6fd5f27c89d0f33f5)
  46ff2453de9e58ad49d79eda1be6ff21c22b3144:AMD/IOMMU: size command buffer dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait command).  There can be one
  such pair of commands pending per CPU. To ensure that under all normal
  circumstances a slot is always available when one is requested, size the
  command ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit df242851ddc93ac0b0a3a20ecab34acc29e3b36b)
  2665d9785e748bf9cd87ec5783099e644ce2bac2:VT-d: size qinval queue dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait descriptor).  There can be
  one such pair of requests pending per CPU. To ensure that under all
  normal circumstances a slot is always available when one is requested,
  size the queue ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit cbfa62bb140c8f10a0ae96db3ce06e22b3b9d302)
  a339ceaa8f17e827ee5eb25f05ad6f52ba8d6b1c:AMD/IOMMU: drop command completion timeout

  First and foremost - such timeouts were not signaled to callers, making
  them believe they're fine to e.g. free previously unmapped pages.

  Mirror VT-d's behavior: A fixed number of loop iterations is not a
  suitable way to detect timeouts in an environment (CPU and bus speeds)
  independent manner anyway. Furthermore, leaving an in-progress operation
  pending when it appears to take too long is problematic: If a command
  completed later, the signaling of its completion may instead be
  understood to signal a subsequently started command's completion.

  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area. Allow callers to specify
  a non-default timeout bias for this logging, using the same values as
  VT-d does, which in particular means a (by default) much larger value
  for device IO TLB invalidation.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit e4fee66043120c954fc309bbb37813604c1c0eb7)
  874dac9b27c09a1fe976dccd62d4509c0389ffea:AMD/IOMMU: wait for command slot to be available

  No caller cared about send_iommu_command() indicating unavailability of
  a slot. Hence if a sufficient number prior commands timed out, we did
  blindly assume that the requested command was submitted to the IOMMU
  when really it wasn't. This could mean both a hanging system (waiting
  for a command to complete that was never seen by the IOMMU) or blindly
  propagating success back to callers, making them believe they're fine
  to e.g. free previously unmapped pages.

  Fold the three involved functions into one, add spin waiting for an
  available slot along the lines of VT-d's qinval_next_index(), and as a
  consequence drop all error indicator return types/values.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit c4e44343579e2c3304d676404d81b2b9bd893c5b)
  e4fee66043120c954fc309bbb37813604c1c0eb7:AMD/IOMMU: drop command completion timeout

  First and foremost - such timeouts were not signaled to callers, making
  them believe they're fine to e.g. free previously unmapped pages.

  Mirror VT-d's behavior: A fixed number of loop iterations is not a
  suitable way to detect timeouts in an environment (CPU and bus speeds)
  independent manner anyway. Furthermore, leaving an in-progress operation
  pending when it appears to take too long is problematic: If a command
  completed later, the signaling of its completion may instead be
  understood to signal a subsequently started command's completion.

  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area. Allow callers to specify
  a non-default timeout bias for this logging, using the same values as
  VT-d does, which in particular means a (by default) much larger value
  for device IO TLB invalidation.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  c4e44343579e2c3304d676404d81b2b9bd893c5b:AMD/IOMMU: wait for command slot to be available

  No caller cared about send_iommu_command() indicating unavailability of
  a slot. Hence if a sufficient number prior commands timed out, we did
  blindly assume that the requested command was submitted to the IOMMU
  when really it wasn't. This could mean both a hanging system (waiting
  for a command to complete that was never seen by the IOMMU) or blindly
  propagating success back to callers, making them believe they're fine
  to e.g. free previously unmapped pages.

  Fold the three involved functions into one, add spin waiting for an
  available slot along the lines of VT-d's qinval_next_index(), and as a
  consequence drop all error indicator return types/values.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  12ebf0f819517096e49a395bd9c4288b5010526d:VT-d: eliminate flush related timeouts

  Leaving an in-progress operation pending when it appears to take too
  long is problematic: If e.g. a QI command completed later, the write to
  the "poll slot" may instead be understood to signal a subsequently
  started command's completion. Also our accounting of the timeout period
  was actually wrong: We included the time it took for the command to
  actually make it to the front of the queue, which could be heavily
  affected by guests other than the one for which the flush is being
  performed.

  Do away with all timeout detection on all flush related code paths.
  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area.

  Additionally log (once) if qinval_next_index() didn't immediately find
  an available slot. Together with the earlier change sizing the queue(s)
  dynamically, we should now have a guarantee that with our fully
  synchronous model any demand for slots can actually be satisfied.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit 7c893abc4ee7e9af62297ba6fd5f27c89d0f33f5)
  35b583686c8085ac78922eb58a2930222c9c142c:AMD/IOMMU: size command buffer dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait command).  There can be one
  such pair of commands pending per CPU. To ensure that under all normal
  circumstances a slot is always available when one is requested, size the
  command ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit df242851ddc93ac0b0a3a20ecab34acc29e3b36b)
  8368f214f9446c3b1abc0045d01a2bc05926215a:VT-d: size qinval queue dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait descriptor).  There can be
  one such pair of requests pending per CPU. To ensure that under all
  normal circumstances a slot is always available when one is requested,
  size the queue ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  (cherry picked from commit cbfa62bb140c8f10a0ae96db3ce06e22b3b9d302)
  7c893abc4ee7e9af62297ba6fd5f27c89d0f33f5:VT-d: eliminate flush related timeouts

  Leaving an in-progress operation pending when it appears to take too
  long is problematic: If e.g. a QI command completed later, the write to
  the "poll slot" may instead be understood to signal a subsequently
  started command's completion. Also our accounting of the timeout period
  was actually wrong: We included the time it took for the command to
  actually make it to the front of the queue, which could be heavily
  affected by guests other than the one for which the flush is being
  performed.

  Do away with all timeout detection on all flush related code paths.
  Log excessively long processing times (with a progressive threshold) to
  have some indication of problems in this area.

  Additionally log (once) if qinval_next_index() didn't immediately find
  an available slot. Together with the earlier change sizing the queue(s)
  dynamically, we should now have a guarantee that with our fully
  synchronous model any demand for slots can actually be satisfied.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  df242851ddc93ac0b0a3a20ecab34acc29e3b36b:AMD/IOMMU: size command buffer dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait command).  There can be one
  such pair of commands pending per CPU. To ensure that under all normal
  circumstances a slot is always available when one is requested, size the
  command ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  cbfa62bb140c8f10a0ae96db3ce06e22b3b9d302:VT-d: size qinval queue dynamically

  With the present synchronous model, we need two slots for every
  operation (the operation itself and a wait descriptor).  There can be
  one such pair of requests pending per CPU. To ensure that under all
  normal circumstances a slot is always available when one is requested,
  size the queue ring according to the number of present CPUs.

  This is part of XSA-373 / CVE-2021-28692.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: cbfa62bb140c8f10a0ae96db3ce06e22b3b9d302
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 0a3eb9bbc2188f36692a570c85816c6d3d0da697
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: c4e44343579e2c3304d676404d81b2b9bd893c5b
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: d3d8a298f7fd27371414fc771786c2a0f1564152
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 8368f214f9446c3b1abc0045d01a2bc05926215a
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: dc3e5441867de26b921c4e10241fb8ad1c9d3fad
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: e318c1330fbfb3388bdb8e5501a0ab89d6aa5a5a
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 51278ce831a8fcc4ffb4c841e3442de3fd4ea76b
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 766b1f447314dd5e8f14c540440cbfc080f3b998
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: d024fe144d072ec1e3c7e03a7992a147cfdbd35e
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 2665d9785e748bf9cd87ec5783099e644ce2bac2
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 874dac9b27c09a1fe976dccd62d4509c0389ffea
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 12ebf0f819517096e49a395bd9c4288b5010526d
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 35b583686c8085ac78922eb58a2930222c9c142c
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: a339ceaa8f17e827ee5eb25f05ad6f52ba8d6b1c
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: ced413bdfddbfbaf72caf79333962fe199bea6d9
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: e5f3be9d6ef53d4dfef0f7a550ce6cd93b9629e2
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: f7993297b3469f4396af8ed14ba376982cabd64b
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 37518c21cf97b2d333403f994a772cbbbe5bedfc
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 95d23c7563636e6304931a559b6610387ef2bf4b
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 89d3cc62a50475a63a388487b8d4b574dfd426a5
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 9e3c8b1448d50a3154882a686719f8acc0dad6e7
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: e4fee66043120c954fc309bbb37813604c1c0eb7
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 944da2f5b8530433aeaa46493db48f3ddb0aa302
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 83c0f6bbb25769b9ac711ea6b218d5ee858a360e
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: df242851ddc93ac0b0a3a20ecab34acc29e3b36b
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: e5bce3a74bacfe570233d61e57d31438d21fafd5
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 46ff2453de9e58ad49d79eda1be6ff21c22b3144
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 9f8bf2a7ddab2a5c874072cfa430ffae9772de1d
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 7c893abc4ee7e9af62297ba6fd5f27c89d0f33f5
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/0a3eb9bbc2188f36692a570c85816c6d3d0da697
    reference_type: commit
    reference_id: 0a3eb9bbc2188f36692a570c85816c6d3d0da697
  - url: https://github.com/xen-project/xen/tree/12ebf0f819517096e49a395bd9c4288b5010526d
    reference_type: commit
    reference_id: 12ebf0f819517096e49a395bd9c4288b5010526d
  - url: https://github.com/xen-project/xen/tree/2665d9785e748bf9cd87ec5783099e644ce2bac2
    reference_type: commit
    reference_id: 2665d9785e748bf9cd87ec5783099e644ce2bac2
  - url: https://github.com/xen-project/xen/tree/35b583686c8085ac78922eb58a2930222c9c142c
    reference_type: commit
    reference_id: 35b583686c8085ac78922eb58a2930222c9c142c
  - url: https://github.com/xen-project/xen/tree/37518c21cf97b2d333403f994a772cbbbe5bedfc
    reference_type: commit
    reference_id: 37518c21cf97b2d333403f994a772cbbbe5bedfc
  - url: https://github.com/xen-project/xen/tree/46ff2453de9e58ad49d79eda1be6ff21c22b3144
    reference_type: commit
    reference_id: 46ff2453de9e58ad49d79eda1be6ff21c22b3144
  - url: https://github.com/xen-project/xen/tree/51278ce831a8fcc4ffb4c841e3442de3fd4ea76b
    reference_type: commit
    reference_id: 51278ce831a8fcc4ffb4c841e3442de3fd4ea76b
  - url: https://github.com/xen-project/xen/tree/766b1f447314dd5e8f14c540440cbfc080f3b998
    reference_type: commit
    reference_id: 766b1f447314dd5e8f14c540440cbfc080f3b998
  - url: https://github.com/xen-project/xen/tree/7c893abc4ee7e9af62297ba6fd5f27c89d0f33f5
    reference_type: commit
    reference_id: 7c893abc4ee7e9af62297ba6fd5f27c89d0f33f5
  - url: https://github.com/xen-project/xen/tree/8368f214f9446c3b1abc0045d01a2bc05926215a
    reference_type: commit
    reference_id: 8368f214f9446c3b1abc0045d01a2bc05926215a
  - url: https://github.com/xen-project/xen/tree/83c0f6bbb25769b9ac711ea6b218d5ee858a360e
    reference_type: commit
    reference_id: 83c0f6bbb25769b9ac711ea6b218d5ee858a360e
  - url: https://github.com/xen-project/xen/tree/874dac9b27c09a1fe976dccd62d4509c0389ffea
    reference_type: commit
    reference_id: 874dac9b27c09a1fe976dccd62d4509c0389ffea
  - url: https://github.com/xen-project/xen/tree/89d3cc62a50475a63a388487b8d4b574dfd426a5
    reference_type: commit
    reference_id: 89d3cc62a50475a63a388487b8d4b574dfd426a5
  - url: https://github.com/xen-project/xen/tree/944da2f5b8530433aeaa46493db48f3ddb0aa302
    reference_type: commit
    reference_id: 944da2f5b8530433aeaa46493db48f3ddb0aa302
  - url: https://github.com/xen-project/xen/tree/95d23c7563636e6304931a559b6610387ef2bf4b
    reference_type: commit
    reference_id: 95d23c7563636e6304931a559b6610387ef2bf4b
  - url: https://github.com/xen-project/xen/tree/9e3c8b1448d50a3154882a686719f8acc0dad6e7
    reference_type: commit
    reference_id: 9e3c8b1448d50a3154882a686719f8acc0dad6e7
  - url: https://github.com/xen-project/xen/tree/9f8bf2a7ddab2a5c874072cfa430ffae9772de1d
    reference_type: commit
    reference_id: 9f8bf2a7ddab2a5c874072cfa430ffae9772de1d
  - url: https://github.com/xen-project/xen/tree/a339ceaa8f17e827ee5eb25f05ad6f52ba8d6b1c
    reference_type: commit
    reference_id: a339ceaa8f17e827ee5eb25f05ad6f52ba8d6b1c
  - url: https://github.com/xen-project/xen/tree/c4e44343579e2c3304d676404d81b2b9bd893c5b
    reference_type: commit
    reference_id: c4e44343579e2c3304d676404d81b2b9bd893c5b
  - url: https://github.com/xen-project/xen/tree/cbfa62bb140c8f10a0ae96db3ce06e22b3b9d302
    reference_type: commit
    reference_id: cbfa62bb140c8f10a0ae96db3ce06e22b3b9d302
  - url: https://github.com/xen-project/xen/tree/ced413bdfddbfbaf72caf79333962fe199bea6d9
    reference_type: commit
    reference_id: ced413bdfddbfbaf72caf79333962fe199bea6d9
  - url: https://github.com/xen-project/xen/tree/d024fe144d072ec1e3c7e03a7992a147cfdbd35e
    reference_type: commit
    reference_id: d024fe144d072ec1e3c7e03a7992a147cfdbd35e
  - url: https://github.com/xen-project/xen/tree/d3d8a298f7fd27371414fc771786c2a0f1564152
    reference_type: commit
    reference_id: d3d8a298f7fd27371414fc771786c2a0f1564152
  - url: https://github.com/xen-project/xen/tree/dc3e5441867de26b921c4e10241fb8ad1c9d3fad
    reference_type: commit
    reference_id: dc3e5441867de26b921c4e10241fb8ad1c9d3fad
  - url: https://github.com/xen-project/xen/tree/df242851ddc93ac0b0a3a20ecab34acc29e3b36b
    reference_type: commit
    reference_id: df242851ddc93ac0b0a3a20ecab34acc29e3b36b
  - url: https://github.com/xen-project/xen/tree/e318c1330fbfb3388bdb8e5501a0ab89d6aa5a5a
    reference_type: commit
    reference_id: e318c1330fbfb3388bdb8e5501a0ab89d6aa5a5a
  - url: https://github.com/xen-project/xen/tree/e4fee66043120c954fc309bbb37813604c1c0eb7
    reference_type: commit
    reference_id: e4fee66043120c954fc309bbb37813604c1c0eb7
  - url: https://github.com/xen-project/xen/tree/e5bce3a74bacfe570233d61e57d31438d21fafd5
    reference_type: commit
    reference_id: e5bce3a74bacfe570233d61e57d31438d21fafd5
  - url: https://github.com/xen-project/xen/tree/e5f3be9d6ef53d4dfef0f7a550ce6cd93b9629e2
    reference_type: commit
    reference_id: e5f3be9d6ef53d4dfef0f7a550ce6cd93b9629e2
  - url: https://github.com/xen-project/xen/tree/f7993297b3469f4396af8ed14ba376982cabd64b
    reference_type: commit
    reference_id: f7993297b3469f4396af8ed14ba376982cabd64b
