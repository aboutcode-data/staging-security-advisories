advisory_id: CVE-2013-1917
datasource_id: collect_xen_project_fix_commits/CVE-2013-1917
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  584eb7c15e4c94baaba93468776572dd7373a33c:x86: clear EFLAGS.NT in SYSENTER entry path

  ... as it causes problems if we happen to exit back via IRET: In the
  course of trying to handle the fault, the hypervisor creates a stack
  frame by hand, and uses PUSHFQ to set the respective EFLAGS field, but
  expects to be able to IRET through that stack frame to the second
  portion of the fixup code (which causes a #GP due to the stored EFLAGS
  having NT set).

  And even if this worked (e.g if we cleared NT in that path), it would
  then (through the fail safe callback) cause a #GP in the guest with the
  SYSENTER handler's first instruction as the source, which in turn would
  allow guest user mode code to crash the guest kernel.

  Inject a #GP on the fake (NULL) address of the SYSENTER instruction
  instead, just like in the case where the guest kernel didn't register
  a corresponding entry point.

  On 32-bit we also need to make sure we clear SYSENTER_CS for all CPUs
  (neither #RESET nor #INIT guarantee this).

  This is CVE-2013-1917 / XSA-44.

  Reported-by: Andrew Cooper <andrew.cooper3@citirx.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Tested-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>
  master commit: fdac9515607b757c044e7ef0d61b1453ef999b08
  master date: 2013-04-18 16:00:35 +0200
  68a30a91bad2d4ff1f7c0d4302ec1060d573f6da:x86: clear EFLAGS.NT in SYSENTER entry path

  ... as it causes problems if we happen to exit back via IRET: In the
  course of trying to handle the fault, the hypervisor creates a stack
  frame by hand, and uses PUSHFQ to set the respective EFLAGS field, but
  expects to be able to IRET through that stack frame to the second
  portion of the fixup code (which causes a #GP due to the stored EFLAGS
  having NT set).

  And even if this worked (e.g if we cleared NT in that path), it would
  then (through the fail safe callback) cause a #GP in the guest with the
  SYSENTER handler's first instruction as the source, which in turn would
  allow guest user mode code to crash the guest kernel.

  Inject a #GP on the fake (NULL) address of the SYSENTER instruction
  instead, just like in the case where the guest kernel didn't register
  a corresponding entry point.

  This is CVE-2013-1917 / XSA-44.

  Reported-by: Andrew Cooper <andrew.cooper3@citirx.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Tested-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>
  master commit: fdac9515607b757c044e7ef0d61b1453ef999b08
  master date: 2013-04-18 16:00:35 +0200
  fdac9515607b757c044e7ef0d61b1453ef999b08:x86: clear EFLAGS.NT in SYSENTER entry path

  ... as it causes problems if we happen to exit back via IRET: In the
  course of trying to handle the fault, the hypervisor creates a stack
  frame by hand, and uses PUSHFQ to set the respective EFLAGS field, but
  expects to be able to IRET through that stack frame to the second
  portion of the fixup code (which causes a #GP due to the stored EFLAGS
  having NT set).

  And even if this worked (e.g if we cleared NT in that path), it would
  then (through the fail safe callback) cause a #GP in the guest with the
  SYSENTER handler's first instruction as the source, which in turn would
  allow guest user mode code to crash the guest kernel.

  Inject a #GP on the fake (NULL) address of the SYSENTER instruction
  instead, just like in the case where the guest kernel didn't register
  a corresponding entry point.

  This is CVE-2013-1917 / XSA-44.

  Reported-by: Andrew Cooper <andrew.cooper3@citirx.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Tested-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 584eb7c15e4c94baaba93468776572dd7373a33c
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 68a30a91bad2d4ff1f7c0d4302ec1060d573f6da
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: fdac9515607b757c044e7ef0d61b1453ef999b08
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/584eb7c15e4c94baaba93468776572dd7373a33c
    reference_type: commit
    reference_id: 584eb7c15e4c94baaba93468776572dd7373a33c
  - url: https://github.com/xen-project/xen/tree/68a30a91bad2d4ff1f7c0d4302ec1060d573f6da
    reference_type: commit
    reference_id: 68a30a91bad2d4ff1f7c0d4302ec1060d573f6da
  - url: https://github.com/xen-project/xen/tree/fdac9515607b757c044e7ef0d61b1453ef999b08
    reference_type: commit
    reference_id: fdac9515607b757c044e7ef0d61b1453ef999b08
