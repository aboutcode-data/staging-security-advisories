advisory_id: CVE-2022-42326
datasource_id: collect_xen_project_fix_commits/CVE-2022-42326
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  377dbf9cea55a1976d0957c1f209b083c734c250:tools/xenstore: harden transaction finalization against errors

  When finalizing a transaction, any error occurring after checking for
  conflicts will result in the transaction being performed only
  partially today. Additionally accounting data will not be updated at
  the end of the transaction, which might result in further problems
  later.

  Avoid those problems by multiple modifications:

  - free any transaction specific nodes which don't need to be committed
    as they haven't been written during the transaction as soon as their
    generation count has been verified, this will reduce the risk of
    out-of-memory situations

  - store the transaction specific node name in struct accessed_node in
    order to avoid the need to allocate additional memory for it when
    finalizing the transaction

  - don't stop the transaction finalization when hitting an error
    condition, but try to continue to handle all modified nodes

  - in case of a detected error do the accounting update as needed and
    call the data base checking only after that

  - if writing a node in a transaction is failing (e.g. due to a failed
    quota check), fail the transaction, as prior changes to struct
    accessed_node can't easily be undone in that case

  This is part of XSA-421 / CVE-2022-42326.

  Signed-off-by: Juergen Gross <jgross@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  Tested-by: Julien Grall <jgrall@amazon.com>
  (cherry picked from commit 2dd823ca7237e7fb90c890642d6a3b357a26fcff)
  1c354767d58cd80224f0dfb107584bc8bd629b00:tools/xenstore: harden transaction finalization against errors

  When finalizing a transaction, any error occurring after checking for
  conflicts will result in the transaction being performed only
  partially today. Additionally accounting data will not be updated at
  the end of the transaction, which might result in further problems
  later.

  Avoid those problems by multiple modifications:

  - free any transaction specific nodes which don't need to be committed
    as they haven't been written during the transaction as soon as their
    generation count has been verified, this will reduce the risk of
    out-of-memory situations

  - store the transaction specific node name in struct accessed_node in
    order to avoid the need to allocate additional memory for it when
    finalizing the transaction

  - don't stop the transaction finalization when hitting an error
    condition, but try to continue to handle all modified nodes

  - in case of a detected error do the accounting update as needed and
    call the data base checking only after that

  - if writing a node in a transaction is failing (e.g. due to a failed
    quota check), fail the transaction, as prior changes to struct
    accessed_node can't easily be undone in that case

  This is part of XSA-421 / CVE-2022-42326.

  Signed-off-by: Juergen Gross <jgross@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  Tested-by: Julien Grall <jgrall@amazon.com>
  (cherry picked from commit 2dd823ca7237e7fb90c890642d6a3b357a26fcff)
  e818f4f0dabf83a6138cd77d7464495fab7bfc16:tools/xenstore: harden transaction finalization against errors

  When finalizing a transaction, any error occurring after checking for
  conflicts will result in the transaction being performed only
  partially today. Additionally accounting data will not be updated at
  the end of the transaction, which might result in further problems
  later.

  Avoid those problems by multiple modifications:

  - free any transaction specific nodes which don't need to be committed
    as they haven't been written during the transaction as soon as their
    generation count has been verified, this will reduce the risk of
    out-of-memory situations

  - store the transaction specific node name in struct accessed_node in
    order to avoid the need to allocate additional memory for it when
    finalizing the transaction

  - don't stop the transaction finalization when hitting an error
    condition, but try to continue to handle all modified nodes

  - in case of a detected error do the accounting update as needed and
    call the data base checking only after that

  - if writing a node in a transaction is failing (e.g. due to a failed
    quota check), fail the transaction, as prior changes to struct
    accessed_node can't easily be undone in that case

  This is part of XSA-421 / CVE-2022-42326.

  Signed-off-by: Juergen Gross <jgross@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  Tested-by: Julien Grall <jgrall@amazon.com>
  (cherry picked from commit 2dd823ca7237e7fb90c890642d6a3b357a26fcff)
  1bdd7c438b399e2ecce9e3c72bd7c1ae56df60f8:tools/xenstore: harden transaction finalization against errors

  When finalizing a transaction, any error occurring after checking for
  conflicts will result in the transaction being performed only
  partially today. Additionally accounting data will not be updated at
  the end of the transaction, which might result in further problems
  later.

  Avoid those problems by multiple modifications:

  - free any transaction specific nodes which don't need to be committed
    as they haven't been written during the transaction as soon as their
    generation count has been verified, this will reduce the risk of
    out-of-memory situations

  - store the transaction specific node name in struct accessed_node in
    order to avoid the need to allocate additional memory for it when
    finalizing the transaction

  - don't stop the transaction finalization when hitting an error
    condition, but try to continue to handle all modified nodes

  - in case of a detected error do the accounting update as needed and
    call the data base checking only after that

  - if writing a node in a transaction is failing (e.g. due to a failed
    quota check), fail the transaction, as prior changes to struct
    accessed_node can't easily be undone in that case

  This is part of XSA-421 / CVE-2022-42326.

  Signed-off-by: Juergen Gross <jgross@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  Tested-by: Julien Grall <jgrall@amazon.com>
  (cherry picked from commit 2dd823ca7237e7fb90c890642d6a3b357a26fcff)
  2dd823ca7237e7fb90c890642d6a3b357a26fcff:tools/xenstore: harden transaction finalization against errors

  When finalizing a transaction, any error occurring after checking for
  conflicts will result in the transaction being performed only
  partially today. Additionally accounting data will not be updated at
  the end of the transaction, which might result in further problems
  later.

  Avoid those problems by multiple modifications:

  - free any transaction specific nodes which don't need to be committed
    as they haven't been written during the transaction as soon as their
    generation count has been verified, this will reduce the risk of
    out-of-memory situations

  - store the transaction specific node name in struct accessed_node in
    order to avoid the need to allocate additional memory for it when
    finalizing the transaction

  - don't stop the transaction finalization when hitting an error
    condition, but try to continue to handle all modified nodes

  - in case of a detected error do the accounting update as needed and
    call the data base checking only after that

  - if writing a node in a transaction is failing (e.g. due to a failed
    quota check), fail the transaction, as prior changes to struct
    accessed_node can't easily be undone in that case

  This is part of XSA-421 / CVE-2022-42326.

  Signed-off-by: Juergen Gross <jgross@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  Tested-by: Julien Grall <jgrall@amazon.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 1c354767d58cd80224f0dfb107584bc8bd629b00
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 377dbf9cea55a1976d0957c1f209b083c734c250
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 2dd823ca7237e7fb90c890642d6a3b357a26fcff
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: e818f4f0dabf83a6138cd77d7464495fab7bfc16
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 1bdd7c438b399e2ecce9e3c72bd7c1ae56df60f8
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/1bdd7c438b399e2ecce9e3c72bd7c1ae56df60f8
    reference_type: commit
    reference_id: 1bdd7c438b399e2ecce9e3c72bd7c1ae56df60f8
  - url: https://github.com/xen-project/xen/tree/1c354767d58cd80224f0dfb107584bc8bd629b00
    reference_type: commit
    reference_id: 1c354767d58cd80224f0dfb107584bc8bd629b00
  - url: https://github.com/xen-project/xen/tree/2dd823ca7237e7fb90c890642d6a3b357a26fcff
    reference_type: commit
    reference_id: 2dd823ca7237e7fb90c890642d6a3b357a26fcff
  - url: https://github.com/xen-project/xen/tree/377dbf9cea55a1976d0957c1f209b083c734c250
    reference_type: commit
    reference_id: 377dbf9cea55a1976d0957c1f209b083c734c250
  - url: https://github.com/xen-project/xen/tree/e818f4f0dabf83a6138cd77d7464495fab7bfc16
    reference_type: commit
    reference_id: e818f4f0dabf83a6138cd77d7464495fab7bfc16
