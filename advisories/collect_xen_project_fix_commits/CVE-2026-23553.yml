advisory_id: CVE-2026-23553
datasource_id: collect_xen_project_fix_commits/CVE-2026-23553
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  36e6dcb9940bf643763fdf495a2c73ebb9ac6a07:x86/spec-ctrl: Fix incomplete IBPB flushing during context switch

  The previous logic attempted to skip an IBPB in the case of vCPU returning to
  a CPU on which it was the previous vCPU to run.  While safe for Xen's
  isolation between vCPUs, this prevents the guest kernel correctly isolation
  between tasks.  Consider:

   1) vCPU runs on CPU A, running task 1.
   2) vCPU moves to CPU B, idle gets scheduled on A.  Xen skips IBPB.
   3) On CPU B, guest kernel switches from task 1 to 2, issuing IBPB.
   4) vCPU moves back to CPU A.  Xen skips IBPB again.

  Now, task 2 is running on CPU A with task 1's training still in the BTB.

  Do the flush unconditionally when switching to a vCPU different than the
  idle one.  Note there's no need to explicitly gate the IBPB to next domain
  != idle, as the context where the IBPB is issued is subject to that
  condition already unless the pCPU is going offline, at which point we don't
  really care to issue an extra IBPB.

  Also add a comment with the reasoning why the IBPB needs to be in
  context_switch() rather than __context_switch().

  This is XSA-479 / CVE-2026-23553.

  Fixes: a2ed643ed783 ("x86/ctxt: Issue a speculation barrier between vcpu contexts")
  Reported-by: David Kaplan <david.kaplan@amd.com>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 7beadd61197a959d5fa9d310fdeb7db3148f0c0d
  master date: 2026-01-27 13:55:27 +0100
  d4775257e38c2f932f7a38bac45f6dc2525fc793:x86/spec-ctrl: Fix incomplete IBPB flushing during context switch

  The previous logic attempted to skip an IBPB in the case of vCPU returning to
  a CPU on which it was the previous vCPU to run.  While safe for Xen's
  isolation between vCPUs, this prevents the guest kernel correctly isolation
  between tasks.  Consider:

   1) vCPU runs on CPU A, running task 1.
   2) vCPU moves to CPU B, idle gets scheduled on A.  Xen skips IBPB.
   3) On CPU B, guest kernel switches from task 1 to 2, issuing IBPB.
   4) vCPU moves back to CPU A.  Xen skips IBPB again.

  Now, task 2 is running on CPU A with task 1's training still in the BTB.

  Do the flush unconditionally when switching to a vCPU different than the
  idle one.  Note there's no need to explicitly gate the IBPB to next domain
  != idle, as the context where the IBPB is issued is subject to that
  condition already unless the pCPU is going offline, at which point we don't
  really care to issue an extra IBPB.

  Also add a comment with the reasoning why the IBPB needs to be in
  context_switch() rather than __context_switch().

  This is XSA-479 / CVE-2026-23553.

  Fixes: a2ed643ed783 ("x86/ctxt: Issue a speculation barrier between vcpu contexts")
  Reported-by: David Kaplan <david.kaplan@amd.com>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 7beadd61197a959d5fa9d310fdeb7db3148f0c0d
  master date: 2026-01-27 13:55:27 +0100
  495cfdccc53895097376bad6a55b4c67b89edc6f:x86/spec-ctrl: Fix incomplete IBPB flushing during context switch

  The previous logic attempted to skip an IBPB in the case of vCPU returning to
  a CPU on which it was the previous vCPU to run.  While safe for Xen's
  isolation between vCPUs, this prevents the guest kernel correctly isolation
  between tasks.  Consider:

   1) vCPU runs on CPU A, running task 1.
   2) vCPU moves to CPU B, idle gets scheduled on A.  Xen skips IBPB.
   3) On CPU B, guest kernel switches from task 1 to 2, issuing IBPB.
   4) vCPU moves back to CPU A.  Xen skips IBPB again.

  Now, task 2 is running on CPU A with task 1's training still in the BTB.

  Do the flush unconditionally when switching to a vCPU different than the
  idle one.  Note there's no need to explicitly gate the IBPB to next domain
  != idle, as the context where the IBPB is issued is subject to that
  condition already unless the pCPU is going offline, at which point we don't
  really care to issue an extra IBPB.

  Also add a comment with the reasoning why the IBPB needs to be in
  context_switch() rather than __context_switch().

  This is XSA-479 / CVE-2026-23553.

  Fixes: a2ed643ed783 ("x86/ctxt: Issue a speculation barrier between vcpu contexts")
  Reported-by: David Kaplan <david.kaplan@amd.com>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 7beadd61197a959d5fa9d310fdeb7db3148f0c0d
  master date: 2026-01-27 13:55:27 +0100
  f48e4904ab8167ecb0ce78a165d1a446f6af9260:x86/spec-ctrl: Fix incomplete IBPB flushing during context switch

  The previous logic attempted to skip an IBPB in the case of vCPU returning to
  a CPU on which it was the previous vCPU to run.  While safe for Xen's
  isolation between vCPUs, this prevents the guest kernel correctly isolation
  between tasks.  Consider:

   1) vCPU runs on CPU A, running task 1.
   2) vCPU moves to CPU B, idle gets scheduled on A.  Xen skips IBPB.
   3) On CPU B, guest kernel switches from task 1 to 2, issuing IBPB.
   4) vCPU moves back to CPU A.  Xen skips IBPB again.

  Now, task 2 is running on CPU A with task 1's training still in the BTB.

  Do the flush unconditionally when switching to a vCPU different than the
  idle one.  Note there's no need to explicitly gate the IBPB to next domain
  != idle, as the context where the IBPB is issued is subject to that
  condition already unless the pCPU is going offline, at which point we don't
  really care to issue an extra IBPB.

  Also add a comment with the reasoning why the IBPB needs to be in
  context_switch() rather than __context_switch().

  This is XSA-479 / CVE-2026-23553.

  Fixes: a2ed643ed783 ("x86/ctxt: Issue a speculation barrier between vcpu contexts")
  Reported-by: David Kaplan <david.kaplan@amd.com>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 7beadd61197a959d5fa9d310fdeb7db3148f0c0d
  master date: 2026-01-27 13:55:27 +0100
  3146587dbc489cce60cae471fd63ef822b5c05a4:x86/spec-ctrl: Fix incomplete IBPB flushing during context switch

  The previous logic attempted to skip an IBPB in the case of vCPU returning to
  a CPU on which it was the previous vCPU to run.  While safe for Xen's
  isolation between vCPUs, this prevents the guest kernel correctly isolation
  between tasks.  Consider:

   1) vCPU runs on CPU A, running task 1.
   2) vCPU moves to CPU B, idle gets scheduled on A.  Xen skips IBPB.
   3) On CPU B, guest kernel switches from task 1 to 2, issuing IBPB.
   4) vCPU moves back to CPU A.  Xen skips IBPB again.

  Now, task 2 is running on CPU A with task 1's training still in the BTB.

  Do the flush unconditionally when switching to a vCPU different than the
  idle one.  Note there's no need to explicitly gate the IBPB to next domain
  != idle, as the context where the IBPB is issued is subject to that
  condition already unless the pCPU is going offline, at which point we don't
  really care to issue an extra IBPB.

  Also add a comment with the reasoning why the IBPB needs to be in
  context_switch() rather than __context_switch().

  This is XSA-479 / CVE-2026-23553.

  Fixes: a2ed643ed783 ("x86/ctxt: Issue a speculation barrier between vcpu contexts")
  Reported-by: David Kaplan <david.kaplan@amd.com>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 7beadd61197a959d5fa9d310fdeb7db3148f0c0d
  master date: 2026-01-27 13:55:27 +0100
  7beadd61197a959d5fa9d310fdeb7db3148f0c0d:x86/spec-ctrl: Fix incomplete IBPB flushing during context switch

  The previous logic attempted to skip an IBPB in the case of vCPU returning to
  a CPU on which it was the previous vCPU to run.  While safe for Xen's
  isolation between vCPUs, this prevents the guest kernel correctly isolation
  between tasks.  Consider:

   1) vCPU runs on CPU A, running task 1.
   2) vCPU moves to CPU B, idle gets scheduled on A.  Xen skips IBPB.
   3) On CPU B, guest kernel switches from task 1 to 2, issuing IBPB.
   4) vCPU moves back to CPU A.  Xen skips IBPB again.

  Now, task 2 is running on CPU A with task 1's training still in the BTB.

  Do the flush unconditionally when switching to a vCPU different than the
  idle one.  Note there's no need to explicitly gate the IBPB to next domain
  != idle, as the context where the IBPB is issued is subject to that
  condition already unless the pCPU is going offline, at which point we don't
  really care to issue an extra IBPB.

  Also add a comment with the reasoning why the IBPB needs to be in
  context_switch() rather than __context_switch().

  This is XSA-479 / CVE-2026-23553.

  Fixes: a2ed643ed783 ("x86/ctxt: Issue a speculation barrier between vcpu contexts")
  Reported-by: David Kaplan <david.kaplan@amd.com>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 3146587dbc489cce60cae471fd63ef822b5c05a4
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: f48e4904ab8167ecb0ce78a165d1a446f6af9260
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 7beadd61197a959d5fa9d310fdeb7db3148f0c0d
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 36e6dcb9940bf643763fdf495a2c73ebb9ac6a07
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: d4775257e38c2f932f7a38bac45f6dc2525fc793
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 495cfdccc53895097376bad6a55b4c67b89edc6f
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/3146587dbc489cce60cae471fd63ef822b5c05a4
    reference_type: commit
    reference_id: 3146587dbc489cce60cae471fd63ef822b5c05a4
  - url: https://github.com/xen-project/xen/tree/36e6dcb9940bf643763fdf495a2c73ebb9ac6a07
    reference_type: commit
    reference_id: 36e6dcb9940bf643763fdf495a2c73ebb9ac6a07
  - url: https://github.com/xen-project/xen/tree/495cfdccc53895097376bad6a55b4c67b89edc6f
    reference_type: commit
    reference_id: 495cfdccc53895097376bad6a55b4c67b89edc6f
  - url: https://github.com/xen-project/xen/tree/7beadd61197a959d5fa9d310fdeb7db3148f0c0d
    reference_type: commit
    reference_id: 7beadd61197a959d5fa9d310fdeb7db3148f0c0d
  - url: https://github.com/xen-project/xen/tree/d4775257e38c2f932f7a38bac45f6dc2525fc793
    reference_type: commit
    reference_id: d4775257e38c2f932f7a38bac45f6dc2525fc793
  - url: https://github.com/xen-project/xen/tree/f48e4904ab8167ecb0ce78a165d1a446f6af9260
    reference_type: commit
    reference_id: f48e4904ab8167ecb0ce78a165d1a446f6af9260
