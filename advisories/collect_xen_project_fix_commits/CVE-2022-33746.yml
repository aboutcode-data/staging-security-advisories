advisory_id: CVE-2022-33746
datasource_id: collect_xen_project_fix_commits/CVE-2022-33746
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  eed4ef4177b8267f2b6f403db00ed393a371285f:xen/x86: p2m: Add preemption in p2m_teardown()

  The list p2m->pages contain all the pages used by the P2M. On large
  instance this can be quite large and the time spent to call
  d->arch.paging.free_page() will take more than 1ms for a 80GB guest
  on a Xen running in nested environment on a c5.metal.

  By extrapolation, it would take > 100ms for a 8TB guest (what we
  current security support). So add some preemption in p2m_teardown()
  and propagate to the callers. Note there are 3 places where
  the preemption is not enabled:
      - hap_final_teardown()/shadow_final_teardown(): We are
        preventing update the P2M once the domain is dying (so
        no more pages could be allocated) and most of the P2M pages
        will be freed in preemptive manneer when relinquishing the
        resources. So this is fine to disable preemption.
      - shadow_enable(): This is fine because it will undo the allocation
        that may have been made by p2m_alloc_table() (so only the root
        page table).

  The preemption is arbitrarily checked every 1024 iterations.

  We now need to include <xen/event.h> in p2m-basic in order to
  import the definition for local_events_need_delivery() used by
  general_preempt_check(). Ideally, the inclusion should happen in
  xen/sched.h but it opened a can of worms.

  Note that with the current approach, Xen doesn't keep track on whether
  the alt/nested P2Ms have been cleared. So there are some redundant work.
  However, this is not expected to incurr too much overhead (the P2M lock
  shouldn't be contended during teardown). So this is optimization is
  left outside of the security event.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  master commit: 8a2111250b424edc49c65c4d41b276766d30635c
  master date: 2022-10-11 14:24:48 +0200
  3e7aa35a56f9e9b42c74724c4083026da8ac9bcd:x86/p2m: free the paging memory pool preemptively

  The paging memory pool is currently freed in two different places:
  from {shadow,hap}_teardown() via domain_relinquish_resources() and
  from {shadow,hap}_final_teardown() via complete_domain_destroy().
  While the former does handle preemption, the later doesn't.

  Attempt to move as much p2m related freeing as possible to happen
  before the call to {shadow,hap}_teardown(), so that most memory can be
  freed in a preemptive way.  In order to avoid causing issues to
  existing callers leave the root p2m page tables set and free them in
  {hap,shadow}_final_teardown().  Also modify {hap,shadow}_free to free
  the page immediately if the domain is dying, so that pages don't
  accumulate in the pool when {shadow,hap}_final_teardown() get called.

  Move altp2m_vcpu_disable_ve() to be done in hap_teardown(), as that's
  the place where altp2m_active gets disabled now.

  This is part of CVE-2022-33746 / XSA-410.

  Reported-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: e7aa55c0aab36d994bf627c92bd5386ae167e16e
  master date: 2022-10-11 14:24:21 +0200
  6e537d36943e5b99afe6194b7fc147610bcf9fba:x86/p2m: truly free paging pool memory for dying domains

  Modify {hap,shadow}_free to free the page immediately if the domain is
  dying, so that pages don't accumulate in the pool when
  {shadow,hap}_final_teardown() get called. This is to limit the amount of
  work which needs to be done there (in a non-preemptable manner).

  Note the call to shadow_free() in shadow_free_p2m_page() is moved after
  increasing total_pages, so that the decrease done in shadow_free() in
  case the domain is dying doesn't underflow the counter, even if just for
  a short interval.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: f50a2c0e1d057c00d6061f40ae24d068226052ad
  master date: 2022-10-11 14:23:51 +0200
  08eec20dc0550316dad64cdc63fee2371702f31f:x86/p2m: refuse new allocations for dying domains

  This will in particular prevent any attempts to add entries to the p2m,
  once - in a subsequent change - non-root entries have been removed.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: ff600a8cf8e36f8ecbffecf96a035952e022ab87
  master date: 2022-10-11 14:23:22 +0200
  181ff7aced0e2afec4cfa57e015d01e0a0b3be59:x86/shadow: tolerate failure in shadow_prealloc()

  Prevent _shadow_prealloc() from calling BUG() when unable to fulfill
  the pre-allocation and instead return true/false.  Modify
  shadow_prealloc() to crash the domain on allocation failure (if the
  domain is not already dying), as shadow cannot operate normally after
  that.  Modify callers to also gracefully handle {_,}shadow_prealloc()
  failing to fulfill the request.

  Note this in turn requires adjusting the callers of
  sh_make_monitor_table() also to handle it returning INVALID_MFN.
  sh_update_paging_modes() is also modified to add additional error
  paths in case of allocation failure, some of those will return with
  null monitor page tables (and the domain likely crashed).  This is no
  different that current error paths, but the newly introduced ones are
  more likely to trigger.

  The now added failure points in sh_update_paging_modes() also require
  that on some error return paths the previous structures are cleared,
  and thus monitor table is null.

  While there adjust the 'type' parameter type of shadow_prealloc() to
  unsigned int rather than u32.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: b7f93c6afb12b6061e2d19de2f39ea09b569ac68
  master date: 2022-10-11 14:22:53 +0200
  aa7891098cc46a7a11b2d823cd8386be8b04c453:x86/shadow: tolerate failure of sh_set_toplevel_shadow()

  Subsequently sh_set_toplevel_shadow() will be adjusted to install a
  blank entry in case prealloc fails. There are, in fact, pre-existing
  error paths which would put in place a blank entry. The 4- and 2-level
  code in sh_update_cr3(), however, assume the top level entry to be
  valid.

  Hence bail from the function in the unlikely event that it's not. Note
  that 3-level logic works differently: In particular a guest is free to
  supply a PDPTR pointing at 4 non-present (or otherwise deemed invalid)
  entries. The guest will crash, but we already cope with that.

  Really mfn_valid() is likely wrong to use in sh_set_toplevel_shadow(),
  and it should instead be !mfn_eq(gmfn, INVALID_MFN). Avoid such a change
  in security context, but add a respective assertion.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
  master commit: eac000978c1feb5a9ee3236ab0c0da9a477e5336
  master date: 2022-10-11 14:22:24 +0200
  0021c269786e0442d6f922d110d957867fff421d:x86/HAP: adjust monitor table related error handling

  hap_make_monitor_table() will return INVALID_MFN if it encounters an
  error condition, but hap_update_paging_modes() wasn’t handling this
  value, resulting in an inappropriate value being stored in
  monitor_table. This would subsequently misguide at least
  hap_vcpu_teardown(). Avoid this by bailing early.

  Further, when a domain has/was already crashed or (perhaps less
  important as there's no such path known to lead here) is already dying,
  avoid calling domain_crash() on it again - that's at best confusing.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  master commit: 5b44a61180f4f2e4f490a28400c884dd357ff45d
  master date: 2022-10-11 14:21:56 +0200
  763f965d04c5eb01890f697aaaaa9120d552672a:x86/p2m: add option to skip root pagetable removal in p2m_teardown()

  Add a new parameter to p2m_teardown() in order to select whether the
  root page table should also be freed.  Note that all users are
  adjusted to pass the parameter to remove the root page tables, so
  behavior is not modified.

  No functional change intended.

  This is part of CVE-2022-33746 / XSA-410.

  Suggested-by: Julien Grall <julien@xen.org>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: 1df52a270225527ae27bfa2fc40347bf93b78357
  master date: 2022-10-11 14:21:23 +0200
  4e38cc1baea00384b208b762bccc624b0e070fed:xen/arm: p2m: Handle preemption when freeing intermediate page tables

  At the moment the P2M page tables will be freed when the domain structure
  is freed without any preemption. As the P2M is quite large, iterating
  through this may take more time than it is reasonable without intermediate
  preemption (to run softirqs and perhaps scheduler).

  Split p2m_teardown() in two parts: one preemptible and called when
  relinquishing the resources, the other one non-preemptible and called
  when freeing the domain structure.

  As we are now freeing the P2M pages early, we also need to prevent
  further allocation if someone call p2m_set_entry() past p2m_teardown()
  (I wasn't able to prove this will never happen). This is done by
  the checking domain->is_dying from previous patch in p2m_set_entry().

  Similarly, we want to make sure that no-one can accessed the free
  pages. Therefore the root is cleared before freeing pages.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Henry Wang <Henry.Wang@arm.com>
  Tested-by: Henry Wang <Henry.Wang@arm.com>
  Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
  master commit: 3202084566bba0ef0c45caf8c24302f83d92f9c8
  master date: 2022-10-11 14:20:56 +0200
  5475195ec490a1cbe226ebe7b709119928673cc8:xen/arm: p2m: Prevent adding mapping when domain is dying

  During the domain destroy process, the domain will still be accessible
  until it is fully destroyed. So does the P2M because we don't bail
  out early if is_dying is non-zero. If a domain has permission to
  modify the other domain's P2M (i.e. dom0, or a stubdomain), then
  foreign mapping can be added past relinquish_p2m_mapping().

  Therefore, we need to prevent mapping to be added when the domain
  is dying. This commit prevents such adding of mapping by adding the
  d->is_dying check to p2m_set_entry(). Also this commit enhances the
  check in relinquish_p2m_mapping() to make sure that no mappings can
  be added in the P2M after the P2M lock is released.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Henry Wang <Henry.Wang@arm.com>
  Tested-by: Henry Wang <Henry.Wang@arm.com>
  Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
  master commit: 3ebe773293e3b945460a3d6f54f3b91915397bab
  master date: 2022-10-11 14:20:18 +0200
  804f83bfba8e73ed99a2f839c6731fa2aa9fb7bb:xen/x86: p2m: Add preemption in p2m_teardown()

  The list p2m->pages contain all the pages used by the P2M. On large
  instance this can be quite large and the time spent to call
  d->arch.paging.free_page() will take more than 1ms for a 80GB guest
  on a Xen running in nested environment on a c5.metal.

  By extrapolation, it would take > 100ms for a 8TB guest (what we
  current security support). So add some preemption in p2m_teardown()
  and propagate to the callers. Note there are 3 places where
  the preemption is not enabled:
      - hap_final_teardown()/shadow_final_teardown(): We are
        preventing update the P2M once the domain is dying (so
        no more pages could be allocated) and most of the P2M pages
        will be freed in preemptive manneer when relinquishing the
        resources. So this is fine to disable preemption.
      - shadow_enable(): This is fine because it will undo the allocation
        that may have been made by p2m_alloc_table() (so only the root
        page table).

  The preemption is arbitrarily checked every 1024 iterations.

  We now need to include <xen/event.h> in p2m-basic in order to
  import the definition for local_events_need_delivery() used by
  general_preempt_check(). Ideally, the inclusion should happen in
  xen/sched.h but it opened a can of worms.

  Note that with the current approach, Xen doesn't keep track on whether
  the alt/nested P2Ms have been cleared. So there are some redundant work.
  However, this is not expected to incurr too much overhead (the P2M lock
  shouldn't be contended during teardown). So this is optimization is
  left outside of the security event.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  master commit: 8a2111250b424edc49c65c4d41b276766d30635c
  master date: 2022-10-11 14:24:48 +0200
  f90615ce03c14b5288bdacd796ada23b4e9d0f7b:x86/p2m: free the paging memory pool preemptively

  The paging memory pool is currently freed in two different places:
  from {shadow,hap}_teardown() via domain_relinquish_resources() and
  from {shadow,hap}_final_teardown() via complete_domain_destroy().
  While the former does handle preemption, the later doesn't.

  Attempt to move as much p2m related freeing as possible to happen
  before the call to {shadow,hap}_teardown(), so that most memory can be
  freed in a preemptive way.  In order to avoid causing issues to
  existing callers leave the root p2m page tables set and free them in
  {hap,shadow}_final_teardown().  Also modify {hap,shadow}_free to free
  the page immediately if the domain is dying, so that pages don't
  accumulate in the pool when {shadow,hap}_final_teardown() get called.

  Move altp2m_vcpu_disable_ve() to be done in hap_teardown(), as that's
  the place where altp2m_active gets disabled now.

  This is part of CVE-2022-33746 / XSA-410.

  Reported-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: e7aa55c0aab36d994bf627c92bd5386ae167e16e
  master date: 2022-10-11 14:24:21 +0200
  fc1098471822d80a35c6f1ac1ec8c7b45caf6eab:x86/p2m: truly free paging pool memory for dying domains

  Modify {hap,shadow}_free to free the page immediately if the domain is
  dying, so that pages don't accumulate in the pool when
  {shadow,hap}_final_teardown() get called. This is to limit the amount of
  work which needs to be done there (in a non-preemptable manner).

  Note the call to shadow_free() in shadow_free_p2m_page() is moved after
  increasing total_pages, so that the decrease done in shadow_free() in
  case the domain is dying doesn't underflow the counter, even if just for
  a short interval.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: f50a2c0e1d057c00d6061f40ae24d068226052ad
  master date: 2022-10-11 14:23:51 +0200
  9b5a7fd916a74295886a7d473c311e3c7e254e54:x86/p2m: refuse new allocations for dying domains

  This will in particular prevent any attempts to add entries to the p2m,
  once - in a subsequent change - non-root entries have been removed.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: ff600a8cf8e36f8ecbffecf96a035952e022ab87
  master date: 2022-10-11 14:23:22 +0200
  b8f4a5de683efbe402db65483d845573c30dbb3f:x86/shadow: tolerate failure in shadow_prealloc()

  Prevent _shadow_prealloc() from calling BUG() when unable to fulfill
  the pre-allocation and instead return true/false.  Modify
  shadow_prealloc() to crash the domain on allocation failure (if the
  domain is not already dying), as shadow cannot operate normally after
  that.  Modify callers to also gracefully handle {_,}shadow_prealloc()
  failing to fulfill the request.

  Note this in turn requires adjusting the callers of
  sh_make_monitor_table() also to handle it returning INVALID_MFN.
  sh_update_paging_modes() is also modified to add additional error
  paths in case of allocation failure, some of those will return with
  null monitor page tables (and the domain likely crashed).  This is no
  different that current error paths, but the newly introduced ones are
  more likely to trigger.

  The now added failure points in sh_update_paging_modes() also require
  that on some error return paths the previous structures are cleared,
  and thus monitor table is null.

  While there adjust the 'type' parameter type of shadow_prealloc() to
  unsigned int rather than u32.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: b7f93c6afb12b6061e2d19de2f39ea09b569ac68
  master date: 2022-10-11 14:22:53 +0200
  0bab3abf73783da66af8cf7cf7aabb7d86caa035:x86/shadow: tolerate failure of sh_set_toplevel_shadow()

  Subsequently sh_set_toplevel_shadow() will be adjusted to install a
  blank entry in case prealloc fails. There are, in fact, pre-existing
  error paths which would put in place a blank entry. The 4- and 2-level
  code in sh_update_cr3(), however, assume the top level entry to be
  valid.

  Hence bail from the function in the unlikely event that it's not. Note
  that 3-level logic works differently: In particular a guest is free to
  supply a PDPTR pointing at 4 non-present (or otherwise deemed invalid)
  entries. The guest will crash, but we already cope with that.

  Really mfn_valid() is likely wrong to use in sh_set_toplevel_shadow(),
  and it should instead be !mfn_eq(gmfn, INVALID_MFN). Avoid such a change
  in security context, but add a respective assertion.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
  master commit: eac000978c1feb5a9ee3236ab0c0da9a477e5336
  master date: 2022-10-11 14:22:24 +0200
  3163e34f6abad70160711ef60c21645355f509fb:x86/HAP: adjust monitor table related error handling

  hap_make_monitor_table() will return INVALID_MFN if it encounters an
  error condition, but hap_update_paging_modes() wasn’t handling this
  value, resulting in an inappropriate value being stored in
  monitor_table. This would subsequently misguide at least
  hap_vcpu_teardown(). Avoid this by bailing early.

  Further, when a domain has/was already crashed or (perhaps less
  important as there's no such path known to lead here) is already dying,
  avoid calling domain_crash() on it again - that's at best confusing.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  master commit: 5b44a61180f4f2e4f490a28400c884dd357ff45d
  master date: 2022-10-11 14:21:56 +0200
  54b6eab0e4450a39ebe11b8f2faeaeb09c6e774a:x86/p2m: add option to skip root pagetable removal in p2m_teardown()

  Add a new parameter to p2m_teardown() in order to select whether the
  root page table should also be freed.  Note that all users are
  adjusted to pass the parameter to remove the root page tables, so
  behavior is not modified.

  No functional change intended.

  This is part of CVE-2022-33746 / XSA-410.

  Suggested-by: Julien Grall <julien@xen.org>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: 1df52a270225527ae27bfa2fc40347bf93b78357
  master date: 2022-10-11 14:21:23 +0200
  9c975e636ed2782d4fd8b2b76126bdfb81f386cc:xen/arm: p2m: Handle preemption when freeing intermediate page tables

  At the moment the P2M page tables will be freed when the domain structure
  is freed without any preemption. As the P2M is quite large, iterating
  through this may take more time than it is reasonable without intermediate
  preemption (to run softirqs and perhaps scheduler).

  Split p2m_teardown() in two parts: one preemptible and called when
  relinquishing the resources, the other one non-preemptible and called
  when freeing the domain structure.

  As we are now freeing the P2M pages early, we also need to prevent
  further allocation if someone call p2m_set_entry() past p2m_teardown()
  (I wasn't able to prove this will never happen). This is done by
  the checking domain->is_dying from previous patch in p2m_set_entry().

  Similarly, we want to make sure that no-one can accessed the free
  pages. Therefore the root is cleared before freeing pages.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Henry Wang <Henry.Wang@arm.com>
  Tested-by: Henry Wang <Henry.Wang@arm.com>
  Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
  master commit: 3202084566bba0ef0c45caf8c24302f83d92f9c8
  master date: 2022-10-11 14:20:56 +0200
  7a7406ba1d8912719eb7c9eec2d7cd34f49dfac0:xen/arm: p2m: Prevent adding mapping when domain is dying

  During the domain destroy process, the domain will still be accessible
  until it is fully destroyed. So does the P2M because we don't bail
  out early if is_dying is non-zero. If a domain has permission to
  modify the other domain's P2M (i.e. dom0, or a stubdomain), then
  foreign mapping can be added past relinquish_p2m_mapping().

  Therefore, we need to prevent mapping to be added when the domain
  is dying. This commit prevents such adding of mapping by adding the
  d->is_dying check to p2m_set_entry(). Also this commit enhances the
  check in relinquish_p2m_mapping() to make sure that no mappings can
  be added in the P2M after the P2M lock is released.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Henry Wang <Henry.Wang@arm.com>
  Tested-by: Henry Wang <Henry.Wang@arm.com>
  Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
  master commit: 3ebe773293e3b945460a3d6f54f3b91915397bab
  master date: 2022-10-11 14:20:18 +0200
  b03074bb47d10c9373688b3661c7c31da01c21a3:xen/x86: p2m: Add preemption in p2m_teardown()

  The list p2m->pages contain all the pages used by the P2M. On large
  instance this can be quite large and the time spent to call
  d->arch.paging.free_page() will take more than 1ms for a 80GB guest
  on a Xen running in nested environment on a c5.metal.

  By extrapolation, it would take > 100ms for a 8TB guest (what we
  current security support). So add some preemption in p2m_teardown()
  and propagate to the callers. Note there are 3 places where
  the preemption is not enabled:
      - hap_final_teardown()/shadow_final_teardown(): We are
        preventing update the P2M once the domain is dying (so
        no more pages could be allocated) and most of the P2M pages
        will be freed in preemptive manneer when relinquishing the
        resources. So this is fine to disable preemption.
      - shadow_enable(): This is fine because it will undo the allocation
        that may have been made by p2m_alloc_table() (so only the root
        page table).

  The preemption is arbitrarily checked every 1024 iterations.

  We now need to include <xen/event.h> in p2m-basic in order to
  import the definition for local_events_need_delivery() used by
  general_preempt_check(). Ideally, the inclusion should happen in
  xen/sched.h but it opened a can of worms.

  Note that with the current approach, Xen doesn't keep track on whether
  the alt/nested P2Ms have been cleared. So there are some redundant work.
  However, this is not expected to incurr too much overhead (the P2M lock
  shouldn't be contended during teardown). So this is optimization is
  left outside of the security event.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  master commit: 8a2111250b424edc49c65c4d41b276766d30635c
  master date: 2022-10-11 14:24:48 +0200
  686c920fa9389fe2b6b619643024ed98b4b7d51f:x86/p2m: free the paging memory pool preemptively

  The paging memory pool is currently freed in two different places:
  from {shadow,hap}_teardown() via domain_relinquish_resources() and
  from {shadow,hap}_final_teardown() via complete_domain_destroy().
  While the former does handle preemption, the later doesn't.

  Attempt to move as much p2m related freeing as possible to happen
  before the call to {shadow,hap}_teardown(), so that most memory can be
  freed in a preemptive way.  In order to avoid causing issues to
  existing callers leave the root p2m page tables set and free them in
  {hap,shadow}_final_teardown().  Also modify {hap,shadow}_free to free
  the page immediately if the domain is dying, so that pages don't
  accumulate in the pool when {shadow,hap}_final_teardown() get called.

  Move altp2m_vcpu_disable_ve() to be done in hap_teardown(), as that's
  the place where altp2m_active gets disabled now.

  This is part of CVE-2022-33746 / XSA-410.

  Reported-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: e7aa55c0aab36d994bf627c92bd5386ae167e16e
  master date: 2022-10-11 14:24:21 +0200
  7f055b011a657f8f16b0df242301efb312058eea:x86/p2m: truly free paging pool memory for dying domains

  Modify {hap,shadow}_free to free the page immediately if the domain is
  dying, so that pages don't accumulate in the pool when
  {shadow,hap}_final_teardown() get called. This is to limit the amount of
  work which needs to be done there (in a non-preemptable manner).

  Note the call to shadow_free() in shadow_free_p2m_page() is moved after
  increasing total_pages, so that the decrease done in shadow_free() in
  case the domain is dying doesn't underflow the counter, even if just for
  a short interval.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: f50a2c0e1d057c00d6061f40ae24d068226052ad
  master date: 2022-10-11 14:23:51 +0200
  4f9b535194f70582863f2a78f113547d8822b2b9:x86/p2m: refuse new allocations for dying domains

  This will in particular prevent any attempts to add entries to the p2m,
  once - in a subsequent change - non-root entries have been removed.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: ff600a8cf8e36f8ecbffecf96a035952e022ab87
  master date: 2022-10-11 14:23:22 +0200
  1e26afa846fb9a00b9155280eeae3b8cb8375dd6:x86/shadow: tolerate failure in shadow_prealloc()

  Prevent _shadow_prealloc() from calling BUG() when unable to fulfill
  the pre-allocation and instead return true/false.  Modify
  shadow_prealloc() to crash the domain on allocation failure (if the
  domain is not already dying), as shadow cannot operate normally after
  that.  Modify callers to also gracefully handle {_,}shadow_prealloc()
  failing to fulfill the request.

  Note this in turn requires adjusting the callers of
  sh_make_monitor_table() also to handle it returning INVALID_MFN.
  sh_update_paging_modes() is also modified to add additional error
  paths in case of allocation failure, some of those will return with
  null monitor page tables (and the domain likely crashed).  This is no
  different that current error paths, but the newly introduced ones are
  more likely to trigger.

  The now added failure points in sh_update_paging_modes() also require
  that on some error return paths the previous structures are cleared,
  and thus monitor table is null.

  While there adjust the 'type' parameter type of shadow_prealloc() to
  unsigned int rather than u32.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: b7f93c6afb12b6061e2d19de2f39ea09b569ac68
  master date: 2022-10-11 14:22:53 +0200
  95f6d555ec84383f7daaf3374f65bec5ff4351f5:x86/shadow: tolerate failure of sh_set_toplevel_shadow()

  Subsequently sh_set_toplevel_shadow() will be adjusted to install a
  blank entry in case prealloc fails. There are, in fact, pre-existing
  error paths which would put in place a blank entry. The 4- and 2-level
  code in sh_update_cr3(), however, assume the top level entry to be
  valid.

  Hence bail from the function in the unlikely event that it's not. Note
  that 3-level logic works differently: In particular a guest is free to
  supply a PDPTR pointing at 4 non-present (or otherwise deemed invalid)
  entries. The guest will crash, but we already cope with that.

  Really mfn_valid() is likely wrong to use in sh_set_toplevel_shadow(),
  and it should instead be !mfn_eq(gmfn, INVALID_MFN). Avoid such a change
  in security context, but add a respective assertion.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
  master commit: eac000978c1feb5a9ee3236ab0c0da9a477e5336
  master date: 2022-10-11 14:22:24 +0200
  d24a10a91d46a56e1d406239643ec651a31033d4:x86/HAP: adjust monitor table related error handling

  hap_make_monitor_table() will return INVALID_MFN if it encounters an
  error condition, but hap_update_paging_modes() wasn’t handling this
  value, resulting in an inappropriate value being stored in
  monitor_table. This would subsequently misguide at least
  hap_vcpu_teardown(). Avoid this by bailing early.

  Further, when a domain has/was already crashed or (perhaps less
  important as there's no such path known to lead here) is already dying,
  avoid calling domain_crash() on it again - that's at best confusing.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  master commit: 5b44a61180f4f2e4f490a28400c884dd357ff45d
  master date: 2022-10-11 14:21:56 +0200
  0f3eab90f327210d91e8e31a769376f286e8819a:x86/p2m: add option to skip root pagetable removal in p2m_teardown()

  Add a new parameter to p2m_teardown() in order to select whether the
  root page table should also be freed.  Note that all users are
  adjusted to pass the parameter to remove the root page tables, so
  behavior is not modified.

  No functional change intended.

  This is part of CVE-2022-33746 / XSA-410.

  Suggested-by: Julien Grall <julien@xen.org>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: 1df52a270225527ae27bfa2fc40347bf93b78357
  master date: 2022-10-11 14:21:23 +0200
  0d805f9fba4bc155d15047685024f7d842e925e4:xen/arm: p2m: Handle preemption when freeing intermediate page tables

  At the moment the P2M page tables will be freed when the domain structure
  is freed without any preemption. As the P2M is quite large, iterating
  through this may take more time than it is reasonable without intermediate
  preemption (to run softirqs and perhaps scheduler).

  Split p2m_teardown() in two parts: one preemptible and called when
  relinquishing the resources, the other one non-preemptible and called
  when freeing the domain structure.

  As we are now freeing the P2M pages early, we also need to prevent
  further allocation if someone call p2m_set_entry() past p2m_teardown()
  (I wasn't able to prove this will never happen). This is done by
  the checking domain->is_dying from previous patch in p2m_set_entry().

  Similarly, we want to make sure that no-one can accessed the free
  pages. Therefore the root is cleared before freeing pages.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Henry Wang <Henry.Wang@arm.com>
  Tested-by: Henry Wang <Henry.Wang@arm.com>
  Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
  master commit: 3202084566bba0ef0c45caf8c24302f83d92f9c8
  master date: 2022-10-11 14:20:56 +0200
  09fc590c15773c2471946a78740c6b02e8c34a45:xen/arm: p2m: Prevent adding mapping when domain is dying

  During the domain destroy process, the domain will still be accessible
  until it is fully destroyed. So does the P2M because we don't bail
  out early if is_dying is non-zero. If a domain has permission to
  modify the other domain's P2M (i.e. dom0, or a stubdomain), then
  foreign mapping can be added past relinquish_p2m_mapping().

  Therefore, we need to prevent mapping to be added when the domain
  is dying. This commit prevents such adding of mapping by adding the
  d->is_dying check to p2m_set_entry(). Also this commit enhances the
  check in relinquish_p2m_mapping() to make sure that no mappings can
  be added in the P2M after the P2M lock is released.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Henry Wang <Henry.Wang@arm.com>
  Tested-by: Henry Wang <Henry.Wang@arm.com>
  Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
  master commit: 3ebe773293e3b945460a3d6f54f3b91915397bab
  master date: 2022-10-11 14:20:18 +0200
  a603386b422f5cb4c5e2639a7e20a1d99dba2175:xen/x86: p2m: Add preemption in p2m_teardown()

  The list p2m->pages contain all the pages used by the P2M. On large
  instance this can be quite large and the time spent to call
  d->arch.paging.free_page() will take more than 1ms for a 80GB guest
  on a Xen running in nested environment on a c5.metal.

  By extrapolation, it would take > 100ms for a 8TB guest (what we
  current security support). So add some preemption in p2m_teardown()
  and propagate to the callers. Note there are 3 places where
  the preemption is not enabled:
      - hap_final_teardown()/shadow_final_teardown(): We are
        preventing update the P2M once the domain is dying (so
        no more pages could be allocated) and most of the P2M pages
        will be freed in preemptive manneer when relinquishing the
        resources. So this is fine to disable preemption.
      - shadow_enable(): This is fine because it will undo the allocation
        that may have been made by p2m_alloc_table() (so only the root
        page table).

  The preemption is arbitrarily checked every 1024 iterations.

  We now need to include <xen/event.h> in p2m-basic in order to
  import the definition for local_events_need_delivery() used by
  general_preempt_check(). Ideally, the inclusion should happen in
  xen/sched.h but it opened a can of worms.

  Note that with the current approach, Xen doesn't keep track on whether
  the alt/nested P2Ms have been cleared. So there are some redundant work.
  However, this is not expected to incurr too much overhead (the P2M lock
  shouldn't be contended during teardown). So this is optimization is
  left outside of the security event.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  master commit: 8a2111250b424edc49c65c4d41b276766d30635c
  master date: 2022-10-11 14:24:48 +0200
  f5959ed715e19cf2844656477dbf74c2f576c9d4:x86/p2m: free the paging memory pool preemptively

  The paging memory pool is currently freed in two different places:
  from {shadow,hap}_teardown() via domain_relinquish_resources() and
  from {shadow,hap}_final_teardown() via complete_domain_destroy().
  While the former does handle preemption, the later doesn't.

  Attempt to move as much p2m related freeing as possible to happen
  before the call to {shadow,hap}_teardown(), so that most memory can be
  freed in a preemptive way.  In order to avoid causing issues to
  existing callers leave the root p2m page tables set and free them in
  {hap,shadow}_final_teardown().  Also modify {hap,shadow}_free to free
  the page immediately if the domain is dying, so that pages don't
  accumulate in the pool when {shadow,hap}_final_teardown() get called.

  Move altp2m_vcpu_disable_ve() to be done in hap_teardown(), as that's
  the place where altp2m_active gets disabled now.

  This is part of CVE-2022-33746 / XSA-410.

  Reported-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: e7aa55c0aab36d994bf627c92bd5386ae167e16e
  master date: 2022-10-11 14:24:21 +0200
  943635d8f8486209e4e48966507ad57963e96284:x86/p2m: truly free paging pool memory for dying domains

  Modify {hap,shadow}_free to free the page immediately if the domain is
  dying, so that pages don't accumulate in the pool when
  {shadow,hap}_final_teardown() get called. This is to limit the amount of
  work which needs to be done there (in a non-preemptable manner).

  Note the call to shadow_free() in shadow_free_p2m_page() is moved after
  increasing total_pages, so that the decrease done in shadow_free() in
  case the domain is dying doesn't underflow the counter, even if just for
  a short interval.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: f50a2c0e1d057c00d6061f40ae24d068226052ad
  master date: 2022-10-11 14:23:51 +0200
  745e0b300dc3f5000e6d48c273b405d4bcc29ba7:x86/p2m: refuse new allocations for dying domains

  This will in particular prevent any attempts to add entries to the p2m,
  once - in a subsequent change - non-root entries have been removed.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: ff600a8cf8e36f8ecbffecf96a035952e022ab87
  master date: 2022-10-11 14:23:22 +0200
  28d3f677ec97c98154311f64871ac48762cf980a:x86/shadow: tolerate failure in shadow_prealloc()

  Prevent _shadow_prealloc() from calling BUG() when unable to fulfill
  the pre-allocation and instead return true/false.  Modify
  shadow_prealloc() to crash the domain on allocation failure (if the
  domain is not already dying), as shadow cannot operate normally after
  that.  Modify callers to also gracefully handle {_,}shadow_prealloc()
  failing to fulfill the request.

  Note this in turn requires adjusting the callers of
  sh_make_monitor_table() also to handle it returning INVALID_MFN.
  sh_update_paging_modes() is also modified to add additional error
  paths in case of allocation failure, some of those will return with
  null monitor page tables (and the domain likely crashed).  This is no
  different that current error paths, but the newly introduced ones are
  more likely to trigger.

  The now added failure points in sh_update_paging_modes() also require
  that on some error return paths the previous structures are cleared,
  and thus monitor table is null.

  While there adjust the 'type' parameter type of shadow_prealloc() to
  unsigned int rather than u32.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: b7f93c6afb12b6061e2d19de2f39ea09b569ac68
  master date: 2022-10-11 14:22:53 +0200
  40e9daf6b56ae49bda3ba4e254ccf0e998e52a8c:x86/shadow: tolerate failure of sh_set_toplevel_shadow()

  Subsequently sh_set_toplevel_shadow() will be adjusted to install a
  blank entry in case prealloc fails. There are, in fact, pre-existing
  error paths which would put in place a blank entry. The 4- and 2-level
  code in sh_update_cr3(), however, assume the top level entry to be
  valid.

  Hence bail from the function in the unlikely event that it's not. Note
  that 3-level logic works differently: In particular a guest is free to
  supply a PDPTR pointing at 4 non-present (or otherwise deemed invalid)
  entries. The guest will crash, but we already cope with that.

  Really mfn_valid() is likely wrong to use in sh_set_toplevel_shadow(),
  and it should instead be !mfn_eq(gmfn, INVALID_MFN). Avoid such a change
  in security context, but add a respective assertion.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
  master commit: eac000978c1feb5a9ee3236ab0c0da9a477e5336
  master date: 2022-10-11 14:22:24 +0200
  3422c19d85a3d23a9d798eafb739ffb8865522d2:x86/HAP: adjust monitor table related error handling

  hap_make_monitor_table() will return INVALID_MFN if it encounters an
  error condition, but hap_update_paging_modes() wasn’t handling this
  value, resulting in an inappropriate value being stored in
  monitor_table. This would subsequently misguide at least
  hap_vcpu_teardown(). Avoid this by bailing early.

  Further, when a domain has/was already crashed or (perhaps less
  important as there's no such path known to lead here) is already dying,
  avoid calling domain_crash() on it again - that's at best confusing.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  master commit: 5b44a61180f4f2e4f490a28400c884dd357ff45d
  master date: 2022-10-11 14:21:56 +0200
  8fc19c143b8aa563077f3d5c46fcc0a54dc04f35:x86/p2m: add option to skip root pagetable removal in p2m_teardown()

  Add a new parameter to p2m_teardown() in order to select whether the
  root page table should also be freed.  Note that all users are
  adjusted to pass the parameter to remove the root page tables, so
  behavior is not modified.

  No functional change intended.

  This is part of CVE-2022-33746 / XSA-410.

  Suggested-by: Julien Grall <julien@xen.org>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  master commit: 1df52a270225527ae27bfa2fc40347bf93b78357
  master date: 2022-10-11 14:21:23 +0200
  937fdbad5180440888f1fcee46299103327efa90:xen/arm: p2m: Handle preemption when freeing intermediate page tables

  At the moment the P2M page tables will be freed when the domain structure
  is freed without any preemption. As the P2M is quite large, iterating
  through this may take more time than it is reasonable without intermediate
  preemption (to run softirqs and perhaps scheduler).

  Split p2m_teardown() in two parts: one preemptible and called when
  relinquishing the resources, the other one non-preemptible and called
  when freeing the domain structure.

  As we are now freeing the P2M pages early, we also need to prevent
  further allocation if someone call p2m_set_entry() past p2m_teardown()
  (I wasn't able to prove this will never happen). This is done by
  the checking domain->is_dying from previous patch in p2m_set_entry().

  Similarly, we want to make sure that no-one can accessed the free
  pages. Therefore the root is cleared before freeing pages.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Henry Wang <Henry.Wang@arm.com>
  Tested-by: Henry Wang <Henry.Wang@arm.com>
  Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
  master commit: 3202084566bba0ef0c45caf8c24302f83d92f9c8
  master date: 2022-10-11 14:20:56 +0200
  8d9531a3421dad2b0012e09e6f41d5274e162064:xen/arm: p2m: Prevent adding mapping when domain is dying

  During the domain destroy process, the domain will still be accessible
  until it is fully destroyed. So does the P2M because we don't bail
  out early if is_dying is non-zero. If a domain has permission to
  modify the other domain's P2M (i.e. dom0, or a stubdomain), then
  foreign mapping can be added past relinquish_p2m_mapping().

  Therefore, we need to prevent mapping to be added when the domain
  is dying. This commit prevents such adding of mapping by adding the
  d->is_dying check to p2m_set_entry(). Also this commit enhances the
  check in relinquish_p2m_mapping() to make sure that no mappings can
  be added in the P2M after the P2M lock is released.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Henry Wang <Henry.Wang@arm.com>
  Tested-by: Henry Wang <Henry.Wang@arm.com>
  Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
  master commit: 3ebe773293e3b945460a3d6f54f3b91915397bab
  master date: 2022-10-11 14:20:18 +0200
  8a2111250b424edc49c65c4d41b276766d30635c:xen/x86: p2m: Add preemption in p2m_teardown()

  The list p2m->pages contain all the pages used by the P2M. On large
  instance this can be quite large and the time spent to call
  d->arch.paging.free_page() will take more than 1ms for a 80GB guest
  on a Xen running in nested environment on a c5.metal.

  By extrapolation, it would take > 100ms for a 8TB guest (what we
  current security support). So add some preemption in p2m_teardown()
  and propagate to the callers. Note there are 3 places where
  the preemption is not enabled:
      - hap_final_teardown()/shadow_final_teardown(): We are
        preventing update the P2M once the domain is dying (so
        no more pages could be allocated) and most of the P2M pages
        will be freed in preemptive manneer when relinquishing the
        resources. So this is fine to disable preemption.
      - shadow_enable(): This is fine because it will undo the allocation
        that may have been made by p2m_alloc_table() (so only the root
        page table).

  The preemption is arbitrarily checked every 1024 iterations.

  We now need to include <xen/event.h> in p2m-basic in order to
  import the definition for local_events_need_delivery() used by
  general_preempt_check(). Ideally, the inclusion should happen in
  xen/sched.h but it opened a can of worms.

  Note that with the current approach, Xen doesn't keep track on whether
  the alt/nested P2Ms have been cleared. So there are some redundant work.
  However, this is not expected to incurr too much overhead (the P2M lock
  shouldn't be contended during teardown). So this is optimization is
  left outside of the security event.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  ----
  Changes since v12:
      - Correct altp2m preemption check placement.

  Changes since v9:
      - Integrate patch into series.

  Changes since v2:
      - Rework the loop doing the preemption
      - Add a comment in shadow_enable() to explain why p2m_teardown()
        doesn't need to be preemptible.

  Changes since v1:
      - Update the commit message
      - Rebase on top of Roger's v8 series
      - Fix preemption check
      - Use 'unsigned int' rather than 'unsigned long' for the counter
  e7aa55c0aab36d994bf627c92bd5386ae167e16e:x86/p2m: free the paging memory pool preemptively

  The paging memory pool is currently freed in two different places:
  from {shadow,hap}_teardown() via domain_relinquish_resources() and
  from {shadow,hap}_final_teardown() via complete_domain_destroy().
  While the former does handle preemption, the later doesn't.

  Attempt to move as much p2m related freeing as possible to happen
  before the call to {shadow,hap}_teardown(), so that most memory can be
  freed in a preemptive way.  In order to avoid causing issues to
  existing callers leave the root p2m page tables set and free them in
  {hap,shadow}_final_teardown().  Also modify {hap,shadow}_free to free
  the page immediately if the domain is dying, so that pages don't
  accumulate in the pool when {shadow,hap}_final_teardown() get called.

  Move altp2m_vcpu_disable_ve() to be done in hap_teardown(), as that's
  the place where altp2m_active gets disabled now.

  This is part of CVE-2022-33746 / XSA-410.

  Reported-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  f50a2c0e1d057c00d6061f40ae24d068226052ad:x86/p2m: truly free paging pool memory for dying domains

  Modify {hap,shadow}_free to free the page immediately if the domain is
  dying, so that pages don't accumulate in the pool when
  {shadow,hap}_final_teardown() get called. This is to limit the amount of
  work which needs to be done there (in a non-preemptable manner).

  Note the call to shadow_free() in shadow_free_p2m_page() is moved after
  increasing total_pages, so that the decrease done in shadow_free() in
  case the domain is dying doesn't underflow the counter, even if just for
  a short interval.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  ff600a8cf8e36f8ecbffecf96a035952e022ab87:x86/p2m: refuse new allocations for dying domains

  This will in particular prevent any attempts to add entries to the p2m,
  once - in a subsequent change - non-root entries have been removed.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  b7f93c6afb12b6061e2d19de2f39ea09b569ac68:x86/shadow: tolerate failure in shadow_prealloc()

  Prevent _shadow_prealloc() from calling BUG() when unable to fulfill
  the pre-allocation and instead return true/false.  Modify
  shadow_prealloc() to crash the domain on allocation failure (if the
  domain is not already dying), as shadow cannot operate normally after
  that.  Modify callers to also gracefully handle {_,}shadow_prealloc()
  failing to fulfill the request.

  Note this in turn requires adjusting the callers of
  sh_make_monitor_table() also to handle it returning INVALID_MFN.
  sh_update_paging_modes() is also modified to add additional error
  paths in case of allocation failure, some of those will return with
  null monitor page tables (and the domain likely crashed).  This is no
  different that current error paths, but the newly introduced ones are
  more likely to trigger.

  The now added failure points in sh_update_paging_modes() also require
  that on some error return paths the previous structures are cleared,
  and thus monitor table is null.

  While there adjust the 'type' parameter type of shadow_prealloc() to
  unsigned int rather than u32.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  eac000978c1feb5a9ee3236ab0c0da9a477e5336:x86/shadow: tolerate failure of sh_set_toplevel_shadow()

  Subsequently sh_set_toplevel_shadow() will be adjusted to install a
  blank entry in case prealloc fails. There are, in fact, pre-existing
  error paths which would put in place a blank entry. The 4- and 2-level
  code in sh_update_cr3(), however, assume the top level entry to be
  valid.

  Hence bail from the function in the unlikely event that it's not. Note
  that 3-level logic works differently: In particular a guest is free to
  supply a PDPTR pointing at 4 non-present (or otherwise deemed invalid)
  entries. The guest will crash, but we already cope with that.

  Really mfn_valid() is likely wrong to use in sh_set_toplevel_shadow(),
  and it should instead be !mfn_eq(gmfn, INVALID_MFN). Avoid such a change
  in security context, but add a respective assertion.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
  5b44a61180f4f2e4f490a28400c884dd357ff45d:x86/HAP: adjust monitor table related error handling

  hap_make_monitor_table() will return INVALID_MFN if it encounters an
  error condition, but hap_update_paging_modes() wasn’t handling this
  value, resulting in an inappropriate value being stored in
  monitor_table. This would subsequently misguide at least
  hap_vcpu_teardown(). Avoid this by bailing early.

  Further, when a domain has/was already crashed or (perhaps less
  important as there's no such path known to lead here) is already dying,
  avoid calling domain_crash() on it again - that's at best confusing.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  1df52a270225527ae27bfa2fc40347bf93b78357:x86/p2m: add option to skip root pagetable removal in p2m_teardown()

  Add a new parameter to p2m_teardown() in order to select whether the
  root page table should also be freed.  Note that all users are
  adjusted to pass the parameter to remove the root page tables, so
  behavior is not modified.

  No functional change intended.

  This is part of CVE-2022-33746 / XSA-410.

  Suggested-by: Julien Grall <julien@xen.org>
  Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Tim Deegan <tim@xen.org>
  3202084566bba0ef0c45caf8c24302f83d92f9c8:xen/arm: p2m: Handle preemption when freeing intermediate page tables

  At the moment the P2M page tables will be freed when the domain structure
  is freed without any preemption. As the P2M is quite large, iterating
  through this may take more time than it is reasonable without intermediate
  preemption (to run softirqs and perhaps scheduler).

  Split p2m_teardown() in two parts: one preemptible and called when
  relinquishing the resources, the other one non-preemptible and called
  when freeing the domain structure.

  As we are now freeing the P2M pages early, we also need to prevent
  further allocation if someone call p2m_set_entry() past p2m_teardown()
  (I wasn't able to prove this will never happen). This is done by
  the checking domain->is_dying from previous patch in p2m_set_entry().

  Similarly, we want to make sure that no-one can accessed the free
  pages. Therefore the root is cleared before freeing pages.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Henry Wang <Henry.Wang@arm.com>
  Tested-by: Henry Wang <Henry.Wang@arm.com>
  Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
  3ebe773293e3b945460a3d6f54f3b91915397bab:xen/arm: p2m: Prevent adding mapping when domain is dying

  During the domain destroy process, the domain will still be accessible
  until it is fully destroyed. So does the P2M because we don't bail
  out early if is_dying is non-zero. If a domain has permission to
  modify the other domain's P2M (i.e. dom0, or a stubdomain), then
  foreign mapping can be added past relinquish_p2m_mapping().

  Therefore, we need to prevent mapping to be added when the domain
  is dying. This commit prevents such adding of mapping by adding the
  d->is_dying check to p2m_set_entry(). Also this commit enhances the
  check in relinquish_p2m_mapping() to make sure that no mappings can
  be added in the P2M after the P2M lock is released.

  This is part of CVE-2022-33746 / XSA-410.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Signed-off-by: Henry Wang <Henry.Wang@arm.com>
  Tested-by: Henry Wang <Henry.Wang@arm.com>
  Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 0f3eab90f327210d91e8e31a769376f286e8819a
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 937fdbad5180440888f1fcee46299103327efa90
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 0bab3abf73783da66af8cf7cf7aabb7d86caa035
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 28d3f677ec97c98154311f64871ac48762cf980a
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 5475195ec490a1cbe226ebe7b709119928673cc8
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 7a7406ba1d8912719eb7c9eec2d7cd34f49dfac0
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 763f965d04c5eb01890f697aaaaa9120d552672a
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: f90615ce03c14b5288bdacd796ada23b4e9d0f7b
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 95f6d555ec84383f7daaf3374f65bec5ff4351f5
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 804f83bfba8e73ed99a2f839c6731fa2aa9fb7bb
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 6e537d36943e5b99afe6194b7fc147610bcf9fba
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 4e38cc1baea00384b208b762bccc624b0e070fed
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 8a2111250b424edc49c65c4d41b276766d30635c
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 3163e34f6abad70160711ef60c21645355f509fb
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 686c920fa9389fe2b6b619643024ed98b4b7d51f
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 08eec20dc0550316dad64cdc63fee2371702f31f
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 0021c269786e0442d6f922d110d957867fff421d
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 8fc19c143b8aa563077f3d5c46fcc0a54dc04f35
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 09fc590c15773c2471946a78740c6b02e8c34a45
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 9b5a7fd916a74295886a7d473c311e3c7e254e54
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 745e0b300dc3f5000e6d48c273b405d4bcc29ba7
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: f50a2c0e1d057c00d6061f40ae24d068226052ad
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 943635d8f8486209e4e48966507ad57963e96284
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 5b44a61180f4f2e4f490a28400c884dd357ff45d
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 7f055b011a657f8f16b0df242301efb312058eea
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: d24a10a91d46a56e1d406239643ec651a31033d4
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 3202084566bba0ef0c45caf8c24302f83d92f9c8
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 181ff7aced0e2afec4cfa57e015d01e0a0b3be59
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 0d805f9fba4bc155d15047685024f7d842e925e4
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 54b6eab0e4450a39ebe11b8f2faeaeb09c6e774a
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: f5959ed715e19cf2844656477dbf74c2f576c9d4
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 8d9531a3421dad2b0012e09e6f41d5274e162064
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: eac000978c1feb5a9ee3236ab0c0da9a477e5336
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: b7f93c6afb12b6061e2d19de2f39ea09b569ac68
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: aa7891098cc46a7a11b2d823cd8386be8b04c453
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: a603386b422f5cb4c5e2639a7e20a1d99dba2175
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 3ebe773293e3b945460a3d6f54f3b91915397bab
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 1df52a270225527ae27bfa2fc40347bf93b78357
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 40e9daf6b56ae49bda3ba4e254ccf0e998e52a8c
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 3e7aa35a56f9e9b42c74724c4083026da8ac9bcd
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: eed4ef4177b8267f2b6f403db00ed393a371285f
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 4f9b535194f70582863f2a78f113547d8822b2b9
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 9c975e636ed2782d4fd8b2b76126bdfb81f386cc
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: fc1098471822d80a35c6f1ac1ec8c7b45caf6eab
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 3422c19d85a3d23a9d798eafb739ffb8865522d2
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: ff600a8cf8e36f8ecbffecf96a035952e022ab87
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: b8f4a5de683efbe402db65483d845573c30dbb3f
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 1e26afa846fb9a00b9155280eeae3b8cb8375dd6
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: e7aa55c0aab36d994bf627c92bd5386ae167e16e
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: b03074bb47d10c9373688b3661c7c31da01c21a3
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/0021c269786e0442d6f922d110d957867fff421d
    reference_type: commit
    reference_id: 0021c269786e0442d6f922d110d957867fff421d
  - url: https://github.com/xen-project/xen/tree/08eec20dc0550316dad64cdc63fee2371702f31f
    reference_type: commit
    reference_id: 08eec20dc0550316dad64cdc63fee2371702f31f
  - url: https://github.com/xen-project/xen/tree/09fc590c15773c2471946a78740c6b02e8c34a45
    reference_type: commit
    reference_id: 09fc590c15773c2471946a78740c6b02e8c34a45
  - url: https://github.com/xen-project/xen/tree/0bab3abf73783da66af8cf7cf7aabb7d86caa035
    reference_type: commit
    reference_id: 0bab3abf73783da66af8cf7cf7aabb7d86caa035
  - url: https://github.com/xen-project/xen/tree/0d805f9fba4bc155d15047685024f7d842e925e4
    reference_type: commit
    reference_id: 0d805f9fba4bc155d15047685024f7d842e925e4
  - url: https://github.com/xen-project/xen/tree/0f3eab90f327210d91e8e31a769376f286e8819a
    reference_type: commit
    reference_id: 0f3eab90f327210d91e8e31a769376f286e8819a
  - url: https://github.com/xen-project/xen/tree/181ff7aced0e2afec4cfa57e015d01e0a0b3be59
    reference_type: commit
    reference_id: 181ff7aced0e2afec4cfa57e015d01e0a0b3be59
  - url: https://github.com/xen-project/xen/tree/1df52a270225527ae27bfa2fc40347bf93b78357
    reference_type: commit
    reference_id: 1df52a270225527ae27bfa2fc40347bf93b78357
  - url: https://github.com/xen-project/xen/tree/1e26afa846fb9a00b9155280eeae3b8cb8375dd6
    reference_type: commit
    reference_id: 1e26afa846fb9a00b9155280eeae3b8cb8375dd6
  - url: https://github.com/xen-project/xen/tree/28d3f677ec97c98154311f64871ac48762cf980a
    reference_type: commit
    reference_id: 28d3f677ec97c98154311f64871ac48762cf980a
  - url: https://github.com/xen-project/xen/tree/3163e34f6abad70160711ef60c21645355f509fb
    reference_type: commit
    reference_id: 3163e34f6abad70160711ef60c21645355f509fb
  - url: https://github.com/xen-project/xen/tree/3202084566bba0ef0c45caf8c24302f83d92f9c8
    reference_type: commit
    reference_id: 3202084566bba0ef0c45caf8c24302f83d92f9c8
  - url: https://github.com/xen-project/xen/tree/3422c19d85a3d23a9d798eafb739ffb8865522d2
    reference_type: commit
    reference_id: 3422c19d85a3d23a9d798eafb739ffb8865522d2
  - url: https://github.com/xen-project/xen/tree/3e7aa35a56f9e9b42c74724c4083026da8ac9bcd
    reference_type: commit
    reference_id: 3e7aa35a56f9e9b42c74724c4083026da8ac9bcd
  - url: https://github.com/xen-project/xen/tree/3ebe773293e3b945460a3d6f54f3b91915397bab
    reference_type: commit
    reference_id: 3ebe773293e3b945460a3d6f54f3b91915397bab
  - url: https://github.com/xen-project/xen/tree/40e9daf6b56ae49bda3ba4e254ccf0e998e52a8c
    reference_type: commit
    reference_id: 40e9daf6b56ae49bda3ba4e254ccf0e998e52a8c
  - url: https://github.com/xen-project/xen/tree/4e38cc1baea00384b208b762bccc624b0e070fed
    reference_type: commit
    reference_id: 4e38cc1baea00384b208b762bccc624b0e070fed
  - url: https://github.com/xen-project/xen/tree/4f9b535194f70582863f2a78f113547d8822b2b9
    reference_type: commit
    reference_id: 4f9b535194f70582863f2a78f113547d8822b2b9
  - url: https://github.com/xen-project/xen/tree/5475195ec490a1cbe226ebe7b709119928673cc8
    reference_type: commit
    reference_id: 5475195ec490a1cbe226ebe7b709119928673cc8
  - url: https://github.com/xen-project/xen/tree/54b6eab0e4450a39ebe11b8f2faeaeb09c6e774a
    reference_type: commit
    reference_id: 54b6eab0e4450a39ebe11b8f2faeaeb09c6e774a
  - url: https://github.com/xen-project/xen/tree/5b44a61180f4f2e4f490a28400c884dd357ff45d
    reference_type: commit
    reference_id: 5b44a61180f4f2e4f490a28400c884dd357ff45d
  - url: https://github.com/xen-project/xen/tree/686c920fa9389fe2b6b619643024ed98b4b7d51f
    reference_type: commit
    reference_id: 686c920fa9389fe2b6b619643024ed98b4b7d51f
  - url: https://github.com/xen-project/xen/tree/6e537d36943e5b99afe6194b7fc147610bcf9fba
    reference_type: commit
    reference_id: 6e537d36943e5b99afe6194b7fc147610bcf9fba
  - url: https://github.com/xen-project/xen/tree/745e0b300dc3f5000e6d48c273b405d4bcc29ba7
    reference_type: commit
    reference_id: 745e0b300dc3f5000e6d48c273b405d4bcc29ba7
  - url: https://github.com/xen-project/xen/tree/763f965d04c5eb01890f697aaaaa9120d552672a
    reference_type: commit
    reference_id: 763f965d04c5eb01890f697aaaaa9120d552672a
  - url: https://github.com/xen-project/xen/tree/7a7406ba1d8912719eb7c9eec2d7cd34f49dfac0
    reference_type: commit
    reference_id: 7a7406ba1d8912719eb7c9eec2d7cd34f49dfac0
  - url: https://github.com/xen-project/xen/tree/7f055b011a657f8f16b0df242301efb312058eea
    reference_type: commit
    reference_id: 7f055b011a657f8f16b0df242301efb312058eea
  - url: https://github.com/xen-project/xen/tree/804f83bfba8e73ed99a2f839c6731fa2aa9fb7bb
    reference_type: commit
    reference_id: 804f83bfba8e73ed99a2f839c6731fa2aa9fb7bb
  - url: https://github.com/xen-project/xen/tree/8a2111250b424edc49c65c4d41b276766d30635c
    reference_type: commit
    reference_id: 8a2111250b424edc49c65c4d41b276766d30635c
  - url: https://github.com/xen-project/xen/tree/8d9531a3421dad2b0012e09e6f41d5274e162064
    reference_type: commit
    reference_id: 8d9531a3421dad2b0012e09e6f41d5274e162064
  - url: https://github.com/xen-project/xen/tree/8fc19c143b8aa563077f3d5c46fcc0a54dc04f35
    reference_type: commit
    reference_id: 8fc19c143b8aa563077f3d5c46fcc0a54dc04f35
  - url: https://github.com/xen-project/xen/tree/937fdbad5180440888f1fcee46299103327efa90
    reference_type: commit
    reference_id: 937fdbad5180440888f1fcee46299103327efa90
  - url: https://github.com/xen-project/xen/tree/943635d8f8486209e4e48966507ad57963e96284
    reference_type: commit
    reference_id: 943635d8f8486209e4e48966507ad57963e96284
  - url: https://github.com/xen-project/xen/tree/95f6d555ec84383f7daaf3374f65bec5ff4351f5
    reference_type: commit
    reference_id: 95f6d555ec84383f7daaf3374f65bec5ff4351f5
  - url: https://github.com/xen-project/xen/tree/9b5a7fd916a74295886a7d473c311e3c7e254e54
    reference_type: commit
    reference_id: 9b5a7fd916a74295886a7d473c311e3c7e254e54
  - url: https://github.com/xen-project/xen/tree/9c975e636ed2782d4fd8b2b76126bdfb81f386cc
    reference_type: commit
    reference_id: 9c975e636ed2782d4fd8b2b76126bdfb81f386cc
  - url: https://github.com/xen-project/xen/tree/a603386b422f5cb4c5e2639a7e20a1d99dba2175
    reference_type: commit
    reference_id: a603386b422f5cb4c5e2639a7e20a1d99dba2175
  - url: https://github.com/xen-project/xen/tree/aa7891098cc46a7a11b2d823cd8386be8b04c453
    reference_type: commit
    reference_id: aa7891098cc46a7a11b2d823cd8386be8b04c453
  - url: https://github.com/xen-project/xen/tree/b03074bb47d10c9373688b3661c7c31da01c21a3
    reference_type: commit
    reference_id: b03074bb47d10c9373688b3661c7c31da01c21a3
  - url: https://github.com/xen-project/xen/tree/b7f93c6afb12b6061e2d19de2f39ea09b569ac68
    reference_type: commit
    reference_id: b7f93c6afb12b6061e2d19de2f39ea09b569ac68
  - url: https://github.com/xen-project/xen/tree/b8f4a5de683efbe402db65483d845573c30dbb3f
    reference_type: commit
    reference_id: b8f4a5de683efbe402db65483d845573c30dbb3f
  - url: https://github.com/xen-project/xen/tree/d24a10a91d46a56e1d406239643ec651a31033d4
    reference_type: commit
    reference_id: d24a10a91d46a56e1d406239643ec651a31033d4
  - url: https://github.com/xen-project/xen/tree/e7aa55c0aab36d994bf627c92bd5386ae167e16e
    reference_type: commit
    reference_id: e7aa55c0aab36d994bf627c92bd5386ae167e16e
  - url: https://github.com/xen-project/xen/tree/eac000978c1feb5a9ee3236ab0c0da9a477e5336
    reference_type: commit
    reference_id: eac000978c1feb5a9ee3236ab0c0da9a477e5336
  - url: https://github.com/xen-project/xen/tree/eed4ef4177b8267f2b6f403db00ed393a371285f
    reference_type: commit
    reference_id: eed4ef4177b8267f2b6f403db00ed393a371285f
  - url: https://github.com/xen-project/xen/tree/f50a2c0e1d057c00d6061f40ae24d068226052ad
    reference_type: commit
    reference_id: f50a2c0e1d057c00d6061f40ae24d068226052ad
  - url: https://github.com/xen-project/xen/tree/f5959ed715e19cf2844656477dbf74c2f576c9d4
    reference_type: commit
    reference_id: f5959ed715e19cf2844656477dbf74c2f576c9d4
  - url: https://github.com/xen-project/xen/tree/f90615ce03c14b5288bdacd796ada23b4e9d0f7b
    reference_type: commit
    reference_id: f90615ce03c14b5288bdacd796ada23b4e9d0f7b
  - url: https://github.com/xen-project/xen/tree/fc1098471822d80a35c6f1ac1ec8c7b45caf6eab
    reference_type: commit
    reference_id: fc1098471822d80a35c6f1ac1ec8c7b45caf6eab
  - url: https://github.com/xen-project/xen/tree/ff600a8cf8e36f8ecbffecf96a035952e022ab87
    reference_type: commit
    reference_id: ff600a8cf8e36f8ecbffecf96a035952e022ab87
