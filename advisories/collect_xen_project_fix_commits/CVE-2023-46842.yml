advisory_id: CVE-2023-46842
datasource_id: collect_xen_project_fix_commits/CVE-2023-46842
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  b8f39fd4d024ea72c586f1afd233f379c6f6230b:hypercall_xlat_continuation: Replace BUG_ON with domain_crash

  Instead of crashing the host in case of unexpected hypercall parameters,
  resort to only crashing the calling domain.

  This is part of XSA-454 / CVE-2023-46842.

  Fixes: b8a7efe8528a ("Enable compatibility mode operation for HYPERVISOR_memory_op")
  Reported-by: Manuel Andreas <manuel.andreas@tum.de>
  Signed-off-by: Bjoern Doebel <doebel@amazon.de>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  (cherry picked from commit 9926e692c4afc40bcd66f8416ff6a1e93ce402f6)
  6462418517abb21775ee775a1275459e70b6e5a1:x86/HVM: clear upper halves of GPRs upon entry from 32-bit code

  Hypercalls in particular can be the subject of continuations, and logic
  there checks updated state against incoming register values. If the
  guest manufactured a suitable argument register with a non-zero upper
  half before entering compatibility mode and issuing a hypercall from
  there, checks in hypercall_xlat_continuation() might trip.

  Since for HVM we want to also be sure to not hit a corner case in the
  emulator, initiate the clipping right from the top of
  {svm,vmx}_vmexit_handler(). Also rename the invoked function, as it no
  longer does only invalidation of fields.

  Note that architecturally the upper halves of registers are undefined
  after a switch between compatibility and 64-bit mode (either direction).
  Hence once having entered compatibility mode, the guest can't assume
  the upper half of any register to retain its value.

  This is part of XSA-454 / CVE-2023-46842.

  Fixes: b8a7efe8528a ("Enable compatibility mode operation for HYPERVISOR_memory_op")
  Reported-by: Manuel Andreas <manuel.andreas@tum.de>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  (cherry picked from commit 6a98383b0877bb66ebfe189da43bf81abe3d7909)
  9926e692c4afc40bcd66f8416ff6a1e93ce402f6:hypercall_xlat_continuation: Replace BUG_ON with domain_crash

  Instead of crashing the host in case of unexpected hypercall parameters,
  resort to only crashing the calling domain.

  This is part of XSA-454 / CVE-2023-46842.

  Fixes: b8a7efe8528a ("Enable compatibility mode operation for HYPERVISOR_memory_op")
  Reported-by: Manuel Andreas <manuel.andreas@tum.de>
  Signed-off-by: Bjoern Doebel <doebel@amazon.de>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  6a98383b0877bb66ebfe189da43bf81abe3d7909:x86/HVM: clear upper halves of GPRs upon entry from 32-bit code

  Hypercalls in particular can be the subject of continuations, and logic
  there checks updated state against incoming register values. If the
  guest manufactured a suitable argument register with a non-zero upper
  half before entering compatibility mode and issuing a hypercall from
  there, checks in hypercall_xlat_continuation() might trip.

  Since for HVM we want to also be sure to not hit a corner case in the
  emulator, initiate the clipping right from the top of
  {svm,vmx}_vmexit_handler(). Also rename the invoked function, as it no
  longer does only invalidation of fields.

  Note that architecturally the upper halves of registers are undefined
  after a switch between compatibility and 64-bit mode (either direction).
  Hence once having entered compatibility mode, the guest can't assume
  the upper half of any register to retain its value.

  This is part of XSA-454 / CVE-2023-46842.

  Fixes: b8a7efe8528a ("Enable compatibility mode operation for HYPERVISOR_memory_op")
  Reported-by: Manuel Andreas <manuel.andreas@tum.de>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  1166467ed300d605529aaf7a7d26c8c92defe36a:hypercall_xlat_continuation: Replace BUG_ON with domain_crash

  Instead of crashing the host in case of unexpected hypercall parameters,
  resort to only crashing the calling domain.

  This is part of XSA-454 / CVE-2023-46842.

  Fixes: b8a7efe8528a ("Enable compatibility mode operation for HYPERVISOR_memory_op")
  Reported-by: Manuel Andreas <manuel.andreas@tum.de>
  Signed-off-by: Bjoern Doebel <doebel@amazon.de>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  (cherry picked from commit 9926e692c4afc40bcd66f8416ff6a1e93ce402f6)
  429a125dba3083fa68e976d408b2ba430a67f0a5:x86/HVM: clear upper halves of GPRs upon entry from 32-bit code

  Hypercalls in particular can be the subject of continuations, and logic
  there checks updated state against incoming register values. If the
  guest manufactured a suitable argument register with a non-zero upper
  half before entering compatibility mode and issuing a hypercall from
  there, checks in hypercall_xlat_continuation() might trip.

  Since for HVM we want to also be sure to not hit a corner case in the
  emulator, initiate the clipping right from the top of
  {svm,vmx}_vmexit_handler(). Also rename the invoked function, as it no
  longer does only invalidation of fields.

  Note that architecturally the upper halves of registers are undefined
  after a switch between compatibility and 64-bit mode (either direction).
  Hence once having entered compatibility mode, the guest can't assume
  the upper half of any register to retain its value.

  This is part of XSA-454 / CVE-2023-46842.

  Fixes: b8a7efe8528a ("Enable compatibility mode operation for HYPERVISOR_memory_op")
  Reported-by: Manuel Andreas <manuel.andreas@tum.de>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  (cherry picked from commit 6a98383b0877bb66ebfe189da43bf81abe3d7909)
  9c7c50969fa6c7b1e2d24c2c9dfe528079d72df2:hypercall_xlat_continuation: Replace BUG_ON with domain_crash

  Instead of crashing the host in case of unexpected hypercall parameters,
  resort to only crashing the calling domain.

  This is part of XSA-454 / CVE-2023-46842.

  Fixes: b8a7efe8528a ("Enable compatibility mode operation for HYPERVISOR_memory_op")
  Reported-by: Manuel Andreas <manuel.andreas@tum.de>
  Signed-off-by: Bjoern Doebel <doebel@amazon.de>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  (cherry picked from commit 9926e692c4afc40bcd66f8416ff6a1e93ce402f6)
  8d6efd087b34127ef9865afc36093617f15080b6:x86/HVM: clear upper halves of GPRs upon entry from 32-bit code

  Hypercalls in particular can be the subject of continuations, and logic
  there checks updated state against incoming register values. If the
  guest manufactured a suitable argument register with a non-zero upper
  half before entering compatibility mode and issuing a hypercall from
  there, checks in hypercall_xlat_continuation() might trip.

  Since for HVM we want to also be sure to not hit a corner case in the
  emulator, initiate the clipping right from the top of
  {svm,vmx}_vmexit_handler(). Also rename the invoked function, as it no
  longer does only invalidation of fields.

  Note that architecturally the upper halves of registers are undefined
  after a switch between compatibility and 64-bit mode (either direction).
  Hence once having entered compatibility mode, the guest can't assume
  the upper half of any register to retain its value.

  This is part of XSA-454 / CVE-2023-46842.

  Fixes: b8a7efe8528a ("Enable compatibility mode operation for HYPERVISOR_memory_op")
  Reported-by: Manuel Andreas <manuel.andreas@tum.de>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  (cherry picked from commit 6a98383b0877bb66ebfe189da43bf81abe3d7909)
  65eb8f32b6b82e0268a9d66b49da354bc6698e87:hypercall_xlat_continuation: Replace BUG_ON with domain_crash

  Instead of crashing the host in case of unexpected hypercall parameters,
  resort to only crashing the calling domain.

  This is part of XSA-454 / CVE-2023-46842.

  Fixes: b8a7efe8528a ("Enable compatibility mode operation for HYPERVISOR_memory_op")
  Reported-by: Manuel Andreas <manuel.andreas@tum.de>
  Signed-off-by: Bjoern Doebel <doebel@amazon.de>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  (cherry picked from commit 9926e692c4afc40bcd66f8416ff6a1e93ce402f6)
  1a41979210b7d276824dc4660f4f58a1d6dea3ca:x86/HVM: clear upper halves of GPRs upon entry from 32-bit code

  Hypercalls in particular can be the subject of continuations, and logic
  there checks updated state against incoming register values. If the
  guest manufactured a suitable argument register with a non-zero upper
  half before entering compatibility mode and issuing a hypercall from
  there, checks in hypercall_xlat_continuation() might trip.

  Since for HVM we want to also be sure to not hit a corner case in the
  emulator, initiate the clipping right from the top of
  {svm,vmx}_vmexit_handler(). Also rename the invoked function, as it no
  longer does only invalidation of fields.

  Note that architecturally the upper halves of registers are undefined
  after a switch between compatibility and 64-bit mode (either direction).
  Hence once having entered compatibility mode, the guest can't assume
  the upper half of any register to retain its value.

  This is part of XSA-454 / CVE-2023-46842.

  Fixes: b8a7efe8528a ("Enable compatibility mode operation for HYPERVISOR_memory_op")
  Reported-by: Manuel Andreas <manuel.andreas@tum.de>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  (cherry picked from commit 6a98383b0877bb66ebfe189da43bf81abe3d7909)
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 9926e692c4afc40bcd66f8416ff6a1e93ce402f6
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 8d6efd087b34127ef9865afc36093617f15080b6
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 6462418517abb21775ee775a1275459e70b6e5a1
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 65eb8f32b6b82e0268a9d66b49da354bc6698e87
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 6a98383b0877bb66ebfe189da43bf81abe3d7909
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 1a41979210b7d276824dc4660f4f58a1d6dea3ca
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 1166467ed300d605529aaf7a7d26c8c92defe36a
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: b8f39fd4d024ea72c586f1afd233f379c6f6230b
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 9c7c50969fa6c7b1e2d24c2c9dfe528079d72df2
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 429a125dba3083fa68e976d408b2ba430a67f0a5
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/1166467ed300d605529aaf7a7d26c8c92defe36a
    reference_type: commit
    reference_id: 1166467ed300d605529aaf7a7d26c8c92defe36a
  - url: https://github.com/xen-project/xen/tree/1a41979210b7d276824dc4660f4f58a1d6dea3ca
    reference_type: commit
    reference_id: 1a41979210b7d276824dc4660f4f58a1d6dea3ca
  - url: https://github.com/xen-project/xen/tree/429a125dba3083fa68e976d408b2ba430a67f0a5
    reference_type: commit
    reference_id: 429a125dba3083fa68e976d408b2ba430a67f0a5
  - url: https://github.com/xen-project/xen/tree/6462418517abb21775ee775a1275459e70b6e5a1
    reference_type: commit
    reference_id: 6462418517abb21775ee775a1275459e70b6e5a1
  - url: https://github.com/xen-project/xen/tree/65eb8f32b6b82e0268a9d66b49da354bc6698e87
    reference_type: commit
    reference_id: 65eb8f32b6b82e0268a9d66b49da354bc6698e87
  - url: https://github.com/xen-project/xen/tree/6a98383b0877bb66ebfe189da43bf81abe3d7909
    reference_type: commit
    reference_id: 6a98383b0877bb66ebfe189da43bf81abe3d7909
  - url: https://github.com/xen-project/xen/tree/8d6efd087b34127ef9865afc36093617f15080b6
    reference_type: commit
    reference_id: 8d6efd087b34127ef9865afc36093617f15080b6
  - url: https://github.com/xen-project/xen/tree/9926e692c4afc40bcd66f8416ff6a1e93ce402f6
    reference_type: commit
    reference_id: 9926e692c4afc40bcd66f8416ff6a1e93ce402f6
  - url: https://github.com/xen-project/xen/tree/9c7c50969fa6c7b1e2d24c2c9dfe528079d72df2
    reference_type: commit
    reference_id: 9c7c50969fa6c7b1e2d24c2c9dfe528079d72df2
  - url: https://github.com/xen-project/xen/tree/b8f39fd4d024ea72c586f1afd233f379c6f6230b
    reference_type: commit
    reference_id: b8f39fd4d024ea72c586f1afd233f379c6f6230b
