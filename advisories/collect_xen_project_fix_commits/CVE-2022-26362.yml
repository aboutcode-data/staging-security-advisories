advisory_id: CVE-2022-26362
datasource_id: collect_xen_project_fix_commits/CVE-2022-26362
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  7669737d7da5790e66ffb670576175c2465ab09c:x86/pv: Fix ABAC cmpxchg() race in _get_page_type()

  _get_page_type() suffers from a race condition where it incorrectly assumes
  that because 'x' was read and a subsequent a cmpxchg() succeeds, the type
  cannot have changed in-between.  Consider:

  CPU A:
    1. Creates an L2e referencing pg
       `-> _get_page_type(pg, PGT_l1_page_table), sees count 0, type PGT_writable_page
    2.     Issues flush_tlb_mask()
  CPU B:
    3. Creates a writeable mapping of pg
       `-> _get_page_type(pg, PGT_writable_page), count increases to 1
    4. Writes into new mapping, creating a TLB entry for pg
    5. Removes the writeable mapping of pg
       `-> _put_page_type(pg), count goes back down to 0
  CPU A:
    7.     Issues cmpxchg(), setting count 1, type PGT_l1_page_table

  CPU B now has a writeable mapping to pg, which Xen believes is a pagetable and
  suitably protected (i.e. read-only).  The TLB flush in step 2 must be deferred
  until after the guest is prohibited from creating new writeable mappings,
  which is after step 7.

  Defer all safety actions until after the cmpxchg() has successfully taken the
  intended typeref, because that is what prevents concurrent users from using
  the old type.

  Also remove the early validation for writeable and shared pages.  This removes
  race conditions where one half of a parallel mapping attempt can return
  successfully before:
   * The IOMMU pagetables are in sync with the new page type
   * Writeable mappings to shared pages have been torn down

  This is part of XSA-401 / CVE-2022-26362.

  Reported-by: Jann Horn <jannh@google.com>
  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: George Dunlap <george.dunlap@citrix.com>
  master commit: 8cc5036bc385112a82f1faff27a0970e6440dfed
  master date: 2022-06-09 14:21:04 +0200
  3826ba5f8271676c1569588abb32d960e5882e54:x86/pv: Clean up _get_page_type()

  Various fixes for clarity, ahead of making complicated changes.

   * Split the overflow check out of the if/else chain for type handling, as
     it's somewhat unrelated.
   * Comment the main if/else chain to explain what is going on.  Adjust one
     ASSERT() and state the bit layout for validate-locked and partial states.
   * Correct the comment about TLB flushing, as it's backwards.  The problem
     case is when writeable mappings are retained to a page becoming read-only,
     as it allows the guest to bypass Xen's safety checks for updates.
   * Reduce the scope of 'y'.  It is an artefact of the cmpxchg loop and not
     valid for use by subsequent logic.  Switch to using ACCESS_ONCE() to treat
     all reads as explicitly volatile.  The only thing preventing the validated
     wait-loop being infinite is the compiler barrier hidden in cpu_relax().
   * Replace one page_get_owner(page) with the already-calculated 'd' already in
     scope.

  No functional change.

  This is part of XSA-401 / CVE-2022-26362.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Signed-off-by: George Dunlap <george.dunlap@eu.citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: George Dunlap <george.dunlap@citrix.com>
  master commit: 9186e96b199e4f7e52e033b238f9fe869afb69c7
  master date: 2022-06-09 14:20:36 +0200
  758f40d7fa7e98ef2d2772ef8f0f57eabde028bd:x86/pv: Fix ABAC cmpxchg() race in _get_page_type()

  _get_page_type() suffers from a race condition where it incorrectly assumes
  that because 'x' was read and a subsequent a cmpxchg() succeeds, the type
  cannot have changed in-between.  Consider:

  CPU A:
    1. Creates an L2e referencing pg
       `-> _get_page_type(pg, PGT_l1_page_table), sees count 0, type PGT_writable_page
    2.     Issues flush_tlb_mask()
  CPU B:
    3. Creates a writeable mapping of pg
       `-> _get_page_type(pg, PGT_writable_page), count increases to 1
    4. Writes into new mapping, creating a TLB entry for pg
    5. Removes the writeable mapping of pg
       `-> _put_page_type(pg), count goes back down to 0
  CPU A:
    7.     Issues cmpxchg(), setting count 1, type PGT_l1_page_table

  CPU B now has a writeable mapping to pg, which Xen believes is a pagetable and
  suitably protected (i.e. read-only).  The TLB flush in step 2 must be deferred
  until after the guest is prohibited from creating new writeable mappings,
  which is after step 7.

  Defer all safety actions until after the cmpxchg() has successfully taken the
  intended typeref, because that is what prevents concurrent users from using
  the old type.

  Also remove the early validation for writeable and shared pages.  This removes
  race conditions where one half of a parallel mapping attempt can return
  successfully before:
   * The IOMMU pagetables are in sync with the new page type
   * Writeable mappings to shared pages have been torn down

  This is part of XSA-401 / CVE-2022-26362.

  Reported-by: Jann Horn <jannh@google.com>
  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: George Dunlap <george.dunlap@citrix.com>
  master commit: 8cc5036bc385112a82f1faff27a0970e6440dfed
  master date: 2022-06-09 14:21:04 +0200
  c70071eb6c6d43f96d0d9e2f2446de491c8ed527:x86/pv: Clean up _get_page_type()

  Various fixes for clarity, ahead of making complicated changes.

   * Split the overflow check out of the if/else chain for type handling, as
     it's somewhat unrelated.
   * Comment the main if/else chain to explain what is going on.  Adjust one
     ASSERT() and state the bit layout for validate-locked and partial states.
   * Correct the comment about TLB flushing, as it's backwards.  The problem
     case is when writeable mappings are retained to a page becoming read-only,
     as it allows the guest to bypass Xen's safety checks for updates.
   * Reduce the scope of 'y'.  It is an artefact of the cmpxchg loop and not
     valid for use by subsequent logic.  Switch to using ACCESS_ONCE() to treat
     all reads as explicitly volatile.  The only thing preventing the validated
     wait-loop being infinite is the compiler barrier hidden in cpu_relax().
   * Replace one page_get_owner(page) with the already-calculated 'd' already in
     scope.

  No functional change.

  This is part of XSA-401 / CVE-2022-26362.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Signed-off-by: George Dunlap <george.dunlap@eu.citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: George Dunlap <george.dunlap@citrix.com>
  master commit: 9186e96b199e4f7e52e033b238f9fe869afb69c7
  master date: 2022-06-09 14:20:36 +0200
  82a94a179cae9fca3ecebe6c26868072088b8e3c:x86/pv: Fix ABAC cmpxchg() race in _get_page_type()

  _get_page_type() suffers from a race condition where it incorrectly assumes
  that because 'x' was read and a subsequent a cmpxchg() succeeds, the type
  cannot have changed in-between.  Consider:

  CPU A:
    1. Creates an L2e referencing pg
       `-> _get_page_type(pg, PGT_l1_page_table), sees count 0, type PGT_writable_page
    2.     Issues flush_tlb_mask()
  CPU B:
    3. Creates a writeable mapping of pg
       `-> _get_page_type(pg, PGT_writable_page), count increases to 1
    4. Writes into new mapping, creating a TLB entry for pg
    5. Removes the writeable mapping of pg
       `-> _put_page_type(pg), count goes back down to 0
  CPU A:
    7.     Issues cmpxchg(), setting count 1, type PGT_l1_page_table

  CPU B now has a writeable mapping to pg, which Xen believes is a pagetable and
  suitably protected (i.e. read-only).  The TLB flush in step 2 must be deferred
  until after the guest is prohibited from creating new writeable mappings,
  which is after step 7.

  Defer all safety actions until after the cmpxchg() has successfully taken the
  intended typeref, because that is what prevents concurrent users from using
  the old type.

  Also remove the early validation for writeable and shared pages.  This removes
  race conditions where one half of a parallel mapping attempt can return
  successfully before:
   * The IOMMU pagetables are in sync with the new page type
   * Writeable mappings to shared pages have been torn down

  This is part of XSA-401 / CVE-2022-26362.

  Reported-by: Jann Horn <jannh@google.com>
  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: George Dunlap <george.dunlap@citrix.com>
  master commit: 8cc5036bc385112a82f1faff27a0970e6440dfed
  master date: 2022-06-09 14:21:04 +0200
  cc74ff882364317e3667c6251cc79bc76fa20ae4:x86/pv: Clean up _get_page_type()

  Various fixes for clarity, ahead of making complicated changes.

   * Split the overflow check out of the if/else chain for type handling, as
     it's somewhat unrelated.
   * Comment the main if/else chain to explain what is going on.  Adjust one
     ASSERT() and state the bit layout for validate-locked and partial states.
   * Correct the comment about TLB flushing, as it's backwards.  The problem
     case is when writeable mappings are retained to a page becoming read-only,
     as it allows the guest to bypass Xen's safety checks for updates.
   * Reduce the scope of 'y'.  It is an artefact of the cmpxchg loop and not
     valid for use by subsequent logic.  Switch to using ACCESS_ONCE() to treat
     all reads as explicitly volatile.  The only thing preventing the validated
     wait-loop being infinite is the compiler barrier hidden in cpu_relax().
   * Replace one page_get_owner(page) with the already-calculated 'd' already in
     scope.

  No functional change.

  This is part of XSA-401 / CVE-2022-26362.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Signed-off-by: George Dunlap <george.dunlap@eu.citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: George Dunlap <george.dunlap@citrix.com>
  master commit: 9186e96b199e4f7e52e033b238f9fe869afb69c7
  master date: 2022-06-09 14:20:36 +0200
  8dab3f79b122e69cbcdebca72cdc14f004ee2193:x86/pv: Fix ABAC cmpxchg() race in _get_page_type()

  _get_page_type() suffers from a race condition where it incorrectly assumes
  that because 'x' was read and a subsequent a cmpxchg() succeeds, the type
  cannot have changed in-between.  Consider:

  CPU A:
    1. Creates an L2e referencing pg
       `-> _get_page_type(pg, PGT_l1_page_table), sees count 0, type PGT_writable_page
    2.     Issues flush_tlb_mask()
  CPU B:
    3. Creates a writeable mapping of pg
       `-> _get_page_type(pg, PGT_writable_page), count increases to 1
    4. Writes into new mapping, creating a TLB entry for pg
    5. Removes the writeable mapping of pg
       `-> _put_page_type(pg), count goes back down to 0
  CPU A:
    7.     Issues cmpxchg(), setting count 1, type PGT_l1_page_table

  CPU B now has a writeable mapping to pg, which Xen believes is a pagetable and
  suitably protected (i.e. read-only).  The TLB flush in step 2 must be deferred
  until after the guest is prohibited from creating new writeable mappings,
  which is after step 7.

  Defer all safety actions until after the cmpxchg() has successfully taken the
  intended typeref, because that is what prevents concurrent users from using
  the old type.

  Also remove the early validation for writeable and shared pages.  This removes
  race conditions where one half of a parallel mapping attempt can return
  successfully before:
   * The IOMMU pagetables are in sync with the new page type
   * Writeable mappings to shared pages have been torn down

  This is part of XSA-401 / CVE-2022-26362.

  Reported-by: Jann Horn <jannh@google.com>
  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: George Dunlap <george.dunlap@citrix.com>
  master commit: 8cc5036bc385112a82f1faff27a0970e6440dfed
  master date: 2022-06-09 14:21:04 +0200
  b152dfbc3ad71a788996440b18174d995c3bffc9:x86/pv: Clean up _get_page_type()

  Various fixes for clarity, ahead of making complicated changes.

   * Split the overflow check out of the if/else chain for type handling, as
     it's somewhat unrelated.
   * Comment the main if/else chain to explain what is going on.  Adjust one
     ASSERT() and state the bit layout for validate-locked and partial states.
   * Correct the comment about TLB flushing, as it's backwards.  The problem
     case is when writeable mappings are retained to a page becoming read-only,
     as it allows the guest to bypass Xen's safety checks for updates.
   * Reduce the scope of 'y'.  It is an artefact of the cmpxchg loop and not
     valid for use by subsequent logic.  Switch to using ACCESS_ONCE() to treat
     all reads as explicitly volatile.  The only thing preventing the validated
     wait-loop being infinite is the compiler barrier hidden in cpu_relax().
   * Replace one page_get_owner(page) with the already-calculated 'd' already in
     scope.

  No functional change.

  This is part of XSA-401 / CVE-2022-26362.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Signed-off-by: George Dunlap <george.dunlap@eu.citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: George Dunlap <george.dunlap@citrix.com>
  master commit: 9186e96b199e4f7e52e033b238f9fe869afb69c7
  master date: 2022-06-09 14:20:36 +0200
  8cc5036bc385112a82f1faff27a0970e6440dfed:x86/pv: Fix ABAC cmpxchg() race in _get_page_type()

  _get_page_type() suffers from a race condition where it incorrectly assumes
  that because 'x' was read and a subsequent a cmpxchg() succeeds, the type
  cannot have changed in-between.  Consider:

  CPU A:
    1. Creates an L2e referencing pg
       `-> _get_page_type(pg, PGT_l1_page_table), sees count 0, type PGT_writable_page
    2.     Issues flush_tlb_mask()
  CPU B:
    3. Creates a writeable mapping of pg
       `-> _get_page_type(pg, PGT_writable_page), count increases to 1
    4. Writes into new mapping, creating a TLB entry for pg
    5. Removes the writeable mapping of pg
       `-> _put_page_type(pg), count goes back down to 0
  CPU A:
    7.     Issues cmpxchg(), setting count 1, type PGT_l1_page_table

  CPU B now has a writeable mapping to pg, which Xen believes is a pagetable and
  suitably protected (i.e. read-only).  The TLB flush in step 2 must be deferred
  until after the guest is prohibited from creating new writeable mappings,
  which is after step 7.

  Defer all safety actions until after the cmpxchg() has successfully taken the
  intended typeref, because that is what prevents concurrent users from using
  the old type.

  Also remove the early validation for writeable and shared pages.  This removes
  race conditions where one half of a parallel mapping attempt can return
  successfully before:
   * The IOMMU pagetables are in sync with the new page type
   * Writeable mappings to shared pages have been torn down

  This is part of XSA-401 / CVE-2022-26362.

  Reported-by: Jann Horn <jannh@google.com>
  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: George Dunlap <george.dunlap@citrix.com>
  9186e96b199e4f7e52e033b238f9fe869afb69c7:x86/pv: Clean up _get_page_type()

  Various fixes for clarity, ahead of making complicated changes.

   * Split the overflow check out of the if/else chain for type handling, as
     it's somewhat unrelated.
   * Comment the main if/else chain to explain what is going on.  Adjust one
     ASSERT() and state the bit layout for validate-locked and partial states.
   * Correct the comment about TLB flushing, as it's backwards.  The problem
     case is when writeable mappings are retained to a page becoming read-only,
     as it allows the guest to bypass Xen's safety checks for updates.
   * Reduce the scope of 'y'.  It is an artefact of the cmpxchg loop and not
     valid for use by subsequent logic.  Switch to using ACCESS_ONCE() to treat
     all reads as explicitly volatile.  The only thing preventing the validated
     wait-loop being infinite is the compiler barrier hidden in cpu_relax().
   * Replace one page_get_owner(page) with the already-calculated 'd' already in
     scope.

  No functional change.

  This is part of XSA-401 / CVE-2022-26362.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Signed-off-by: George Dunlap <george.dunlap@eu.citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: George Dunlap <george.dunlap@citrix.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 82a94a179cae9fca3ecebe6c26868072088b8e3c
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 8dab3f79b122e69cbcdebca72cdc14f004ee2193
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 7669737d7da5790e66ffb670576175c2465ab09c
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 9186e96b199e4f7e52e033b238f9fe869afb69c7
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 3826ba5f8271676c1569588abb32d960e5882e54
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 758f40d7fa7e98ef2d2772ef8f0f57eabde028bd
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 8cc5036bc385112a82f1faff27a0970e6440dfed
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: c70071eb6c6d43f96d0d9e2f2446de491c8ed527
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: b152dfbc3ad71a788996440b18174d995c3bffc9
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: cc74ff882364317e3667c6251cc79bc76fa20ae4
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/3826ba5f8271676c1569588abb32d960e5882e54
    reference_type: commit
    reference_id: 3826ba5f8271676c1569588abb32d960e5882e54
  - url: https://github.com/xen-project/xen/tree/758f40d7fa7e98ef2d2772ef8f0f57eabde028bd
    reference_type: commit
    reference_id: 758f40d7fa7e98ef2d2772ef8f0f57eabde028bd
  - url: https://github.com/xen-project/xen/tree/7669737d7da5790e66ffb670576175c2465ab09c
    reference_type: commit
    reference_id: 7669737d7da5790e66ffb670576175c2465ab09c
  - url: https://github.com/xen-project/xen/tree/82a94a179cae9fca3ecebe6c26868072088b8e3c
    reference_type: commit
    reference_id: 82a94a179cae9fca3ecebe6c26868072088b8e3c
  - url: https://github.com/xen-project/xen/tree/8cc5036bc385112a82f1faff27a0970e6440dfed
    reference_type: commit
    reference_id: 8cc5036bc385112a82f1faff27a0970e6440dfed
  - url: https://github.com/xen-project/xen/tree/8dab3f79b122e69cbcdebca72cdc14f004ee2193
    reference_type: commit
    reference_id: 8dab3f79b122e69cbcdebca72cdc14f004ee2193
  - url: https://github.com/xen-project/xen/tree/9186e96b199e4f7e52e033b238f9fe869afb69c7
    reference_type: commit
    reference_id: 9186e96b199e4f7e52e033b238f9fe869afb69c7
  - url: https://github.com/xen-project/xen/tree/b152dfbc3ad71a788996440b18174d995c3bffc9
    reference_type: commit
    reference_id: b152dfbc3ad71a788996440b18174d995c3bffc9
  - url: https://github.com/xen-project/xen/tree/c70071eb6c6d43f96d0d9e2f2446de491c8ed527
    reference_type: commit
    reference_id: c70071eb6c6d43f96d0d9e2f2446de491c8ed527
  - url: https://github.com/xen-project/xen/tree/cc74ff882364317e3667c6251cc79bc76fa20ae4
    reference_type: commit
    reference_id: cc74ff882364317e3667c6251cc79bc76fa20ae4
