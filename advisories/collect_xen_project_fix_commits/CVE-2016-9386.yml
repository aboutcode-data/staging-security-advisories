advisory_id: CVE-2016-9386
datasource_id: collect_xen_project_fix_commits/CVE-2016-9386
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  ed77368cc90c9972a747c82bec7c22703bc23184:x86/hvm: Fix the handling of non-present segments

  In 32bit, the data segments may be NULL to indicate that the segment is
  ineligible for use.  In both 32bit and 64bit, the LDT selector may be NULL to
  indicate that the entire LDT is ineligible for use.  However, nothing in Xen
  actually checks for this condition when performing other segmentation
  checks.  (Note however that limit and writeability checks are correctly
  performed).

  Neither Intel nor AMD specify the exact behaviour of loading a NULL segment.
  Experimentally, AMD zeroes all attributes but leaves the base and limit
  unmodified.  Intel zeroes the base, sets the limit to 0xfffffff and resets the
  attributes to just .G and .D/B.

  The use of the segment information in the VMCB/VMCS is equivalent to a native
  pipeline interacting with the segment cache.  The present bit can therefore
  have a subtly different meaning, and it is now cooked to uniformly indicate
  whether the segment is usable or not.

  GDTR and IDTR don't have access rights like the other segments, but for
  consistency, they are treated as being present so no special casing is needed
  elsewhere in the segmentation logic.

  AMD hardware does not consider the present bit for %cs and %tr, and will
  function as if they were present.  They are therefore unconditionally set to
  present when reading information from the VMCB, to maintain the new meaning of
  usability.

  Intel hardware has a separate unusable bit in the VMCS segment attributes.
  This bit is inverted and stored in the present field, so the hvm code can work
  with architecturally-common state.

  This is CVE-2016-9386 / XSA-191.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 04beafa8e6c66f5cd814c00e2d2b51cfbc41cb8a
  master date: 2016-11-22 13:44:50 +0100
  877b7602876b54f2c7c4c19374ee189db6194d73:x86/hvm: Fix the handling of non-present segments

  In 32bit, the data segments may be NULL to indicate that the segment is
  ineligible for use.  In both 32bit and 64bit, the LDT selector may be NULL to
  indicate that the entire LDT is ineligible for use.  However, nothing in Xen
  actually checks for this condition when performing other segmentation
  checks.  (Note however that limit and writeability checks are correctly
  performed).

  Neither Intel nor AMD specify the exact behaviour of loading a NULL segment.
  Experimentally, AMD zeroes all attributes but leaves the base and limit
  unmodified.  Intel zeroes the base, sets the limit to 0xfffffff and resets the
  attributes to just .G and .D/B.

  The use of the segment information in the VMCB/VMCS is equivalent to a native
  pipeline interacting with the segment cache.  The present bit can therefore
  have a subtly different meaning, and it is now cooked to uniformly indicate
  whether the segment is usable or not.

  GDTR and IDTR don't have access rights like the other segments, but for
  consistency, they are treated as being present so no special casing is needed
  elsewhere in the segmentation logic.

  AMD hardware does not consider the present bit for %cs and %tr, and will
  function as if they were present.  They are therefore unconditionally set to
  present when reading information from the VMCB, to maintain the new meaning of
  usability.

  Intel hardware has a separate unusable bit in the VMCS segment attributes.
  This bit is inverted and stored in the present field, so the hvm code can work
  with architecturally-common state.

  This is CVE-2016-9386 / XSA-191.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 04beafa8e6c66f5cd814c00e2d2b51cfbc41cb8a
  master date: 2016-11-22 13:44:50 +0100
  ffda12216868c75d3b2414997cbd847d4deab2d2:x86/hvm: Fix the handling of non-present segments

  In 32bit, the data segments may be NULL to indicate that the segment is
  ineligible for use.  In both 32bit and 64bit, the LDT selector may be NULL to
  indicate that the entire LDT is ineligible for use.  However, nothing in Xen
  actually checks for this condition when performing other segmentation
  checks.  (Note however that limit and writeability checks are correctly
  performed).

  Neither Intel nor AMD specify the exact behaviour of loading a NULL segment.
  Experimentally, AMD zeroes all attributes but leaves the base and limit
  unmodified.  Intel zeroes the base, sets the limit to 0xfffffff and resets the
  attributes to just .G and .D/B.

  The use of the segment information in the VMCB/VMCS is equivalent to a native
  pipeline interacting with the segment cache.  The present bit can therefore
  have a subtly different meaning, and it is now cooked to uniformly indicate
  whether the segment is usable or not.

  GDTR and IDTR don't have access rights like the other segments, but for
  consistency, they are treated as being present so no special casing is needed
  elsewhere in the segmentation logic.

  AMD hardware does not consider the present bit for %cs and %tr, and will
  function as if they were present.  They are therefore unconditionally set to
  present when reading information from the VMCB, to maintain the new meaning of
  usability.

  Intel hardware has a separate unusable bit in the VMCS segment attributes.
  This bit is inverted and stored in the present field, so the hvm code can work
  with architecturally-common state.

  This is CVE-2016-9386 / XSA-191.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 04beafa8e6c66f5cd814c00e2d2b51cfbc41cb8a
  master date: 2016-11-22 13:44:50 +0100
  e98e17e3a5915d9f75fc8ca9624919e02ddc9d4f:x86/hvm: Fix the handling of non-present segments

  In 32bit, the data segments may be NULL to indicate that the segment is
  ineligible for use.  In both 32bit and 64bit, the LDT selector may be NULL to
  indicate that the entire LDT is ineligible for use.  However, nothing in Xen
  actually checks for this condition when performing other segmentation
  checks.  (Note however that limit and writeability checks are correctly
  performed).

  Neither Intel nor AMD specify the exact behaviour of loading a NULL segment.
  Experimentally, AMD zeroes all attributes but leaves the base and limit
  unmodified.  Intel zeroes the base, sets the limit to 0xfffffff and resets the
  attributes to just .G and .D/B.

  The use of the segment information in the VMCB/VMCS is equivalent to a native
  pipeline interacting with the segment cache.  The present bit can therefore
  have a subtly different meaning, and it is now cooked to uniformly indicate
  whether the segment is usable or not.

  GDTR and IDTR don't have access rights like the other segments, but for
  consistency, they are treated as being present so no special casing is needed
  elsewhere in the segmentation logic.

  AMD hardware does not consider the present bit for %cs and %tr, and will
  function as if they were present.  They are therefore unconditionally set to
  present when reading information from the VMCB, to maintain the new meaning of
  usability.

  Intel hardware has a separate unusable bit in the VMCS segment attributes.
  This bit is inverted and stored in the present field, so the hvm code can work
  with architecturally-common state.

  This is CVE-2016-9386 / XSA-191.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
  master commit: 04beafa8e6c66f5cd814c00e2d2b51cfbc41cb8a
  master date: 2016-11-22 13:44:50 +0100
  04beafa8e6c66f5cd814c00e2d2b51cfbc41cb8a:x86/hvm: Fix the handling of non-present segments

  In 32bit, the data segments may be NULL to indicate that the segment is
  ineligible for use.  In both 32bit and 64bit, the LDT selector may be NULL to
  indicate that the entire LDT is ineligible for use.  However, nothing in Xen
  actually checks for this condition when performing other segmentation
  checks.  (Note however that limit and writeability checks are correctly
  performed).

  Neither Intel nor AMD specify the exact behaviour of loading a NULL segment.
  Experimentally, AMD zeroes all attributes but leaves the base and limit
  unmodified.  Intel zeroes the base, sets the limit to 0xfffffff and resets the
  attributes to just .G and .D/B.

  The use of the segment information in the VMCB/VMCS is equivalent to a native
  pipeline interacting with the segment cache.  The present bit can therefore
  have a subtly different meaning, and it is now cooked to uniformly indicate
  whether the segment is usable or not.

  GDTR and IDTR don't have access rights like the other segments, but for
  consistency, they are treated as being present so no special casing is needed
  elsewhere in the segmentation logic.

  AMD hardware does not consider the present bit for %cs and %tr, and will
  function as if they were present.  They are therefore unconditionally set to
  present when reading information from the VMCB, to maintain the new meaning of
  usability.

  Intel hardware has a separate unusable bit in the VMCS segment attributes.
  This bit is inverted and stored in the present field, so the hvm code can work
  with architecturally-common state.

  This is CVE-2016-9386 / XSA-191.

  Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Reviewed-by: Jan Beulich <jbeulich@suse.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: ffda12216868c75d3b2414997cbd847d4deab2d2
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: ed77368cc90c9972a747c82bec7c22703bc23184
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: e98e17e3a5915d9f75fc8ca9624919e02ddc9d4f
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 04beafa8e6c66f5cd814c00e2d2b51cfbc41cb8a
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 877b7602876b54f2c7c4c19374ee189db6194d73
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/04beafa8e6c66f5cd814c00e2d2b51cfbc41cb8a
    reference_type: commit
    reference_id: 04beafa8e6c66f5cd814c00e2d2b51cfbc41cb8a
  - url: https://github.com/xen-project/xen/tree/877b7602876b54f2c7c4c19374ee189db6194d73
    reference_type: commit
    reference_id: 877b7602876b54f2c7c4c19374ee189db6194d73
  - url: https://github.com/xen-project/xen/tree/e98e17e3a5915d9f75fc8ca9624919e02ddc9d4f
    reference_type: commit
    reference_id: e98e17e3a5915d9f75fc8ca9624919e02ddc9d4f
  - url: https://github.com/xen-project/xen/tree/ed77368cc90c9972a747c82bec7c22703bc23184
    reference_type: commit
    reference_id: ed77368cc90c9972a747c82bec7c22703bc23184
  - url: https://github.com/xen-project/xen/tree/ffda12216868c75d3b2414997cbd847d4deab2d2
    reference_type: commit
    reference_id: ffda12216868c75d3b2414997cbd847d4deab2d2
