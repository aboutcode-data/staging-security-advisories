advisory_id: CVE-2022-42310
datasource_id: collect_xen_project_fix_commits/CVE-2022-42310
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  fcba6c74e1493a329563208ed1f3014dab54bd47:tools/xenstore: Fail a transaction if it is not possible to create a node

  Commit f2bebf72c4d5 "xenstore: rework of transaction handling" moved
  out from copying the entire database everytime a new transaction is
  opened to track the list of nodes changed.

  The content of all the nodes accessed during a transaction will be
  temporarily stored in TDB using a different key.

  The function create_node() may write/update multiple nodes if the child
  doesn't exist. In case of a failure, the function will revert any
  changes (this include any update to TDB). Unfortunately, the function
  which reverts the changes (i.e. destroy_node()) will not use the correct
  key to delete any update or even request the transaction to fail.

  This means that if a client decide to go ahead with committing the
  transaction, orphan nodes will be created because they were not linked
  to an existing node (create_node() will write the nodes backwards).

  Once some nodes have been partially updated in a transaction, it is not
  easily possible to undo any changes. So rather than continuing and hit
  weird issue while committing, it is much saner to fail the transaction.

  This will have an impact on any client that decides to commit even if it
  can't write a node. Although, it is not clear why a normal client would
  want to do that...

  Lastly, update destroy_node() to use the correct key for deleting the
  node. Rather than recreating it (this will allocate memory and
  therefore fail), stash the key in the structure node.

  This is XSA-415 / CVE-2022-42310.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Reviewed-by: Juergen Gross <jgross@suse.com>
  (cherry picked from commit 5d71766bd1a4a3a8b2fe952ca2be80e02fe48f34)
  bd50953ef300049cc2d20fdc5a34b90a97b6abc0:tools/xenstore: Fail a transaction if it is not possible to create a node

  Commit f2bebf72c4d5 "xenstore: rework of transaction handling" moved
  out from copying the entire database everytime a new transaction is
  opened to track the list of nodes changed.

  The content of all the nodes accessed during a transaction will be
  temporarily stored in TDB using a different key.

  The function create_node() may write/update multiple nodes if the child
  doesn't exist. In case of a failure, the function will revert any
  changes (this include any update to TDB). Unfortunately, the function
  which reverts the changes (i.e. destroy_node()) will not use the correct
  key to delete any update or even request the transaction to fail.

  This means that if a client decide to go ahead with committing the
  transaction, orphan nodes will be created because they were not linked
  to an existing node (create_node() will write the nodes backwards).

  Once some nodes have been partially updated in a transaction, it is not
  easily possible to undo any changes. So rather than continuing and hit
  weird issue while committing, it is much saner to fail the transaction.

  This will have an impact on any client that decides to commit even if it
  can't write a node. Although, it is not clear why a normal client would
  want to do that...

  Lastly, update destroy_node() to use the correct key for deleting the
  node. Rather than recreating it (this will allocate memory and
  therefore fail), stash the key in the structure node.

  This is XSA-415 / CVE-2022-42310.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Reviewed-by: Juergen Gross <jgross@suse.com>
  (cherry picked from commit 5d71766bd1a4a3a8b2fe952ca2be80e02fe48f34)
  579e7334b909c22efc65c5df22e8afe414882154:tools/xenstore: Fail a transaction if it is not possible to create a node

  Commit f2bebf72c4d5 "xenstore: rework of transaction handling" moved
  out from copying the entire database everytime a new transaction is
  opened to track the list of nodes changed.

  The content of all the nodes accessed during a transaction will be
  temporarily stored in TDB using a different key.

  The function create_node() may write/update multiple nodes if the child
  doesn't exist. In case of a failure, the function will revert any
  changes (this include any update to TDB). Unfortunately, the function
  which reverts the changes (i.e. destroy_node()) will not use the correct
  key to delete any update or even request the transaction to fail.

  This means that if a client decide to go ahead with committing the
  transaction, orphan nodes will be created because they were not linked
  to an existing node (create_node() will write the nodes backwards).

  Once some nodes have been partially updated in a transaction, it is not
  easily possible to undo any changes. So rather than continuing and hit
  weird issue while committing, it is much saner to fail the transaction.

  This will have an impact on any client that decides to commit even if it
  can't write a node. Although, it is not clear why a normal client would
  want to do that...

  Lastly, update destroy_node() to use the correct key for deleting the
  node. Rather than recreating it (this will allocate memory and
  therefore fail), stash the key in the structure node.

  This is XSA-415 / CVE-2022-42310.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Reviewed-by: Juergen Gross <jgross@suse.com>
  (cherry picked from commit 5d71766bd1a4a3a8b2fe952ca2be80e02fe48f34)
  427e86b48836a9511f57004ca367283cd85cd30f:tools/xenstore: Fail a transaction if it is not possible to create a node

  Commit f2bebf72c4d5 "xenstore: rework of transaction handling" moved
  out from copying the entire database everytime a new transaction is
  opened to track the list of nodes changed.

  The content of all the nodes accessed during a transaction will be
  temporarily stored in TDB using a different key.

  The function create_node() may write/update multiple nodes if the child
  doesn't exist. In case of a failure, the function will revert any
  changes (this include any update to TDB). Unfortunately, the function
  which reverts the changes (i.e. destroy_node()) will not use the correct
  key to delete any update or even request the transaction to fail.

  This means that if a client decide to go ahead with committing the
  transaction, orphan nodes will be created because they were not linked
  to an existing node (create_node() will write the nodes backwards).

  Once some nodes have been partially updated in a transaction, it is not
  easily possible to undo any changes. So rather than continuing and hit
  weird issue while committing, it is much saner to fail the transaction.

  This will have an impact on any client that decides to commit even if it
  can't write a node. Although, it is not clear why a normal client would
  want to do that...

  Lastly, update destroy_node() to use the correct key for deleting the
  node. Rather than recreating it (this will allocate memory and
  therefore fail), stash the key in the structure node.

  This is XSA-415 / CVE-2022-42310.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Reviewed-by: Juergen Gross <jgross@suse.com>
  (cherry picked from commit 5d71766bd1a4a3a8b2fe952ca2be80e02fe48f34)
  5d71766bd1a4a3a8b2fe952ca2be80e02fe48f34:tools/xenstore: Fail a transaction if it is not possible to create a node

  Commit f2bebf72c4d5 "xenstore: rework of transaction handling" moved
  out from copying the entire database everytime a new transaction is
  opened to track the list of nodes changed.

  The content of all the nodes accessed during a transaction will be
  temporarily stored in TDB using a different key.

  The function create_node() may write/update multiple nodes if the child
  doesn't exist. In case of a failure, the function will revert any
  changes (this include any update to TDB). Unfortunately, the function
  which reverts the changes (i.e. destroy_node()) will not use the correct
  key to delete any update or even request the transaction to fail.

  This means that if a client decide to go ahead with committing the
  transaction, orphan nodes will be created because they were not linked
  to an existing node (create_node() will write the nodes backwards).

  Once some nodes have been partially updated in a transaction, it is not
  easily possible to undo any changes. So rather than continuing and hit
  weird issue while committing, it is much saner to fail the transaction.

  This will have an impact on any client that decides to commit even if it
  can't write a node. Although, it is not clear why a normal client would
  want to do that...

  Lastly, update destroy_node() to use the correct key for deleting the
  node. Rather than recreating it (this will allocate memory and
  therefore fail), stash the key in the structure node.

  This is XSA-415 / CVE-2022-42310.

  Signed-off-by: Julien Grall <jgrall@amazon.com>
  Reviewed-by: Juergen Gross <jgross@suse.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: fcba6c74e1493a329563208ed1f3014dab54bd47
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: bd50953ef300049cc2d20fdc5a34b90a97b6abc0
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 5d71766bd1a4a3a8b2fe952ca2be80e02fe48f34
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 427e86b48836a9511f57004ca367283cd85cd30f
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 579e7334b909c22efc65c5df22e8afe414882154
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/427e86b48836a9511f57004ca367283cd85cd30f
    reference_type: commit
    reference_id: 427e86b48836a9511f57004ca367283cd85cd30f
  - url: https://github.com/xen-project/xen/tree/579e7334b909c22efc65c5df22e8afe414882154
    reference_type: commit
    reference_id: 579e7334b909c22efc65c5df22e8afe414882154
  - url: https://github.com/xen-project/xen/tree/5d71766bd1a4a3a8b2fe952ca2be80e02fe48f34
    reference_type: commit
    reference_id: 5d71766bd1a4a3a8b2fe952ca2be80e02fe48f34
  - url: https://github.com/xen-project/xen/tree/bd50953ef300049cc2d20fdc5a34b90a97b6abc0
    reference_type: commit
    reference_id: bd50953ef300049cc2d20fdc5a34b90a97b6abc0
  - url: https://github.com/xen-project/xen/tree/fcba6c74e1493a329563208ed1f3014dab54bd47
    reference_type: commit
    reference_id: fcba6c74e1493a329563208ed1f3014dab54bd47
