advisory_id: CVE-2021-28698
datasource_id: collect_xen_project_fix_commits/CVE-2021-28698
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  a7599f030881b5e1aca63462712011f52222a56b:gnttab: replace mapkind()

  mapkind() doesn't scale very well with larger maptrack entry counts,
  using a brute force linear search through all entries, with the only
  option of an early loop exit if a matching writable entry was found.
  Introduce a radix tree alongside the main maptrack table, thus
  allowing much faster MFN-based lookup. To avoid the need to actually
  allocate space for the individual nodes, encode the two counters in the
  node pointers themselves, thus limiting the number of permitted
  simultaneous r/o and r/w mappings of the same MFN to 2³¹-1 (64-bit) /
  2¹⁵-1 (32-bit) each.

  To avoid enforcing an unnecessarily low bound on the number of
  simultaneous mappings of a single MFN, introduce
  radix_tree_{ulong_to_ptr,ptr_to_ulong} paralleling
  radix_tree_{int_to_ptr,ptr_to_int}.

  As a consequence locking changes are also applicable: With there no
  longer being any inspection of the remote domain's active entries,
  there's also no need anymore to hold the remote domain's grant table
  lock. And since we're no longer iterating over the local domain's map
  track table, the lock in map_grant_ref() can also be dropped before the
  new maptrack entry actually gets populated.

  As a nice side effect this also reduces the number of IOMMU operations
  in unmap_common(): Previously we would have "established" a readable
  mapping whenever we didn't find a writable entry anymore (yet, of
  course, at least one readable one). But we only need to do this if we
  actually dropped the last writable entry, not if there were none already
  before.

  This is part of CVE-2021-28698 / XSA-380.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: 9781b51efde251efcc0291ddb1d9c7cefe2b2555
  master date: 2021-08-25 14:18:39 +0200
  02c696719301cdb22bf2f029deae14efc7c41b42:gnttab: add preemption check to gnttab_release_mappings()

  A guest may die with many grant mappings still in place, or simply with
  a large maptrack table. Iterating through this may take more time than
  is reasonable without intermediate preemption (to run softirqs and
  perhaps the scheduler).

  Move the invocation of the function to the section where other
  restartable functions get invoked, and have the function itself check
  for preemption every once in a while. Have it iterate the table
  backwards, such that decreasing the maptrack limit is all it takes to
  convey restart information.

  In domain_teardown() introduce PROG_none such that inserting at the
  front will be easier going forward.

  This is part of CVE-2021-28698 / XSA-380.

  Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: b1ee10be5625b7d502cef1e6ee3818610ab0d29c
  master date: 2021-08-25 14:18:18 +0200
  090986baef8956eba86ed1f51f4013eb7984298d:gnttab: replace mapkind()

  mapkind() doesn't scale very well with larger maptrack entry counts,
  using a brute force linear search through all entries, with the only
  option of an early loop exit if a matching writable entry was found.
  Introduce a radix tree alongside the main maptrack table, thus
  allowing much faster MFN-based lookup. To avoid the need to actually
  allocate space for the individual nodes, encode the two counters in the
  node pointers themselves, thus limiting the number of permitted
  simultaneous r/o and r/w mappings of the same MFN to 2³¹-1 (64-bit) /
  2¹⁵-1 (32-bit) each.

  To avoid enforcing an unnecessarily low bound on the number of
  simultaneous mappings of a single MFN, introduce
  radix_tree_{ulong_to_ptr,ptr_to_ulong} paralleling
  radix_tree_{int_to_ptr,ptr_to_int}.

  As a consequence locking changes are also applicable: With there no
  longer being any inspection of the remote domain's active entries,
  there's also no need anymore to hold the remote domain's grant table
  lock. And since we're no longer iterating over the local domain's map
  track table, the lock in map_grant_ref() can also be dropped before the
  new maptrack entry actually gets populated.

  As a nice side effect this also reduces the number of IOMMU operations
  in unmap_common(): Previously we would have "established" a readable
  mapping whenever we didn't find a writable entry anymore (yet, of
  course, at least one readable one). But we only need to do this if we
  actually dropped the last writable entry, not if there were none already
  before.

  This is part of CVE-2021-28698 / XSA-380.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: 9781b51efde251efcc0291ddb1d9c7cefe2b2555
  master date: 2021-08-25 14:18:39 +0200
  e8f95a693826bfb5a87bbb6998313a5b7bff0737:gnttab: add preemption check to gnttab_release_mappings()

  A guest may die with many grant mappings still in place, or simply with
  a large maptrack table. Iterating through this may take more time than
  is reasonable without intermediate preemption (to run softirqs and
  perhaps the scheduler).

  Move the invocation of the function to the section where other
  restartable functions get invoked, and have the function itself check
  for preemption every once in a while. Have it iterate the table
  backwards, such that decreasing the maptrack limit is all it takes to
  convey restart information.

  In domain_teardown() introduce PROG_none such that inserting at the
  front will be easier going forward.

  This is part of CVE-2021-28698 / XSA-380.

  Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: b1ee10be5625b7d502cef1e6ee3818610ab0d29c
  master date: 2021-08-25 14:18:18 +0200
  4d65fe936a8b99603e9f2457e1b3ec6b6a1a2b60:gnttab: replace mapkind()

  mapkind() doesn't scale very well with larger maptrack entry counts,
  using a brute force linear search through all entries, with the only
  option of an early loop exit if a matching writable entry was found.
  Introduce a radix tree alongside the main maptrack table, thus
  allowing much faster MFN-based lookup. To avoid the need to actually
  allocate space for the individual nodes, encode the two counters in the
  node pointers themselves, thus limiting the number of permitted
  simultaneous r/o and r/w mappings of the same MFN to 2³¹-1 (64-bit) /
  2¹⁵-1 (32-bit) each.

  To avoid enforcing an unnecessarily low bound on the number of
  simultaneous mappings of a single MFN, introduce
  radix_tree_{ulong_to_ptr,ptr_to_ulong} paralleling
  radix_tree_{int_to_ptr,ptr_to_int}.

  As a consequence locking changes are also applicable: With there no
  longer being any inspection of the remote domain's active entries,
  there's also no need anymore to hold the remote domain's grant table
  lock. And since we're no longer iterating over the local domain's map
  track table, the lock in map_grant_ref() can also be dropped before the
  new maptrack entry actually gets populated.

  As a nice side effect this also reduces the number of IOMMU operations
  in unmap_common(): Previously we would have "established" a readable
  mapping whenever we didn't find a writable entry anymore (yet, of
  course, at least one readable one). But we only need to do this if we
  actually dropped the last writable entry, not if there were none already
  before.

  This is part of CVE-2021-28698 / XSA-380.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: 9781b51efde251efcc0291ddb1d9c7cefe2b2555
  master date: 2021-08-25 14:18:39 +0200
  9d954c8c1a3e3cd70cddf9dbf7da7305de9b1173:gnttab: add preemption check to gnttab_release_mappings()

  A guest may die with many grant mappings still in place, or simply with
  a large maptrack table. Iterating through this may take more time than
  is reasonable without intermediate preemption (to run softirqs and
  perhaps the scheduler).

  Move the invocation of the function to the section where other
  restartable functions get invoked, and have the function itself check
  for preemption every once in a while. Have it iterate the table
  backwards, such that decreasing the maptrack limit is all it takes to
  convey restart information.

  In domain_teardown() introduce PROG_none such that inserting at the
  front will be easier going forward.

  This is part of CVE-2021-28698 / XSA-380.

  Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: b1ee10be5625b7d502cef1e6ee3818610ab0d29c
  master date: 2021-08-25 14:18:18 +0200
  b81187fc4032be56be712f0126c7215f243093ed:gnttab: replace mapkind()

  mapkind() doesn't scale very well with larger maptrack entry counts,
  using a brute force linear search through all entries, with the only
  option of an early loop exit if a matching writable entry was found.
  Introduce a radix tree alongside the main maptrack table, thus
  allowing much faster MFN-based lookup. To avoid the need to actually
  allocate space for the individual nodes, encode the two counters in the
  node pointers themselves, thus limiting the number of permitted
  simultaneous r/o and r/w mappings of the same MFN to 2³¹-1 (64-bit) /
  2¹⁵-1 (32-bit) each.

  To avoid enforcing an unnecessarily low bound on the number of
  simultaneous mappings of a single MFN, introduce
  radix_tree_{ulong_to_ptr,ptr_to_ulong} paralleling
  radix_tree_{int_to_ptr,ptr_to_int}.

  As a consequence locking changes are also applicable: With there no
  longer being any inspection of the remote domain's active entries,
  there's also no need anymore to hold the remote domain's grant table
  lock. And since we're no longer iterating over the local domain's map
  track table, the lock in map_grant_ref() can also be dropped before the
  new maptrack entry actually gets populated.

  As a nice side effect this also reduces the number of IOMMU operations
  in unmap_common(): Previously we would have "established" a readable
  mapping whenever we didn't find a writable entry anymore (yet, of
  course, at least one readable one). But we only need to do this if we
  actually dropped the last writable entry, not if there were none already
  before.

  This is part of CVE-2021-28698 / XSA-380.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: 9781b51efde251efcc0291ddb1d9c7cefe2b2555
  master date: 2021-08-25 14:18:39 +0200
  29aeeda345168a70facfd7c7ef16fbea6d447061:gnttab: add preemption check to gnttab_release_mappings()

  A guest may die with many grant mappings still in place, or simply with
  a large maptrack table. Iterating through this may take more time than
  is reasonable without intermediate preemption (to run softirqs and
  perhaps the scheduler).

  Move the invocation of the function to the section where other
  restartable functions get invoked, and have the function itself check
  for preemption every once in a while. Have it iterate the table
  backwards, such that decreasing the maptrack limit is all it takes to
  convey restart information.

  In domain_teardown() introduce PROG_none such that inserting at the
  front will be easier going forward.

  This is part of CVE-2021-28698 / XSA-380.

  Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: b1ee10be5625b7d502cef1e6ee3818610ab0d29c
  master date: 2021-08-25 14:18:18 +0200
  2f6ebcec023be0b0873a5e67ce3a0ab301dbac4f:gnttab: replace mapkind()

  mapkind() doesn't scale very well with larger maptrack entry counts,
  using a brute force linear search through all entries, with the only
  option of an early loop exit if a matching writable entry was found.
  Introduce a radix tree alongside the main maptrack table, thus
  allowing much faster MFN-based lookup. To avoid the need to actually
  allocate space for the individual nodes, encode the two counters in the
  node pointers themselves, thus limiting the number of permitted
  simultaneous r/o and r/w mappings of the same MFN to 2³¹-1 (64-bit) /
  2¹⁵-1 (32-bit) each.

  To avoid enforcing an unnecessarily low bound on the number of
  simultaneous mappings of a single MFN, introduce
  radix_tree_{ulong_to_ptr,ptr_to_ulong} paralleling
  radix_tree_{int_to_ptr,ptr_to_int}.

  As a consequence locking changes are also applicable: With there no
  longer being any inspection of the remote domain's active entries,
  there's also no need anymore to hold the remote domain's grant table
  lock. And since we're no longer iterating over the local domain's map
  track table, the lock in map_grant_ref() can also be dropped before the
  new maptrack entry actually gets populated.

  As a nice side effect this also reduces the number of IOMMU operations
  in unmap_common(): Previously we would have "established" a readable
  mapping whenever we didn't find a writable entry anymore (yet, of
  course, at least one readable one). But we only need to do this if we
  actually dropped the last writable entry, not if there were none already
  before.

  This is part of CVE-2021-28698 / XSA-380.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: 9781b51efde251efcc0291ddb1d9c7cefe2b2555
  master date: 2021-08-25 14:18:39 +0200
  9bfbde40bc268dc479dde785d2435fd5a2e61efd:gnttab: add preemption check to gnttab_release_mappings()

  A guest may die with many grant mappings still in place, or simply with
  a large maptrack table. Iterating through this may take more time than
  is reasonable without intermediate preemption (to run softirqs and
  perhaps the scheduler).

  Move the invocation of the function to the section where other
  restartable functions get invoked, and have the function itself check
  for preemption every once in a while. Have it iterate the table
  backwards, such that decreasing the maptrack limit is all it takes to
  convey restart information.

  In domain_teardown() introduce PROG_none such that inserting at the
  front will be easier going forward.

  This is part of CVE-2021-28698 / XSA-380.

  Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: b1ee10be5625b7d502cef1e6ee3818610ab0d29c
  master date: 2021-08-25 14:18:18 +0200
  9781b51efde251efcc0291ddb1d9c7cefe2b2555:gnttab: replace mapkind()

  mapkind() doesn't scale very well with larger maptrack entry counts,
  using a brute force linear search through all entries, with the only
  option of an early loop exit if a matching writable entry was found.
  Introduce a radix tree alongside the main maptrack table, thus
  allowing much faster MFN-based lookup. To avoid the need to actually
  allocate space for the individual nodes, encode the two counters in the
  node pointers themselves, thus limiting the number of permitted
  simultaneous r/o and r/w mappings of the same MFN to 2³¹-1 (64-bit) /
  2¹⁵-1 (32-bit) each.

  To avoid enforcing an unnecessarily low bound on the number of
  simultaneous mappings of a single MFN, introduce
  radix_tree_{ulong_to_ptr,ptr_to_ulong} paralleling
  radix_tree_{int_to_ptr,ptr_to_int}.

  As a consequence locking changes are also applicable: With there no
  longer being any inspection of the remote domain's active entries,
  there's also no need anymore to hold the remote domain's grant table
  lock. And since we're no longer iterating over the local domain's map
  track table, the lock in map_grant_ref() can also be dropped before the
  new maptrack entry actually gets populated.

  As a nice side effect this also reduces the number of IOMMU operations
  in unmap_common(): Previously we would have "established" a readable
  mapping whenever we didn't find a writable entry anymore (yet, of
  course, at least one readable one). But we only need to do this if we
  actually dropped the last writable entry, not if there were none already
  before.

  This is part of CVE-2021-28698 / XSA-380.

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  b1ee10be5625b7d502cef1e6ee3818610ab0d29c:gnttab: add preemption check to gnttab_release_mappings()

  A guest may die with many grant mappings still in place, or simply with
  a large maptrack table. Iterating through this may take more time than
  is reasonable without intermediate preemption (to run softirqs and
  perhaps the scheduler).

  Move the invocation of the function to the section where other
  restartable functions get invoked, and have the function itself check
  for preemption every once in a while. Have it iterate the table
  backwards, such that decreasing the maptrack limit is all it takes to
  convey restart information.

  In domain_teardown() introduce PROG_none such that inserting at the
  front will be easier going forward.

  This is part of CVE-2021-28698 / XSA-380.

  Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 090986baef8956eba86ed1f51f4013eb7984298d
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 4d65fe936a8b99603e9f2457e1b3ec6b6a1a2b60
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 29aeeda345168a70facfd7c7ef16fbea6d447061
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 02c696719301cdb22bf2f029deae14efc7c41b42
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: e8f95a693826bfb5a87bbb6998313a5b7bff0737
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 9d954c8c1a3e3cd70cddf9dbf7da7305de9b1173
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 9781b51efde251efcc0291ddb1d9c7cefe2b2555
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: b81187fc4032be56be712f0126c7215f243093ed
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: b1ee10be5625b7d502cef1e6ee3818610ab0d29c
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: a7599f030881b5e1aca63462712011f52222a56b
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 9bfbde40bc268dc479dde785d2435fd5a2e61efd
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 2f6ebcec023be0b0873a5e67ce3a0ab301dbac4f
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/02c696719301cdb22bf2f029deae14efc7c41b42
    reference_type: commit
    reference_id: 02c696719301cdb22bf2f029deae14efc7c41b42
  - url: https://github.com/xen-project/xen/tree/090986baef8956eba86ed1f51f4013eb7984298d
    reference_type: commit
    reference_id: 090986baef8956eba86ed1f51f4013eb7984298d
  - url: https://github.com/xen-project/xen/tree/29aeeda345168a70facfd7c7ef16fbea6d447061
    reference_type: commit
    reference_id: 29aeeda345168a70facfd7c7ef16fbea6d447061
  - url: https://github.com/xen-project/xen/tree/2f6ebcec023be0b0873a5e67ce3a0ab301dbac4f
    reference_type: commit
    reference_id: 2f6ebcec023be0b0873a5e67ce3a0ab301dbac4f
  - url: https://github.com/xen-project/xen/tree/4d65fe936a8b99603e9f2457e1b3ec6b6a1a2b60
    reference_type: commit
    reference_id: 4d65fe936a8b99603e9f2457e1b3ec6b6a1a2b60
  - url: https://github.com/xen-project/xen/tree/9781b51efde251efcc0291ddb1d9c7cefe2b2555
    reference_type: commit
    reference_id: 9781b51efde251efcc0291ddb1d9c7cefe2b2555
  - url: https://github.com/xen-project/xen/tree/9bfbde40bc268dc479dde785d2435fd5a2e61efd
    reference_type: commit
    reference_id: 9bfbde40bc268dc479dde785d2435fd5a2e61efd
  - url: https://github.com/xen-project/xen/tree/9d954c8c1a3e3cd70cddf9dbf7da7305de9b1173
    reference_type: commit
    reference_id: 9d954c8c1a3e3cd70cddf9dbf7da7305de9b1173
  - url: https://github.com/xen-project/xen/tree/a7599f030881b5e1aca63462712011f52222a56b
    reference_type: commit
    reference_id: a7599f030881b5e1aca63462712011f52222a56b
  - url: https://github.com/xen-project/xen/tree/b1ee10be5625b7d502cef1e6ee3818610ab0d29c
    reference_type: commit
    reference_id: b1ee10be5625b7d502cef1e6ee3818610ab0d29c
  - url: https://github.com/xen-project/xen/tree/b81187fc4032be56be712f0126c7215f243093ed
    reference_type: commit
    reference_id: b81187fc4032be56be712f0126c7215f243093ed
  - url: https://github.com/xen-project/xen/tree/e8f95a693826bfb5a87bbb6998313a5b7bff0737
    reference_type: commit
    reference_id: e8f95a693826bfb5a87bbb6998313a5b7bff0737
