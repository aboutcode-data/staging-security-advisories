advisory_id: CVE-2023-46837
datasource_id: collect_xen_project_fix_commits/CVE-2023-46837
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  6400013f07e5c7fec9f68821755aed94683b663c:xen/arm: page: Avoid pointer overflow on cache clean & invalidate

  On Arm32, after cleaning and invalidating the last dcache line of the top
  domheap page i.e. VA = 0xfffff000 (as a result of flushing the page to
  RAM), we end up adding the value of a dcache line size to the pointer
  once again, which results in a pointer arithmetic overflow (with 64B line
  size, operation 0xffffffc0 + 0x40 overflows to 0x0). Such behavior is
  undefined and given the wide range of compiler versions we support, it is
  difficult to determine what could happen in such scenario.

  Modify clean_and_invalidate_dcache_va_range() as well as
  clean_dcache_va_range() and invalidate_dcache_va_range() due to similarity
  of handling to prevent pointer arithmetic overflow. Modify the loops to
  use an additional variable to store the index of the next cacheline.
  Add an assert to prevent passing a region that wraps around which is
  illegal and would end up in a page fault anyway (region 0-2MB is
  unmapped). Lastly, return early if size passed is 0.

  Note that on Arm64, we don't have this problem given that the max VA
  space we support is 48-bits.

  This is XSA-447 / CVE-2023-46837.

  Signed-off-by: Michal Orzel <michal.orzel@amd.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: 190b7f49af6487a9665da63d43adc9d9a5fbd01e
  master date: 2023-12-12 14:01:00 +0100
  e7c3d6ceaf73120098f9213fd12f79fd50e8e588:xen/arm: page: Avoid pointer overflow on cache clean & invalidate

  On Arm32, after cleaning and invalidating the last dcache line of the top
  domheap page i.e. VA = 0xfffff000 (as a result of flushing the page to
  RAM), we end up adding the value of a dcache line size to the pointer
  once again, which results in a pointer arithmetic overflow (with 64B line
  size, operation 0xffffffc0 + 0x40 overflows to 0x0). Such behavior is
  undefined and given the wide range of compiler versions we support, it is
  difficult to determine what could happen in such scenario.

  Modify clean_and_invalidate_dcache_va_range() as well as
  clean_dcache_va_range() and invalidate_dcache_va_range() due to similarity
  of handling to prevent pointer arithmetic overflow. Modify the loops to
  use an additional variable to store the index of the next cacheline.
  Add an assert to prevent passing a region that wraps around which is
  illegal and would end up in a page fault anyway (region 0-2MB is
  unmapped). Lastly, return early if size passed is 0.

  Note that on Arm64, we don't have this problem given that the max VA
  space we support is 48-bits.

  This is XSA-447 / CVE-2023-46837.

  Signed-off-by: Michal Orzel <michal.orzel@amd.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: 190b7f49af6487a9665da63d43adc9d9a5fbd01e
  master date: 2023-12-12 14:01:00 +0100
  958706fd2e178ffe8e5597b05b694b494e24258b:xen/arm: page: Avoid pointer overflow on cache clean & invalidate

  On Arm32, after cleaning and invalidating the last dcache line of the top
  domheap page i.e. VA = 0xfffff000 (as a result of flushing the page to
  RAM), we end up adding the value of a dcache line size to the pointer
  once again, which results in a pointer arithmetic overflow (with 64B line
  size, operation 0xffffffc0 + 0x40 overflows to 0x0). Such behavior is
  undefined and given the wide range of compiler versions we support, it is
  difficult to determine what could happen in such scenario.

  Modify clean_and_invalidate_dcache_va_range() as well as
  clean_dcache_va_range() and invalidate_dcache_va_range() due to similarity
  of handling to prevent pointer arithmetic overflow. Modify the loops to
  use an additional variable to store the index of the next cacheline.
  Add an assert to prevent passing a region that wraps around which is
  illegal and would end up in a page fault anyway (region 0-2MB is
  unmapped). Lastly, return early if size passed is 0.

  Note that on Arm64, we don't have this problem given that the max VA
  space we support is 48-bits.

  This is XSA-447 / CVE-2023-46837.

  Signed-off-by: Michal Orzel <michal.orzel@amd.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: 190b7f49af6487a9665da63d43adc9d9a5fbd01e
  master date: 2023-12-12 14:01:00 +0100
  a4f3f5a62c10a5adc898cf45261783209f5bc037:xen/arm: page: Avoid pointer overflow on cache clean & invalidate

  On Arm32, after cleaning and invalidating the last dcache line of the top
  domheap page i.e. VA = 0xfffff000 (as a result of flushing the page to
  RAM), we end up adding the value of a dcache line size to the pointer
  once again, which results in a pointer arithmetic overflow (with 64B line
  size, operation 0xffffffc0 + 0x40 overflows to 0x0). Such behavior is
  undefined and given the wide range of compiler versions we support, it is
  difficult to determine what could happen in such scenario.

  Modify clean_and_invalidate_dcache_va_range() as well as
  clean_dcache_va_range() and invalidate_dcache_va_range() due to similarity
  of handling to prevent pointer arithmetic overflow. Modify the loops to
  use an additional variable to store the index of the next cacheline.
  Add an assert to prevent passing a region that wraps around which is
  illegal and would end up in a page fault anyway (region 0-2MB is
  unmapped). Lastly, return early if size passed is 0.

  Note that on Arm64, we don't have this problem given that the max VA
  space we support is 48-bits.

  This is XSA-447 / CVE-2023-46837.

  Signed-off-by: Michal Orzel <michal.orzel@amd.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
  master commit: 190b7f49af6487a9665da63d43adc9d9a5fbd01e
  master date: 2023-12-12 14:01:00 +0100
  190b7f49af6487a9665da63d43adc9d9a5fbd01e:xen/arm: page: Avoid pointer overflow on cache clean & invalidate

  On Arm32, after cleaning and invalidating the last dcache line of the top
  domheap page i.e. VA = 0xfffff000 (as a result of flushing the page to
  RAM), we end up adding the value of a dcache line size to the pointer
  once again, which results in a pointer arithmetic overflow (with 64B line
  size, operation 0xffffffc0 + 0x40 overflows to 0x0). Such behavior is
  undefined and given the wide range of compiler versions we support, it is
  difficult to determine what could happen in such scenario.

  Modify clean_and_invalidate_dcache_va_range() as well as
  clean_dcache_va_range() and invalidate_dcache_va_range() due to similarity
  of handling to prevent pointer arithmetic overflow. Modify the loops to
  use an additional variable to store the index of the next cacheline.
  Add an assert to prevent passing a region that wraps around which is
  illegal and would end up in a page fault anyway (region 0-2MB is
  unmapped). Lastly, return early if size passed is 0.

  Note that on Arm64, we don't have this problem given that the max VA
  space we support is 48-bits.

  This is XSA-447 / CVE-2023-46837.

  Signed-off-by: Michal Orzel <michal.orzel@amd.com>
  Reviewed-by: Julien Grall <jgrall@amazon.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: e7c3d6ceaf73120098f9213fd12f79fd50e8e588
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: '190b7f49af6487a9665da63d43adc9d9a5fbd01e'
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 6400013f07e5c7fec9f68821755aed94683b663c
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 958706fd2e178ffe8e5597b05b694b494e24258b
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: a4f3f5a62c10a5adc898cf45261783209f5bc037
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/190b7f49af6487a9665da63d43adc9d9a5fbd01e
    reference_type: commit
    reference_id: '190b7f49af6487a9665da63d43adc9d9a5fbd01e'
  - url: https://github.com/xen-project/xen/tree/6400013f07e5c7fec9f68821755aed94683b663c
    reference_type: commit
    reference_id: 6400013f07e5c7fec9f68821755aed94683b663c
  - url: https://github.com/xen-project/xen/tree/958706fd2e178ffe8e5597b05b694b494e24258b
    reference_type: commit
    reference_id: 958706fd2e178ffe8e5597b05b694b494e24258b
  - url: https://github.com/xen-project/xen/tree/a4f3f5a62c10a5adc898cf45261783209f5bc037
    reference_type: commit
    reference_id: a4f3f5a62c10a5adc898cf45261783209f5bc037
  - url: https://github.com/xen-project/xen/tree/e7c3d6ceaf73120098f9213fd12f79fd50e8e588
    reference_type: commit
    reference_id: e7c3d6ceaf73120098f9213fd12f79fd50e8e588
