advisory_id: CVE-2017-12136
datasource_id: collect_xen_project_fix_commits/CVE-2017-12136
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  f974d3211ee7431ac45c401a88d6b436ce5c0c3c:gnttab: split maptrack lock to make it fulfill its purpose again

  The way the lock is currently being used in get_maptrack_handle(), it
  protects only the maptrack limit: The function acts on current's list
  only, so races on list accesses are impossible even without the lock.

  Otoh list access races are possible between __get_maptrack_handle() and
  put_maptrack_handle(), due to the invocation of the former for other
  than current from steal_maptrack_handle(). Introduce a per-vCPU lock
  for list accesses to become race free again. This lock will be
  uncontended except when it becomes necessary to take the steal path,
  i.e. in the common case there should be no meaningful performance
  impact.

  When in get_maptrack_handle adds a stolen entry to a fresh, empty,
  freelist, we think that there is probably no concurrency.  However,
  this is not a fast path and adding the locking there makes the code
  clearly correct.

  Also, while we are here: the stolen maptrack_entry's tail pointer was
  not properly set.  Set it.

  This is CVE-2017-12136 / XSA-228.

  Reported-by: Ian Jackson <ian.jackson@eu.citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Signed-off-by: Ian Jackson <Ian.Jackson@eu.citrix.com>
  master commit: 02cbeeb6207508b0f04a2c6181445c8eb3f1e117
  master date: 2017-08-15 15:07:25 +0200
  c362cde2c62b0164dba3f55815da875c0da918cc:gnttab: split maptrack lock to make it fulfill its purpose again

  The way the lock is currently being used in get_maptrack_handle(), it
  protects only the maptrack limit: The function acts on current's list
  only, so races on list accesses are impossible even without the lock.

  Otoh list access races are possible between __get_maptrack_handle() and
  put_maptrack_handle(), due to the invocation of the former for other
  than current from steal_maptrack_handle(). Introduce a per-vCPU lock
  for list accesses to become race free again. This lock will be
  uncontended except when it becomes necessary to take the steal path,
  i.e. in the common case there should be no meaningful performance
  impact.

  When in get_maptrack_handle adds a stolen entry to a fresh, empty,
  freelist, we think that there is probably no concurrency.  However,
  this is not a fast path and adding the locking there makes the code
  clearly correct.

  Also, while we are here: the stolen maptrack_entry's tail pointer was
  not properly set.  Set it.

  This is CVE-2017-12136 / XSA-228.

  Reported-by: Ian Jackson <ian.jackson@eu.citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Signed-off-by: Ian Jackson <Ian.Jackson@eu.citrix.com>
  master commit: 02cbeeb6207508b0f04a2c6181445c8eb3f1e117
  master date: 2017-08-15 15:07:25 +0200
  877591cc281c00661bf23917ff02c367229b5964:gnttab: split maptrack lock to make it fulfill its purpose again

  The way the lock is currently being used in get_maptrack_handle(), it
  protects only the maptrack limit: The function acts on current's list
  only, so races on list accesses are impossible even without the lock.

  Otoh list access races are possible between __get_maptrack_handle() and
  put_maptrack_handle(), due to the invocation of the former for other
  than current from steal_maptrack_handle(). Introduce a per-vCPU lock
  for list accesses to become race free again. This lock will be
  uncontended except when it becomes necessary to take the steal path,
  i.e. in the common case there should be no meaningful performance
  impact.

  When in get_maptrack_handle adds a stolen entry to a fresh, empty,
  freelist, we think that there is probably no concurrency.  However,
  this is not a fast path and adding the locking there makes the code
  clearly correct.

  Also, while we are here: the stolen maptrack_entry's tail pointer was
  not properly set.  Set it.

  This is CVE-2017-12136 / XSA-228.

  Reported-by: Ian Jackson <ian.jackson@eu.citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Signed-off-by: Ian Jackson <Ian.Jackson@eu.citrix.com>
  master commit: 02cbeeb6207508b0f04a2c6181445c8eb3f1e117
  master date: 2017-08-15 15:07:25 +0200
  266fc0ea45a5b56e2d507f84978ec86256280375:gnttab: split maptrack lock to make it fulfill its purpose again

  The way the lock is currently being used in get_maptrack_handle(), it
  protects only the maptrack limit: The function acts on current's list
  only, so races on list accesses are impossible even without the lock.

  Otoh list access races are possible between __get_maptrack_handle() and
  put_maptrack_handle(), due to the invocation of the former for other
  than current from steal_maptrack_handle(). Introduce a per-vCPU lock
  for list accesses to become race free again. This lock will be
  uncontended except when it becomes necessary to take the steal path,
  i.e. in the common case there should be no meaningful performance
  impact.

  When in get_maptrack_handle adds a stolen entry to a fresh, empty,
  freelist, we think that there is probably no concurrency.  However,
  this is not a fast path and adding the locking there makes the code
  clearly correct.

  Also, while we are here: the stolen maptrack_entry's tail pointer was
  not properly set.  Set it.

  This is CVE-2017-12136 / XSA-228.

  Reported-by: Ian Jackson <ian.jackson@eu.citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Signed-off-by: Ian Jackson <Ian.Jackson@eu.citrix.com>
  master commit: 02cbeeb6207508b0f04a2c6181445c8eb3f1e117
  master date: 2017-08-15 15:07:25 +0200
  02cbeeb6207508b0f04a2c6181445c8eb3f1e117:gnttab: split maptrack lock to make it fulfill its purpose again

  The way the lock is currently being used in get_maptrack_handle(), it
  protects only the maptrack limit: The function acts on current's list
  only, so races on list accesses are impossible even without the lock.

  Otoh list access races are possible between __get_maptrack_handle() and
  put_maptrack_handle(), due to the invocation of the former for other
  than current from steal_maptrack_handle(). Introduce a per-vCPU lock
  for list accesses to become race free again. This lock will be
  uncontended except when it becomes necessary to take the steal path,
  i.e. in the common case there should be no meaningful performance
  impact.

  When in get_maptrack_handle adds a stolen entry to a fresh, empty,
  freelist, we think that there is probably no concurrency.  However,
  this is not a fast path and adding the locking there makes the code
  clearly correct.

  Also, while we are here: the stolen maptrack_entry's tail pointer was
  not properly set.  Set it.

  This is CVE-2017-12136 / XSA-228.

  Reported-by: Ian Jackson <ian.jackson@eu.citrix.com>
  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Signed-off-by: Ian Jackson <Ian.Jackson@eu.citrix.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 266fc0ea45a5b56e2d507f84978ec86256280375
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 877591cc281c00661bf23917ff02c367229b5964
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: c362cde2c62b0164dba3f55815da875c0da918cc
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 02cbeeb6207508b0f04a2c6181445c8eb3f1e117
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: f974d3211ee7431ac45c401a88d6b436ce5c0c3c
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/02cbeeb6207508b0f04a2c6181445c8eb3f1e117
    reference_type: commit
    reference_id: 02cbeeb6207508b0f04a2c6181445c8eb3f1e117
  - url: https://github.com/xen-project/xen/tree/266fc0ea45a5b56e2d507f84978ec86256280375
    reference_type: commit
    reference_id: 266fc0ea45a5b56e2d507f84978ec86256280375
  - url: https://github.com/xen-project/xen/tree/877591cc281c00661bf23917ff02c367229b5964
    reference_type: commit
    reference_id: 877591cc281c00661bf23917ff02c367229b5964
  - url: https://github.com/xen-project/xen/tree/c362cde2c62b0164dba3f55815da875c0da918cc
    reference_type: commit
    reference_id: c362cde2c62b0164dba3f55815da875c0da918cc
  - url: https://github.com/xen-project/xen/tree/f974d3211ee7431ac45c401a88d6b436ce5c0c3c
    reference_type: commit
    reference_id: f974d3211ee7431ac45c401a88d6b436ce5c0c3c
