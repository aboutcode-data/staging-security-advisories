advisory_id: CVE-2022-26361
datasource_id: collect_xen_project_fix_commits/CVE-2022-26361
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  c633ec9451e76015c409bd5119ffcb0f2e61fe8b:IOMMU/x86: use per-device page tables for quarantining

  Devices with RMRRs / unity mapped regions, due to it being unspecified
  how/when these memory regions may be accessed, may not be left
  disconnected from the mappings of these regions (as long as it's not
  certain that the device has been fully quiesced). Hence even the page
  tables used when quarantining such devices need to have mappings of
  those regions. This implies installing page tables in the first place
  even when not in scratch-page quarantining mode.

  This is CVE-2022-26361 / part of XSA-400.

  While for the purpose here it would be sufficient to have devices with
  RMRRs / unity mapped regions use per-device page tables, extend this to
  all devices (in scratch-page quarantining mode). This allows the leaf
  pages to be mapped r/w, thus covering also memory writes (rather than
  just reads) issued by non-quiescent devices.

  Set up quarantine page tables as late as possible, yet early enough to
  not encounter failure during de-assign. This means setup generally
  happens in assign_device(), while (for now) the one in deassign_device()
  is there mainly to be on the safe side.

  In VT-d's DID allocation function don't require the IOMMU lock to be
  held anymore: All involved code paths hold pcidevs_lock, so this way we
  avoid the need to acquire the IOMMU lock around the new call to
  context_set_domain_id().

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  Reviewed-by: Kevin Tian <kevin.tian@intel.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  master commit: 14dd241aad8af447680ac73e8579990e2c09c1e7
  master date: 2022-04-05 14:24:18 +0200
  169a2834ef5d723091f187a5d6493ae77825757a:IOMMU/x86: use per-device page tables for quarantining

  Devices with RMRRs / unity mapped regions, due to it being unspecified
  how/when these memory regions may be accessed, may not be left
  disconnected from the mappings of these regions (as long as it's not
  certain that the device has been fully quiesced). Hence even the page
  tables used when quarantining such devices need to have mappings of
  those regions. This implies installing page tables in the first place
  even when not in scratch-page quarantining mode.

  This is CVE-2022-26361 / part of XSA-400.

  While for the purpose here it would be sufficient to have devices with
  RMRRs / unity mapped regions use per-device page tables, extend this to
  all devices (in scratch-page quarantining mode). This allows the leaf
  pages to be mapped r/w, thus covering also memory writes (rather than
  just reads) issued by non-quiescent devices.

  Set up quarantine page tables as late as possible, yet early enough to
  not encounter failure during de-assign. This means setup generally
  happens in assign_device(), while (for now) the one in deassign_device()
  is there mainly to be on the safe side.

  In VT-d's DID allocation function don't require the IOMMU lock to be
  held anymore: All involved code paths hold pcidevs_lock, so this way we
  avoid the need to acquire the IOMMU lock around the new call to
  context_set_domain_id().

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  Reviewed-by: Kevin Tian <kevin.tian@intel.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  master commit: 14dd241aad8af447680ac73e8579990e2c09c1e7
  master date: 2022-04-05 14:24:18 +0200
  faed81ff3940b377a981af37a89161bddcacdaf5:IOMMU/x86: use per-device page tables for quarantining

  Devices with RMRRs / unity mapped regions, due to it being unspecified
  how/when these memory regions may be accessed, may not be left
  disconnected from the mappings of these regions (as long as it's not
  certain that the device has been fully quiesced). Hence even the page
  tables used when quarantining such devices need to have mappings of
  those regions. This implies installing page tables in the first place
  even when not in scratch-page quarantining mode.

  This is CVE-2022-26361 / part of XSA-400.

  While for the purpose here it would be sufficient to have devices with
  RMRRs / unity mapped regions use per-device page tables, extend this to
  all devices (in scratch-page quarantining mode). This allows the leaf
  pages to be mapped r/w, thus covering also memory writes (rather than
  just reads) issued by non-quiescent devices.

  Set up quarantine page tables as late as possible, yet early enough to
  not encounter failure during de-assign. This means setup generally
  happens in assign_device(), while (for now) the one in deassign_device()
  is there mainly to be on the safe side.

  In VT-d's DID allocation function don't require the IOMMU lock to be
  held anymore: All involved code paths hold pcidevs_lock, so this way we
  avoid the need to acquire the IOMMU lock around the new call to
  context_set_domain_id().

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  Reviewed-by: Kevin Tian <kevin.tian@intel.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  master commit: 14dd241aad8af447680ac73e8579990e2c09c1e7
  master date: 2022-04-05 14:24:18 +0200
  aaa61028803a64e72f1026f9608dfa34d0c255ec:IOMMU/x86: use per-device page tables for quarantining

  Devices with RMRRs / unity mapped regions, due to it being unspecified
  how/when these memory regions may be accessed, may not be left
  disconnected from the mappings of these regions (as long as it's not
  certain that the device has been fully quiesced). Hence even the page
  tables used when quarantining such devices need to have mappings of
  those regions. This implies installing page tables in the first place
  even when not in scratch-page quarantining mode.

  This is CVE-2022-26361 / part of XSA-400.

  While for the purpose here it would be sufficient to have devices with
  RMRRs / unity mapped regions use per-device page tables, extend this to
  all devices (in scratch-page quarantining mode). This allows the leaf
  pages to be mapped r/w, thus covering also memory writes (rather than
  just reads) issued by non-quiescent devices.

  Set up quarantine page tables as late as possible, yet early enough to
  not encounter failure during de-assign. This means setup generally
  happens in assign_device(), while (for now) the one in deassign_device()
  is there mainly to be on the safe side.

  As to the removal of QUARANTINE_SKIP() from domain_context_unmap_one():
  I think this was never really needed there, as the function explicitly
  deals with finding a non-present context entry. Leaving it there would
  require propagating pgd_maddr into the function (like was done by "VT-d:
  prepare for per-device quarantine page tables" for
  domain_context_mapping_one()).

  In VT-d's DID allocation function don't require the IOMMU lock to be
  held anymore: All involved code paths hold pcidevs_lock, so this way we
  avoid the need to acquire the IOMMU lock around the new call to
  context_set_domain_id().

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  Reviewed-by: Kevin Tian <kevin.tian@intel.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  master commit: 14dd241aad8af447680ac73e8579990e2c09c1e7
  master date: 2022-04-05 14:24:18 +0200
  54e37f44a219a987189c566e15ccad7af0bcc4ed:IOMMU/x86: use per-device page tables for quarantining

  Devices with RMRRs / unity mapped regions, due to it being unspecified
  how/when these memory regions may be accessed, may not be left
  disconnected from the mappings of these regions (as long as it's not
  certain that the device has been fully quiesced). Hence even the page
  tables used when quarantining such devices need to have mappings of
  those regions. This implies installing page tables in the first place
  even when not in scratch-page quarantining mode.

  This is CVE-2022-26361 / part of XSA-400.

  While for the purpose here it would be sufficient to have devices with
  RMRRs / unity mapped regions use per-device page tables, extend this to
  all devices (in scratch-page quarantining mode). This allows the leaf
  pages to be mapped r/w, thus covering also memory writes (rather than
  just reads) issued by non-quiescent devices.

  Set up quarantine page tables as late as possible, yet early enough to
  not encounter failure during de-assign. This means setup generally
  happens in assign_device(), while (for now) the one in deassign_device()
  is there mainly to be on the safe side.

  As to the removal of QUARANTINE_SKIP() from domain_context_unmap_one():
  I think this was never really needed there, as the function explicitly
  deals with finding a non-present context entry. Leaving it there would
  require propagating pgd_maddr into the function (like was done by "VT-d:
  prepare for per-device quarantine page tables" for
  domain_context_mapping_one()).

  In VT-d's DID allocation function don't require the IOMMU lock to be
  held anymore: All involved code paths hold pcidevs_lock, so this way we
  avoid the need to acquire the IOMMU lock around the new call to
  context_set_domain_id().

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  Reviewed-by: Kevin Tian <kevin.tian@intel.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
  master commit: 14dd241aad8af447680ac73e8579990e2c09c1e7
  master date: 2022-04-05 14:24:18 +0200
  14dd241aad8af447680ac73e8579990e2c09c1e7:IOMMU/x86: use per-device page tables for quarantining

  Devices with RMRRs / unity mapped regions, due to it being unspecified
  how/when these memory regions may be accessed, may not be left
  disconnected from the mappings of these regions (as long as it's not
  certain that the device has been fully quiesced). Hence even the page
  tables used when quarantining such devices need to have mappings of
  those regions. This implies installing page tables in the first place
  even when not in scratch-page quarantining mode.

  This is CVE-2022-26361 / part of XSA-400.

  While for the purpose here it would be sufficient to have devices with
  RMRRs / unity mapped regions use per-device page tables, extend this to
  all devices (in scratch-page quarantining mode). This allows the leaf
  pages to be mapped r/w, thus covering also memory writes (rather than
  just reads) issued by non-quiescent devices.

  Set up quarantine page tables as late as possible, yet early enough to
  not encounter failure during de-assign. This means setup generally
  happens in assign_device(), while (for now) the one in deassign_device()
  is there mainly to be on the safe side.

  As to the removal of QUARANTINE_SKIP() from domain_context_unmap_one():
  I think this was never really needed there, as the function explicitly
  deals with finding a non-present context entry. Leaving it there would
  require propagating pgd_maddr into the function (like was done by "VT-d:
  prepare for per-device quarantine page tables" for
  domain_context_mapping_one()).

  In VT-d's DID allocation function don't require the IOMMU lock to be
  held anymore: All involved code paths hold pcidevs_lock, so this way we
  avoid the need to acquire the IOMMU lock around the new call to
  context_set_domain_id().

  Signed-off-by: Jan Beulich <jbeulich@suse.com>
  Reviewed-by: Paul Durrant <paul@xen.org>
  Reviewed-by: Kevin Tian <kevin.tian@intel.com>
  Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 169a2834ef5d723091f187a5d6493ae77825757a
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 54e37f44a219a987189c566e15ccad7af0bcc4ed
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: aaa61028803a64e72f1026f9608dfa34d0c255ec
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 14dd241aad8af447680ac73e8579990e2c09c1e7
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: faed81ff3940b377a981af37a89161bddcacdaf5
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: c633ec9451e76015c409bd5119ffcb0f2e61fe8b
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/14dd241aad8af447680ac73e8579990e2c09c1e7
    reference_type: commit
    reference_id: 14dd241aad8af447680ac73e8579990e2c09c1e7
  - url: https://github.com/xen-project/xen/tree/169a2834ef5d723091f187a5d6493ae77825757a
    reference_type: commit
    reference_id: 169a2834ef5d723091f187a5d6493ae77825757a
  - url: https://github.com/xen-project/xen/tree/54e37f44a219a987189c566e15ccad7af0bcc4ed
    reference_type: commit
    reference_id: 54e37f44a219a987189c566e15ccad7af0bcc4ed
  - url: https://github.com/xen-project/xen/tree/aaa61028803a64e72f1026f9608dfa34d0c255ec
    reference_type: commit
    reference_id: aaa61028803a64e72f1026f9608dfa34d0c255ec
  - url: https://github.com/xen-project/xen/tree/c633ec9451e76015c409bd5119ffcb0f2e61fe8b
    reference_type: commit
    reference_id: c633ec9451e76015c409bd5119ffcb0f2e61fe8b
  - url: https://github.com/xen-project/xen/tree/faed81ff3940b377a981af37a89161bddcacdaf5
    reference_type: commit
    reference_id: faed81ff3940b377a981af37a89161bddcacdaf5
