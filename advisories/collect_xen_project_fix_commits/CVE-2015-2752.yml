advisory_id: CVE-2015-2752
datasource_id: collect_xen_project_fix_commits/CVE-2015-2752
datasource_url: https://github.com/xen-project/xen
aliases: []
summary: |
  b10bca0483a1fa74de99807b89b13b27064794e1:Limit XEN_DOMCTL_memory_mapping hypercall to only process up to 64 GFNs (or less)

  Said hypercall for large BARs can take quite a while. As such
  we can require that the hypercall MUST break up the request
  in smaller values.

  Another approach is to add preemption to it - whether we do the
  preemption using hypercall_create_continuation or returning
  EAGAIN to userspace (and have it re-invocate the call) - either
  way the issue we cannot easily solve is that in 'map_mmio_regions'
  if we encounter an error we MUST call 'unmap_mmio_regions' for the
  whole BAR region.

  Since the preemption would re-use input fields such as nr_mfns,
  first_gfn, first_mfn - we would lose the original values -
  and only undo what was done in the current round (i.e. ignoring
  anything that was done prior to earlier preemptions).

  Unless we re-used the return value as 'EAGAIN|nr_mfns_done<<10' but
  that puts a limit (since the return value is a long) on the amount
  of nr_mfns that can provided.

  This patch sidesteps this problem by:
   - Setting an hard limit of nr_mfns having to be 64 or less.
   - Toolstack adjusts correspondingly to the nr_mfn limit.
   - If the there is an error when adding the toolstack will call the
     remove operation to remove the whole region.

  The need to break this hypercall down is for large BARs can take
  more than the guest (initial domain usually) time-slice. This has
  the negative result in that the guest is locked out for a long
  duration and is unable to act on any pending events.

  We also augment the code to return zero if nr_mfns instead
  of trying to the hypercall.

  This is XSA-125 / CVE-2015-2752.

  Suggested-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Jan Beulich <jbeulich@suse.com>
  Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
  Acked-by: Ian Campbell <ian.campbell@citrix.com>
  f5bca8110b16a5467a07d17b7596fc9bc5c03905:Limit XEN_DOMCTL_memory_mapping hypercall to only process up to 64 GFNs (or less)

  Said hypercall for large BARs can take quite a while. As such
  we can require that the hypercall MUST break up the request
  in smaller values.

  Another approach is to add preemption to it - whether we do the
  preemption using hypercall_create_continuation or returning
  EAGAIN to userspace (and have it re-invocate the call) - either
  way the issue we cannot easily solve is that in 'map_mmio_regions'
  if we encounter an error we MUST call 'unmap_mmio_regions' for the
  whole BAR region.

  Since the preemption would re-use input fields such as nr_mfns,
  first_gfn, first_mfn - we would lose the original values -
  and only undo what was done in the current round (i.e. ignoring
  anything that was done prior to earlier preemptions).

  Unless we re-used the return value as 'EAGAIN|nr_mfns_done<<10' but
  that puts a limit (since the return value is a long) on the amount
  of nr_mfns that can provided.

  This patch sidesteps this problem by:
   - Setting an hard limit of nr_mfns having to be 64 or less.
   - Toolstack adjusts correspondingly to the nr_mfn limit.
   - If the there is an error when adding the toolstack will call the
     remove operation to remove the whole region.

  The need to break this hypercall down is for large BARs can take
  more than the guest (initial domain usually) time-slice. This has
  the negative result in that the guest is locked out for a long
  duration and is unable to act on any pending events.

  We also augment the code to return zero if nr_mfns instead
  of trying to the hypercall.

  This is XSA-125 / CVE-2015-2752.

  Suggested-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Jan Beulich <jbeulich@suse.com>
  Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
  Acked-by: Ian Campbell <ian.campbell@citrix.com>
  18856366dceb254f16577113e11e4bb94cdc59d9:Limit XEN_DOMCTL_memory_mapping hypercall to only process up to 64 GFNs (or less)

  Said hypercall for large BARs can take quite a while. As such
  we can require that the hypercall MUST break up the request
  in smaller values.

  Another approach is to add preemption to it - whether we do the
  preemption using hypercall_create_continuation or returning
  EAGAIN to userspace (and have it re-invocate the call) - either
  way the issue we cannot easily solve is that in 'map_mmio_regions'
  if we encounter an error we MUST call 'unmap_mmio_regions' for the
  whole BAR region.

  Since the preemption would re-use input fields such as nr_mfns,
  first_gfn, first_mfn - we would lose the original values -
  and only undo what was done in the current round (i.e. ignoring
  anything that was done prior to earlier preemptions).

  Unless we re-used the return value as 'EAGAIN|nr_mfns_done<<10' but
  that puts a limit (since the return value is a long) on the amount
  of nr_mfns that can provided.

  This patch sidesteps this problem by:
   - Setting an hard limit of nr_mfns having to be 64 or less.
   - Toolstack adjusts correspondingly to the nr_mfn limit.
   - If the there is an error when adding the toolstack will call the
     remove operation to remove the whole region.

  The need to break this hypercall down is for large BARs can take
  more than the guest (initial domain usually) time-slice. This has
  the negative result in that the guest is locked out for a long
  duration and is unable to act on any pending events.

  We also augment the code to return zero if nr_mfns instead
  of trying to the hypercall.

  This is XSA-125 / CVE-2015-2752.

  Suggested-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Jan Beulich <jbeulich@suse.com>
  Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
  Acked-by: Ian Campbell <ian.campbell@citrix.com>
  e3bfa4003ceaa2746cdd77655953ab2601acaf9c:Limit XEN_DOMCTL_memory_mapping hypercall to only process up to 64 GFNs (or less)

  Said hypercall for large BARs can take quite a while. As such
  we can require that the hypercall MUST break up the request
  in smaller values.

  Another approach is to add preemption to it - whether we do the
  preemption using hypercall_create_continuation or returning
  EAGAIN to userspace (and have it re-invocate the call) - either
  way the issue we cannot easily solve is that in 'map_mmio_regions'
  if we encounter an error we MUST call 'unmap_mmio_regions' for the
  whole BAR region.

  Since the preemption would re-use input fields such as nr_mfns,
  first_gfn, first_mfn - we would lose the original values -
  and only undo what was done in the current round (i.e. ignoring
  anything that was done prior to earlier preemptions).

  Unless we re-used the return value as 'EAGAIN|nr_mfns_done<<10' but
  that puts a limit (since the return value is a long) on the amount
  of nr_mfns that can provided.

  This patch sidesteps this problem by:
   - Setting an hard limit of nr_mfns having to be 64 or less.
   - Toolstack adjusts correspondingly to the nr_mfn limit.
   - If the there is an error when adding the toolstack will call the
     remove operation to remove the whole region.

  The need to break this hypercall down is for large BARs can take
  more than the guest (initial domain usually) time-slice. This has
  the negative result in that the guest is locked out for a long
  duration and is unable to act on any pending events.

  We also augment the code to return zero if nr_mfns instead
  of trying to the hypercall.

  This is XSA-125 / CVE-2015-2752.

  Suggested-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Jan Beulich <jbeulich@suse.com>
  Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
  Acked-by: Ian Campbell <ian.campbell@citrix.com>
  518ae14973a44228fd7158c3d70270df6ed90033:Limit XEN_DOMCTL_memory_mapping hypercall to only process up to 64 GFNs (or less)

  Said hypercall for large BARs can take quite a while. As such
  we can require that the hypercall MUST break up the request
  in smaller values.

  Another approach is to add preemption to it - whether we do the
  preemption using hypercall_create_continuation or returning
  EAGAIN to userspace (and have it re-invocate the call) - either
  way the issue we cannot easily solve is that in 'map_mmio_regions'
  if we encounter an error we MUST call 'unmap_mmio_regions' for the
  whole BAR region.

  Since the preemption would re-use input fields such as nr_mfns,
  first_gfn, first_mfn - we would lose the original values -
  and only undo what was done in the current round (i.e. ignoring
  anything that was done prior to earlier preemptions).

  Unless we re-used the return value as 'EAGAIN|nr_mfns_done<<10' but
  that puts a limit (since the return value is a long) on the amount
  of nr_mfns that can provided.

  This patch sidesteps this problem by:
   - Setting an hard limit of nr_mfns having to be 64 or less.
   - Toolstack adjusts correspondingly to the nr_mfn limit.
   - If the there is an error when adding the toolstack will call the
     remove operation to remove the whole region.

  The need to break this hypercall down is for large BARs can take
  more than the guest (initial domain usually) time-slice. This has
  the negative result in that the guest is locked out for a long
  duration and is unable to act on any pending events.

  We also augment the code to return zero if nr_mfns instead
  of trying to the hypercall.

  This is XSA-125 / CVE-2015-2752.

  Suggested-by: Jan Beulich <jbeulich@suse.com>
  Acked-by: Jan Beulich <jbeulich@suse.com>
  Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
  Acked-by: Ian Campbell <ian.campbell@citrix.com>
impacted_packages:
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: e3bfa4003ceaa2746cdd77655953ab2601acaf9c
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: b10bca0483a1fa74de99807b89b13b27064794e1
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 518ae14973a44228fd7158c3d70270df6ed90033
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: 18856366dceb254f16577113e11e4bb94cdc59d9
    introduced_in_commits: []
  - purl: pkg:github/xen-project/xen
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/xen-project/xen
        commit: f5bca8110b16a5467a07d17b7596fc9bc5c03905
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/xen-project/xen/tree/18856366dceb254f16577113e11e4bb94cdc59d9
    reference_type: commit
    reference_id: 18856366dceb254f16577113e11e4bb94cdc59d9
  - url: https://github.com/xen-project/xen/tree/518ae14973a44228fd7158c3d70270df6ed90033
    reference_type: commit
    reference_id: 518ae14973a44228fd7158c3d70270df6ed90033
  - url: https://github.com/xen-project/xen/tree/b10bca0483a1fa74de99807b89b13b27064794e1
    reference_type: commit
    reference_id: b10bca0483a1fa74de99807b89b13b27064794e1
  - url: https://github.com/xen-project/xen/tree/e3bfa4003ceaa2746cdd77655953ab2601acaf9c
    reference_type: commit
    reference_id: e3bfa4003ceaa2746cdd77655953ab2601acaf9c
  - url: https://github.com/xen-project/xen/tree/f5bca8110b16a5467a07d17b7596fc9bc5c03905
    reference_type: commit
    reference_id: f5bca8110b16a5467a07d17b7596fc9bc5c03905
