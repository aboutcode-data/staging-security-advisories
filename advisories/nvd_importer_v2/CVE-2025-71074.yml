advisory_id: CVE-2025-71074
datasource_id: nvd_importer_v2/CVE-2025-71074
datasource_url: https://nvd.nist.gov/vuln/detail/CVE-2025-71074
aliases: []
summary: "In the Linux kernel, the following vulnerability has been resolved:\n\nfunctionfs:\
  \ fix the open/removal races\n\nffs_epfile_open() can race with removal, ending up with file->private_data\n\
  pointing to freed object.\n\nThere is a total count of opened files on functionfs (both ep0\
  \ and\ndynamic ones) and when it hits zero, dynamic files get removed.\nUnfortunately, that\
  \ removal can happen while another thread is\nin ffs_epfile_open(), but has not incremented\
  \ the count yet.\nIn that case open will succeed, leaving us with UAF on any subsequent\n\
  read() or write().\n\nThe root cause is that ffs->opened is misused; atomic_dec_and_test()\
  \ vs.\natomic_add_return() is not a good idea, when object remains visible all\nalong.\n\n\
  To untangle that\n\t* serialize openers on ffs->mutex (both for ep0 and for dynamic files)\n\
  \t* have dynamic ones use atomic_inc_not_zero() and fail if we had\nzero ->opened; in that\
  \ case the file we are opening is doomed.\n\t* have the inodes of dynamic files marked on\
  \ removal (from the\ncallback of simple_recursive_removal()) - clear ->i_private there.\n\t\
  * have open of dynamic ones verify they hadn't been already removed,\nalong with checking\
  \ that state is FFS_ACTIVE."
impacted_packages: []
severities: []
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/e5bf5ee266633cb18fff6f98f0b7d59a62819eee
    reference_type:
    reference_id:
  - url: https://nvd.nist.gov/vuln/detail/CVE-2025-71074
    reference_type:
    reference_id: CVE-2025-71074
