advisory_id: CVE-2026-23177
datasource_id: nvd_importer_v2/CVE-2026-23177
datasource_url: https://nvd.nist.gov/vuln/detail/CVE-2026-23177
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  mm, shmem: prevent infinite loop on truncate race

  When truncating a large swap entry, shmem_free_swap() returns 0 when the
  entry's index doesn't match the given index due to lookup alignment.  The
  failure fallback path checks if the entry crosses the end border and
  aborts when it happens, so truncate won't erase an unexpected entry or
  range.  But one scenario was ignored.

  When `index` points to the middle of a large swap entry, and the large
  swap entry doesn't go across the end border, find_get_entries() will
  return that large swap entry as the first item in the batch with
  `indices[0]` equal to `index`.  The entry's base index will be smaller
  than `indices[0]`, so shmem_free_swap() will fail and return 0 due to the
  "base < index" check.  The code will then call shmem_confirm_swap(), get
  the order, check if it crosses the END boundary (which it doesn't), and
  retry with the same index.

  The next iteration will find the same entry again at the same index with
  same indices, leading to an infinite loop.

  Fix this by retrying with a round-down index, and abort if the index is
  smaller than the truncate range.
impacted_packages: []
severities: []
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/2030dddf95451b4e7a389f052091e7c4b7b274c6
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/7b6a0f121d50234aab3e7ab9a62ebe826d40a32a
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/dfc3ab6bd64860f8022d69903be299d09be86e11
    reference_type:
    reference_id:
  - url: https://nvd.nist.gov/vuln/detail/CVE-2026-23177
    reference_type:
    reference_id: CVE-2026-23177
