advisory_id: CVE-2023-53523
datasource_id: nvd_importer_v2/CVE-2023-53523
datasource_url: https://nvd.nist.gov/vuln/detail/CVE-2023-53523
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  can: gs_usb: fix time stamp counter initialization

  If the gs_usb device driver is unloaded (or unbound) before the
  interface is shut down, the USB stack first calls the struct
  usb_driver::disconnect and then the struct net_device_ops::ndo_stop
  callback.

  In gs_usb_disconnect() all pending bulk URBs are killed, i.e. no more
  RX'ed CAN frames are send from the USB device to the host. Later in
  gs_can_close() a reset control message is send to each CAN channel to
  remove the controller from the CAN bus. In this race window the USB
  device can still receive CAN frames from the bus and internally queue
  them to be send to the host.

  At least in the current version of the candlelight firmware, the queue
  of received CAN frames is not emptied during the reset command. After
  loading (or binding) the gs_usb driver, new URBs are submitted during
  the struct net_device_ops::ndo_open callback and the candlelight
  firmware starts sending its already queued CAN frames to the host.

  However, this scenario was not considered when implementing the
  hardware timestamp function. The cycle counter/time counter
  infrastructure is set up (gs_usb_timestamp_init()) after the USBs are
  submitted, resulting in a NULL pointer dereference if
  timecounter_cyc2time() (via the call chain:
  gs_usb_receive_bulk_callback() -> gs_usb_set_timestamp() ->
  gs_usb_skb_set_timestamp()) is called too early.

  Move the gs_usb_timestamp_init() function before the URBs are
  submitted to fix this problem.

  For a comprehensive solution, we need to consider gs_usb devices with
  more than 1 channel. The cycle counter/time counter infrastructure is
  setup per channel, but the RX URBs are per device. Once gs_can_open()
  of _a_ channel has been called, and URBs have been submitted, the
  gs_usb_receive_bulk_callback() can be called for _all_ available
  channels, even for channels that are not running, yet. As cycle
  counter/time counter has not set up, this will again lead to a NULL
  pointer dereference.

  Convert the cycle counter/time counter from a "per channel" to a "per
  device" functionality. Also set it up, before submitting any URBs to
  the device.

  Further in gs_usb_receive_bulk_callback(), don't process any URBs for
  not started CAN channels, only resubmit the URB.
impacted_packages: []
severities:
  - score: '5.5'
    scoring_system: cvssv3.1
    scoring_elements: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
    published_at: None
    url: https://nvd.nist.gov/vuln/detail/CVE-2023-53523
weaknesses:
  - CWE-476
references:
  - url: https://git.kernel.org/stable/c/210a8cffc9c1b044281c0a868485c870c9c11374
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/5886e4d5ecec3e22844efed90b2dd383ef804b3a
    reference_type:
    reference_id:
  - url: https://nvd.nist.gov/vuln/search/results?adv_search=true&isCpeNameSearch=true&query=cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
    reference_type:
    reference_id: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
  - url: https://nvd.nist.gov/vuln/search/results?adv_search=true&isCpeNameSearch=true&query=cpe:2.3:o:linux:linux_kernel:6.5:rc1:*:*:*:*:*:*
    reference_type:
    reference_id: cpe:2.3:o:linux:linux_kernel:6.5:rc1:*:*:*:*:*:*
  - url: https://nvd.nist.gov/vuln/search/results?adv_search=true&isCpeNameSearch=true&query=cpe:2.3:o:linux:linux_kernel:6.5:rc2:*:*:*:*:*:*
    reference_type:
    reference_id: cpe:2.3:o:linux:linux_kernel:6.5:rc2:*:*:*:*:*:*
  - url: https://nvd.nist.gov/vuln/detail/CVE-2023-53523
    reference_type:
    reference_id: CVE-2023-53523
