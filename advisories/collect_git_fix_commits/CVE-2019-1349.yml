advisory_id: CVE-2019-1349
datasource_id: collect_git_fix_commits/CVE-2019-1349
datasource_url: https://github.com/git/git
aliases: []
summary: |
  873a466ea3f233d4fb11f894a311de06939a2a3e:clone: drop the protections where hooks aren't run

  As part of the security bug-fix releases v2.39.4, ..., v2.45.1, I
  introduced logic to safeguard `git clone` from running hooks that were
  installed _during_ the clone operation.

  The rationale was that Git's CVE-2024-32002, CVE-2021-21300,
  CVE-2019-1354, CVE-2019-1353, CVE-2019-1352, and CVE-2019-1349 should
  have been low-severity vulnerabilities but were elevated to
  critical/high severity by the attack vector that allows a weakness where
  files inside `.git/` can be inadvertently written during a `git clone`
  to escalate to a Remote Code Execution attack by virtue of installing a
  malicious `post-checkout` hook that Git will then run at the end of the
  operation without giving the user a chance to see what code is executed.

  Unfortunately, Git LFS uses a similar strategy to install its own
  `post-checkout` hook during a `git clone`; In fact, Git LFS is
  installing four separate hooks while running the `smudge` filter.

  While this pattern is probably in want of being improved by introducing
  better support in Git for Git LFS and other tools wishing to register
  hooks to be run at various stages of Git's commands, let's undo the
  clone protections to unbreak Git LFS-enabled clones.

  This reverts commit 8db1e8743c0 (clone: prevent hooks from running
  during a clone, 2024-03-28).

  Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
  Signed-off-by: Junio C Hamano <gitster@pobox.com>
  0060fd1511b94c918928fa3708f69a3f33895a4a:clone --recurse-submodules: prevent name squatting on Windows

  In addition to preventing `.git` from being tracked by Git, on Windows
  we also have to prevent `git~1` from being tracked, as the default NTFS
  short name (also known as the "8.3 filename") for the file name `.git`
  is `git~1`, otherwise it would be possible for malicious repositories to
  write directly into the `.git/` directory, e.g. a `post-checkout` hook
  that would then be executed _during_ a recursive clone.

  When we implemented appropriate protections in 2b4c6efc821 (read-cache:
  optionally disallow NTFS .git variants, 2014-12-16), we had analyzed
  carefully that the `.git` directory or file would be guaranteed to be
  the first directory entry to be written. Otherwise it would be possible
  e.g. for a file named `..git` to be assigned the short name `git~1` and
  subsequently, the short name generated for `.git` would be `git~2`. Or
  `git~3`. Or even `~9999999` (for a detailed explanation of the lengths
  we have to go to protect `.gitmodules`, see the commit message of
  e7cb0b4455c (is_ntfs_dotgit: match other .git files, 2018-05-11)).

  However, by exploiting two issues (that will be addressed in a related
  patch series close by), it is currently possible to clone a submodule
  into a non-empty directory:

  - On Windows, file names cannot end in a space or a period (for
    historical reasons: the period separating the base name from the file
    extension was not actually written to disk, and the base name/file
    extension was space-padded to the full 8/3 characters, respectively).
    Helpfully, when creating a directory under the name, say, `sub.`, that
    trailing period is trimmed automatically and the actual name on disk
    is `sub`.

    This means that while Git thinks that the submodule names `sub` and
    `sub.` are different, they both access `.git/modules/sub/`.

  - While the backslash character is a valid file name character on Linux,
    it is not so on Windows. As Git tries to be cross-platform, it
    therefore allows backslash characters in the file names stored in tree
    objects.

    Which means that it is totally possible that a submodule `c` sits next
    to a file `c\..git`, and on Windows, during recursive clone a file
    called `..git` will be written into `c/`, of course _before_ the
    submodule is cloned.

  Note that the actual exploit is not quite as simple as having a
  submodule `c` next to a file `c\..git`, as we have to make sure that the
  directory `.git/modules/b` already exists when the submodule is checked
  out, otherwise a different code path is taken in `module_clone()` that
  does _not_ allow a non-empty submodule directory to exist already.

  Even if we will address both issues nearby (the next commit will
  disallow backslash characters in tree entries' file names on Windows,
  and another patch will disallow creating directories/files with trailing
  spaces or periods), it is a wise idea to defend in depth against this
  sort of attack vector: when submodules are cloned recursively, we now
  _require_ the directory to be empty, addressing CVE-2019-1349.

  Note: the code path we patch is shared with the code path of `git
  submodule update --init`, which must not expect, in general, that the
  directory is empty. Hence we have to introduce the new option
  `--force-init` and hand it all the way down from `git submodule` to the
  actual `git submodule--helper` process that performs the initial clone.

  Reported-by: Nicolas Joly <Nicolas.Joly@microsoft.com>
  Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
impacted_packages:
  - purl: pkg:github/git/git
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/git/git
        commit: 873a466ea3f233d4fb11f894a311de06939a2a3e
    introduced_in_commits: []
  - purl: pkg:github/git/git
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/git/git
        commit: 0060fd1511b94c918928fa3708f69a3f33895a4a
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/git/git/tree/0060fd1511b94c918928fa3708f69a3f33895a4a
    reference_type: commit
    reference_id: 0060fd1511b94c918928fa3708f69a3f33895a4a
  - url: https://github.com/git/git/tree/873a466ea3f233d4fb11f894a311de06939a2a3e
    reference_type: commit
    reference_id: 873a466ea3f233d4fb11f894a311de06939a2a3e
