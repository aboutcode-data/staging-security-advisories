advisory_id: CVE-2021-21300
datasource_id: collect_git_fix_commits/CVE-2021-21300
datasource_url: https://github.com/git/git
aliases: []
summary: |
  873a466ea3f233d4fb11f894a311de06939a2a3e:clone: drop the protections where hooks aren't run

  As part of the security bug-fix releases v2.39.4, ..., v2.45.1, I
  introduced logic to safeguard `git clone` from running hooks that were
  installed _during_ the clone operation.

  The rationale was that Git's CVE-2024-32002, CVE-2021-21300,
  CVE-2019-1354, CVE-2019-1353, CVE-2019-1352, and CVE-2019-1349 should
  have been low-severity vulnerabilities but were elevated to
  critical/high severity by the attack vector that allows a weakness where
  files inside `.git/` can be inadvertently written during a `git clone`
  to escalate to a Remote Code Execution attack by virtue of installing a
  malicious `post-checkout` hook that Git will then run at the end of the
  operation without giving the user a chance to see what code is executed.

  Unfortunately, Git LFS uses a similar strategy to install its own
  `post-checkout` hook during a `git clone`; In fact, Git LFS is
  installing four separate hooks while running the `smudge` filter.

  While this pattern is probably in want of being improved by introducing
  better support in Git for Git LFS and other tools wishing to register
  hooks to be run at various stages of Git's commands, let's undo the
  clone protections to unbreak Git LFS-enabled clones.

  This reverts commit 8db1e8743c0 (clone: prevent hooks from running
  during a clone, 2024-03-28).

  Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
  Signed-off-by: Junio C Hamano <gitster@pobox.com>
  56a57652ef8e4ca2f108a8719b8caeed5e153c95:Sync with Git 2.30.2 for CVE-2021-21300

  Signed-off-by: Junio C Hamano <gitster@pobox.com>
  684dd4c2b414bcf648505e74498a608f28de4592:checkout: fix bug that makes checkout follow symlinks in leading path

  Before checking out a file, we have to confirm that all of its leading
  components are real existing directories. And to reduce the number of
  lstat() calls in this process, we cache the last leading path known to
  contain only directories. However, when a path collision occurs (e.g.
  when checking out case-sensitive files in case-insensitive file
  systems), a cached path might have its file type changed on disk,
  leaving the cache on an invalid state. Normally, this doesn't bring
  any bad consequences as we usually check out files in index order, and
  therefore, by the time the cached path becomes outdated, we no longer
  need it anyway (because all files in that directory would have already
  been written).

  But, there are some users of the checkout machinery that do not always
  follow the index order. In particular: checkout-index writes the paths
  in the same order that they appear on the CLI (or stdin); and the
  delayed checkout feature -- used when a long-running filter process
  replies with "status=delayed" -- postpones the checkout of some entries,
  thus modifying the checkout order.

  When we have to check out an out-of-order entry and the lstat() cache is
  invalid (due to a previous path collision), checkout_entry() may end up
  using the invalid data and thrusting that the leading components are
  real directories when, in reality, they are not. In the best case
  scenario, where the directory was replaced by a regular file, the user
  will get an error: "fatal: unable to create file 'foo/bar': Not a
  directory". But if the directory was replaced by a symlink, checkout
  could actually end up following the symlink and writing the file at a
  wrong place, even outside the repository. Since delayed checkout is
  affected by this bug, it could be used by an attacker to write
  arbitrary files during the clone of a maliciously crafted repository.

  Some candidate solutions considered were to disable the lstat() cache
  during unordered checkouts or sort the entries before passing them to
  the checkout machinery. But both ideas include some performance penalty
  and they don't future-proof the code against new unordered use cases.

  Instead, we now manually reset the lstat cache whenever we successfully
  remove a directory. Note: We are not even checking whether the directory
  was the same as the lstat cache points to because we might face a
  scenario where the paths refer to the same location but differ due to
  case folding, precomposed UTF-8 issues, or the presence of `..`
  components in the path. Two regression tests, with case-collisions and
  utf8-collisions, are also added for both checkout-index and delayed
  checkout.

  Note: to make the previously mentioned clone attack unfeasible, it would
  be sufficient to reset the lstat cache only after the remove_subtree()
  call inside checkout_entry(). This is the place where we would remove a
  directory whose path collides with the path of another entry that we are
  currently trying to check out (possibly a symlink). However, in the
  interest of a thorough fix that does not leave Git open to
  similar-but-not-identical attack vectors, we decided to intercept
  all `rmdir()` calls in one fell swoop.

  This addresses CVE-2021-21300.

  Co-authored-by: Johannes Schindelin <johannes.schindelin@gmx.de>
  Signed-off-by: Matheus Tavares <matheus.bernardino@usp.br>
impacted_packages:
  - purl: pkg:github/git/git
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/git/git
        commit: 56a57652ef8e4ca2f108a8719b8caeed5e153c95
    introduced_in_commits: []
  - purl: pkg:github/git/git
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/git/git
        commit: 873a466ea3f233d4fb11f894a311de06939a2a3e
    introduced_in_commits: []
  - purl: pkg:github/git/git
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/git/git
        commit: 684dd4c2b414bcf648505e74498a608f28de4592
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/git/git/tree/56a57652ef8e4ca2f108a8719b8caeed5e153c95
    reference_type: commit
    reference_id: 56a57652ef8e4ca2f108a8719b8caeed5e153c95
  - url: https://github.com/git/git/tree/684dd4c2b414bcf648505e74498a608f28de4592
    reference_type: commit
    reference_id: 684dd4c2b414bcf648505e74498a608f28de4592
  - url: https://github.com/git/git/tree/873a466ea3f233d4fb11f894a311de06939a2a3e
    reference_type: commit
    reference_id: 873a466ea3f233d4fb11f894a311de06939a2a3e
