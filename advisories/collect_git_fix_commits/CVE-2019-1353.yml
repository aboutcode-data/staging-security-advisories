advisory_id: CVE-2019-1353
datasource_id: collect_git_fix_commits/CVE-2019-1353
datasource_url: https://github.com/git/git
aliases: []
summary: |
  873a466ea3f233d4fb11f894a311de06939a2a3e:clone: drop the protections where hooks aren't run

  As part of the security bug-fix releases v2.39.4, ..., v2.45.1, I
  introduced logic to safeguard `git clone` from running hooks that were
  installed _during_ the clone operation.

  The rationale was that Git's CVE-2024-32002, CVE-2021-21300,
  CVE-2019-1354, CVE-2019-1353, CVE-2019-1352, and CVE-2019-1349 should
  have been low-severity vulnerabilities but were elevated to
  critical/high severity by the attack vector that allows a weakness where
  files inside `.git/` can be inadvertently written during a `git clone`
  to escalate to a Remote Code Execution attack by virtue of installing a
  malicious `post-checkout` hook that Git will then run at the end of the
  operation without giving the user a chance to see what code is executed.

  Unfortunately, Git LFS uses a similar strategy to install its own
  `post-checkout` hook during a `git clone`; In fact, Git LFS is
  installing four separate hooks while running the `smudge` filter.

  While this pattern is probably in want of being improved by introducing
  better support in Git for Git LFS and other tools wishing to register
  hooks to be run at various stages of Git's commands, let's undo the
  clone protections to unbreak Git LFS-enabled clones.

  This reverts commit 8db1e8743c0 (clone: prevent hooks from running
  during a clone, 2024-03-28).

  Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
  Signed-off-by: Junio C Hamano <gitster@pobox.com>
  dd53ea7220606f9ed36db5a0ef910143fdac2903:Merge branch 'turn-on-protectntfs-by-default'

  This patch series makes it safe to use Git on Windows drives, even if
  running on a mounted network share or within the Windows Subsystem for
  Linux (WSL).

  This topic branch addresses CVE-2019-1353.

  Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
  9102f958ee5254b10c0be72672aa3305bf4f4704:protect_ntfs: turn on NTFS protection by default

  Back in the DOS days, in the FAT file system, file names always
  consisted of a base name of length 8 plus a file extension of length 3.
  Shorter file names were simply padded with spaces to the full 8.3
  format.

  Later, the FAT file system was taught to support _also_ longer names,
  with an 8.3 "short name" as primary file name. While at it, the same
  facility allowed formerly illegal file names, such as `.git` (empty base
  names were not allowed), which would have the "short name" `git~1`
  associated with it.

  For backwards-compatibility, NTFS supports alternative 8.3 short
  filenames, too, even if starting with Windows Vista, they are only
  generated on the system drive by default.

  We addressed the problem that the `.git/` directory can _also_ be
  accessed via `git~1/` (when short names are enabled) in 2b4c6efc821
  (read-cache: optionally disallow NTFS .git variants, 2014-12-16), i.e.
  since Git v1.9.5, by introducing the config setting `core.protectNTFS`
  and enabling it by default on Windows.

  In the meantime, Windows 10 introduced the "Windows Subsystem for Linux"
  (short: WSL), i.e. a way to run Linux applications/distributions in a
  thinly-isolated subsystem on Windows (giving rise to many a "2016 is the
  Year of Linux on the Desktop" jokes). WSL is getting increasingly
  popular, also due to the painless way Linux application can operate
  directly ("natively") on files on Windows' file system: the Windows
  drives are mounted automatically (e.g. `C:` as `/mnt/c/`).

  Taken together, this means that we now have to enable the safe-guards of
  Git v1.9.5 also in WSL: it is possible to access a `.git` directory
  inside `/mnt/c/` via the 8.3 name `git~1` (unless short name generation
  was disabled manually). Since regular Linux distributions run in WSL,
  this means we have to enable `core.protectNTFS` at least on Linux, too.

  To enable Services for Macintosh in Windows NT to store so-called
  resource forks, NTFS introduced "Alternate Data Streams". Essentially,
  these constitute additional metadata that are connected to (and copied
  with) their associated files, and they are accessed via pseudo file
  names of the form `filename:<stream-name>:<stream-type>`.

  In a recent patch, we extended `core.protectNTFS` to also protect
  against accesses via NTFS Alternate Data Streams, e.g. to prevent
  contents of the `.git/` directory to be "tracked" via yet another
  alternative file name.

  While it is not possible (at least by default) to access files via NTFS
  Alternate Data Streams from within WSL, the defaults on macOS when
  mounting network shares via SMB _do_ allow accessing files and
  directories in that way. Therefore, we need to enable `core.protectNTFS`
  on macOS by default, too, and really, on any Operating System that can
  mount network shares via SMB/CIFS.

  A couple of approaches were considered for fixing this:

  1. We could perform a dynamic NTFS check similar to the `core.symlinks`
     check in `init`/`clone`: instead of trying to create a symbolic link
     in the `.git/` directory, we could create a test file and try to
     access `.git/config` via 8.3 name and/or Alternate Data Stream.

  2. We could simply "flip the switch" on `core.protectNTFS`, to make it
     "on by default".

  The obvious downside of 1. is that it won't protect worktrees that were
  clone with a vulnerable Git version already. We considered patching code
  paths that check out files to check whether we're running on an NTFS
  system dynamically and persist the result in the repository-local config
  setting `core.protectNTFS`, but in the end decided that this solution
  would be too fragile, and too involved.

  The obvious downside of 2. is that everybody will have to "suffer" the
  performance penalty incurred from calling `is_ntfs_dotgit()` on every
  path, even in setups where.

  After the recent work to accelerate `is_ntfs_dotgit()` in most cases,
  it looks as if the time spent on validating ten million random
  file names increases only negligibly (less than 20ms, well within the
  standard deviation of ~50ms). Therefore the benefits outweigh the cost.

  Another downside of this is that paths that might have been acceptable
  previously now will be forbidden. Realistically, though, this is an
  improvement because public Git hosters already would reject any `git
  push` that contains such file names.

  Note: There might be a similar problem mounting HFS+ on Linux. However,
  this scenario has been considered unlikely and in light of the cost (in
  the aforementioned benchmark, `core.protectHFS = true` increased the
  time from ~440ms to ~610ms), it was decided _not_ to touch the default
  of `core.protectHFS`.

  This change addresses CVE-2019-1353.

  Reported-by: Nicolas Joly <Nicolas.Joly@microsoft.com>
  Helped-by: Garima Singh <garima.singh@microsoft.com>
  Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
impacted_packages:
  - purl: pkg:github/git/git
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/git/git
        commit: 873a466ea3f233d4fb11f894a311de06939a2a3e
    introduced_in_commits: []
  - purl: pkg:github/git/git
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/git/git
        commit: dd53ea7220606f9ed36db5a0ef910143fdac2903
    introduced_in_commits: []
  - purl: pkg:github/git/git
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/git/git
        commit: 9102f958ee5254b10c0be72672aa3305bf4f4704
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/git/git/tree/873a466ea3f233d4fb11f894a311de06939a2a3e
    reference_type: commit
    reference_id: 873a466ea3f233d4fb11f894a311de06939a2a3e
  - url: https://github.com/git/git/tree/9102f958ee5254b10c0be72672aa3305bf4f4704
    reference_type: commit
    reference_id: 9102f958ee5254b10c0be72672aa3305bf4f4704
  - url: https://github.com/git/git/tree/dd53ea7220606f9ed36db5a0ef910143fdac2903
    reference_type: commit
    reference_id: dd53ea7220606f9ed36db5a0ef910143fdac2903
