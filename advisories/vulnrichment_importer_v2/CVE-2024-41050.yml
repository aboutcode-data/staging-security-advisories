advisory_id: CVE-2024-41050
datasource_id: vulnrichment_importer_v2/CVE-2024-41050
datasource_url: https://github.com/cisagov/vulnrichment/blob/develop/2024/41xxx/CVE-2024-41050.json
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  cachefiles: cyclic allocation of msg_id to avoid reuse

  Reusing the msg_id after a maliciously completed reopen request may cause
  a read request to remain unprocessed and result in a hung, as shown below:

         t1       |      t2       |      t3
  -------------------------------------------------
  cachefiles_ondemand_select_req
   cachefiles_ondemand_object_is_close(A)
   cachefiles_ondemand_set_object_reopening(A)
   queue_work(fscache_object_wq, &info->work)
                  ondemand_object_worker
                   cachefiles_ondemand_init_object(A)
                    cachefiles_ondemand_send_req(OPEN)
                      // get msg_id 6
                      wait_for_completion(&req_A->done)
  cachefiles_ondemand_daemon_read
   // read msg_id 6 req_A
   cachefiles_ondemand_get_fd
   copy_to_user
                                  // Malicious completion msg_id 6
                                  copen 6,-1
                                  cachefiles_ondemand_copen
                                   complete(&req_A->done)
                                   // will not set the object to close
                                   // because ondemand_id && fd is valid.

                  // ondemand_object_worker() is done
                  // but the object is still reopening.

                                  // new open req_B
                                  cachefiles_ondemand_init_object(B)
                                   cachefiles_ondemand_send_req(OPEN)
                                   // reuse msg_id 6
  process_open_req
   copen 6,A.size
   // The expected failed copen was executed successfully

  Expect copen to fail, and when it does, it closes fd, which sets the
  object to close, and then close triggers reopen again. However, due to
  msg_id reuse resulting in a successful copen, the anonymous fd is not
  closed until the daemon exits. Therefore read requests waiting for reopen
  to complete may trigger hung task.

  To avoid this issue, allocate the msg_id cyclically to avoid reusing the
  msg_id for a very short duration of time.
impacted_packages: []
severities:
  - score: Track
    scoring_system: ssvc
    scoring_elements: SSVCv2/E:N/A:N/T:P/P:M/B:A/M:M/D:T/2024-09-10T16:22:44Z/
    published_at: None
    url:
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/19f4f399091478c95947f6bd7ad61622300c30d9
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/35710c6c4a1c64478ec1b5e0e81d386c0844dec6
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/9d3bf4e9aa23f0d9e99ebe7a94f232ddba54ee17
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/de045a82e1a4e04be62718d3c2981a55150765a0
    reference_type:
    reference_id:
