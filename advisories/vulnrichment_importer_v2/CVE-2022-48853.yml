advisory_id: CVE-2022-48853
datasource_id: vulnrichment_importer_v2/CVE-2022-48853
datasource_url: https://github.com/cisagov/vulnrichment/blob/develop/2022/48xxx/CVE-2022-48853.json
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  swiotlb: fix info leak with DMA_FROM_DEVICE

  The problem I'm addressing was discovered by the LTP test covering
  cve-2018-1000204.

  A short description of what happens follows:
  1) The test case issues a command code 00 (TEST UNIT READY) via the SG_IO
     interface with: dxfer_len == 524288, dxdfer_dir == SG_DXFER_FROM_DEV
     and a corresponding dxferp. The peculiar thing about this is that TUR
     is not reading from the device.
  2) In sg_start_req() the invocation of blk_rq_map_user() effectively
     bounces the user-space buffer. As if the device was to transfer into
     it. Since commit a45b599ad808 ("scsi: sg: allocate with __GFP_ZERO in
     sg_build_indirect()") we make sure this first bounce buffer is
     allocated with GFP_ZERO.
  3) For the rest of the story we keep ignoring that we have a TUR, so the
     device won't touch the buffer we prepare as if the we had a
     DMA_FROM_DEVICE type of situation. My setup uses a virtio-scsi device
     and the  buffer allocated by SG is mapped by the function
     virtqueue_add_split() which uses DMA_FROM_DEVICE for the "in" sgs (here
     scatter-gather and not scsi generics). This mapping involves bouncing
     via the swiotlb (we need swiotlb to do virtio in protected guest like
     s390 Secure Execution, or AMD SEV).
  4) When the SCSI TUR is done, we first copy back the content of the second
     (that is swiotlb) bounce buffer (which most likely contains some
     previous IO data), to the first bounce buffer, which contains all
     zeros.  Then we copy back the content of the first bounce buffer to
     the user-space buffer.
  5) The test case detects that the buffer, which it zero-initialized,
    ain't all zeros and fails.

  One can argue that this is an swiotlb problem, because without swiotlb
  we leak all zeros, and the swiotlb should be transparent in a sense that
  it does not affect the outcome (if all other participants are well
  behaved).

  Copying the content of the original buffer into the swiotlb buffer is
  the only way I can think of to make swiotlb transparent in such
  scenarios. So let's do just that if in doubt, but allow the driver
  to tell us that the whole mapped buffer is going to be overwritten,
  in which case we can preserve the old behavior and avoid the performance
  impact of the extra bounce.
impacted_packages: []
severities:
  - score: Track
    scoring_system: ssvc
    scoring_elements: SSVCv2/E:N/A:N/T:P/P:M/B:A/M:M/D:T/2024-09-10T16:25:58Z/
    published_at: None
    url:
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/06cb238b0f7ac1669cb06390704c61794724c191
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/7007c894631cf43041dcfa0da7142bbaa7eb673c
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/901c7280ca0d5e2b4a8929fbe0bfb007ac2a6544
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/aaf166f37eb6bb55d81c3e40a2a460c8875c8813
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/b2f140a9f980806f572d672e1780acea66b9a25c
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/dcead36b19d999d687cd9c99b7f37520d9102b57
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/f2141881b530738777c28bb51c62175895c8178b
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/f3f2247ac31cb71d1f05f56536df5946c6652f4a
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/fd97de9c7b973f46a6103f4170c5efc7b8ef8797
    reference_type:
    reference_id:
