advisory_id: CVE-2024-39510
datasource_id: vulnrichment_importer_v2/CVE-2024-39510
datasource_url: https://github.com/cisagov/vulnrichment/blob/develop/2024/39xxx/CVE-2024-39510.json
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  cachefiles: fix slab-use-after-free in cachefiles_ondemand_daemon_read()

  We got the following issue in a fuzz test of randomly issuing the restore
  command:

  ==================================================================
  BUG: KASAN: slab-use-after-free in cachefiles_ondemand_daemon_read+0xb41/0xb60
  Read of size 8 at addr ffff888122e84088 by task ondemand-04-dae/963

  CPU: 13 PID: 963 Comm: ondemand-04-dae Not tainted 6.8.0-dirty #564
  Call Trace:
   kasan_report+0x93/0xc0
   cachefiles_ondemand_daemon_read+0xb41/0xb60
   vfs_read+0x169/0xb50
   ksys_read+0xf5/0x1e0

  Allocated by task 116:
   kmem_cache_alloc+0x140/0x3a0
   cachefiles_lookup_cookie+0x140/0xcd0
   fscache_cookie_state_machine+0x43c/0x1230
   [...]

  Freed by task 792:
   kmem_cache_free+0xfe/0x390
   cachefiles_put_object+0x241/0x480
   fscache_cookie_state_machine+0x5c8/0x1230
   [...]
  ==================================================================

  Following is the process that triggers the issue:

       mount  |   daemon_thread1    |    daemon_thread2
  ------------------------------------------------------------
  cachefiles_withdraw_cookie
   cachefiles_ondemand_clean_object(object)
    cachefiles_ondemand_send_req
     REQ_A = kzalloc(sizeof(*req) + data_len)
     wait_for_completion(&REQ_A->done)

              cachefiles_daemon_read
               cachefiles_ondemand_daemon_read
                REQ_A = cachefiles_ondemand_select_req
                msg->object_id = req->object->ondemand->ondemand_id
                                    ------ restore ------
                                    cachefiles_ondemand_restore
                                    xas_for_each(&xas, req, ULONG_MAX)
                                     xas_set_mark(&xas, CACHEFILES_REQ_NEW)

                                    cachefiles_daemon_read
                                     cachefiles_ondemand_daemon_read
                                      REQ_A = cachefiles_ondemand_select_req
                copy_to_user(_buffer, msg, n)
                 xa_erase(&cache->reqs, id)
                 complete(&REQ_A->done)
                ------ close(fd) ------
                cachefiles_ondemand_fd_release
                 cachefiles_put_object
   cachefiles_put_object
    kmem_cache_free(cachefiles_object_jar, object)
                                      REQ_A->object->ondemand->ondemand_id
                                       // object UAF !!!

  When we see the request within xa_lock, req->object must not have been
  freed yet, so grab the reference count of object before xa_unlock to
  avoid the above issue.
impacted_packages: []
severities:
  - score: Track
    scoring_system: ssvc
    scoring_elements: SSVCv2/E:N/A:N/T:P/P:M/B:A/M:M/D:T/2024-09-10T17:06:40Z/
    published_at: None
    url:
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/3958679c49152391209b32be3357193300a51abd
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/93064676a2820420a2d37d7c8289f277fe20793d
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/cb55625f8eb9d2de8be4da0c4580d48cbb32058e
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/da4a827416066191aafeeccee50a8836a826ba10
    reference_type:
    reference_id:
