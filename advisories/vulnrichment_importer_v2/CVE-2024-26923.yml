advisory_id: CVE-2024-26923
datasource_id: vulnrichment_importer_v2/CVE-2024-26923
datasource_url: https://github.com/cisagov/vulnrichment/blob/develop/2024/26xxx/CVE-2024-26923.json
aliases: []
summary: "In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: Fix\
  \ garbage collector racing against connect()\n\nGarbage collector does not take into account\
  \ the risk of embryo getting\nenqueued during the garbage collection. If such embryo has a\
  \ peer that\ncarries SCM_RIGHTS, two consecutive passes of scan_children() may see a\ndifferent\
  \ set of children. Leading to an incorrectly elevated inflight\ncount, and then a dangling\
  \ pointer within the gc_inflight_list.\n\nsockets are AF_UNIX/SOCK_STREAM\nS is an unconnected\
  \ socket\nL is a listening in-flight socket bound to addr, not in fdtable\nV's fd will be\
  \ passed via sendmsg(), gets inflight count bumped\n\nconnect(S, addr)\tsendmsg(S, [V]); close(V)\t\
  __unix_gc()\n----------------\t-------------------------\t-----------\n\nNS = unix_create1()\n\
  skb1 = sock_wmalloc(NS)\nL = unix_find_other(addr)\nunix_state_lock(L)\nunix_peer(S) = NS\n\
  \t\t\t// V count=1 inflight=0\n\n \t\t\tNS = unix_peer(S)\n \t\t\tskb2 = sock_alloc()\n\t\t\
  \tskb_queue_tail(NS, skb2[V])\n\n\t\t\t// V became in-flight\n\t\t\t// V count=2 inflight=1\n\
  \n\t\t\tclose(V)\n\n\t\t\t// V count=1 inflight=1\n\t\t\t// GC candidate condition met\n\n\
  \t\t\t\t\t\tfor u in gc_inflight_list:\n\t\t\t\t\t\t  if (total_refs == inflight_refs)\n\t\
  \t\t\t\t\t    add u to gc_candidates\n\n\t\t\t\t\t\t// gc_candidates={L, V}\n\n\t\t\t\t\t\t\
  for u in gc_candidates:\n\t\t\t\t\t\t  scan_children(u, dec_inflight)\n\n\t\t\t\t\t\t// embryo\
  \ (skb1) was not\n\t\t\t\t\t\t// reachable from L yet, so V's\n\t\t\t\t\t\t// inflight remains\
  \ unchanged\n__skb_queue_tail(L, skb1)\nunix_state_unlock(L)\n\t\t\t\t\t\tfor u in gc_candidates:\n\
  \t\t\t\t\t\t  if (u.inflight)\n\t\t\t\t\t\t    scan_children(u, inc_inflight_move_tail)\n\n\
  \t\t\t\t\t\t// V count=1 inflight=2 (!)\n\nIf there is a GC-candidate listening socket, lock/unlock\
  \ its state. This\nmakes GC wait until the end of any ongoing connect() to that socket. After\n\
  flipping the lock, a possibly SCM-laden embryo is already enqueued. And if\nthere is another\
  \ embryo coming, it can not possibly carry SCM_RIGHTS. At\nthis point, unix_inflight() can\
  \ not happen because unix_gc_lock is already\ntaken. Inflight graph remains unaffected."
impacted_packages: []
severities:
  - score: Track
    scoring_system: ssvc
    scoring_elements: SSVCv2/E:N/A:N/T:P/P:M/B:A/M:M/D:T/2024-06-07T17:09:18Z/
    published_at: None
    url:
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/2e2a03787f4f0abc0072350654ab0ef3324d9db3
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/343c5372d5e17b306db5f8f3c895539b06e3177f
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/47d8ac011fe1c9251070e1bd64cb10b48193ec51
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/507cc232ffe53a352847893f8177d276c3b532a9
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/a36ae0ec2353015f0f6762e59f4c2dbc0c906423
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/b75722be422c276b699200de90527d01c602ea7c
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/dbdf7bec5c920200077d693193f989cb1513f009
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/e76c2678228f6aec74b305ae30c9374cc2f28a51
    reference_type:
    reference_id:
