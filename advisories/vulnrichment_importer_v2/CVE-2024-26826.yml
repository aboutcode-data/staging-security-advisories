advisory_id: CVE-2024-26826
datasource_id: vulnrichment_importer_v2/CVE-2024-26826
datasource_url: https://github.com/cisagov/vulnrichment/blob/develop/2024/26xxx/CVE-2024-26826.json
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  mptcp: fix data re-injection from stale subflow

  When the MPTCP PM detects that a subflow is stale, all the packet
  scheduler must re-inject all the mptcp-level unacked data. To avoid
  acquiring unneeded locks, it first try to check if any unacked data
  is present at all in the RTX queue, but such check is currently
  broken, as it uses TCP-specific helper on an MPTCP socket.

  Funnily enough fuzzers and static checkers are happy, as the accessed
  memory still belongs to the mptcp_sock struct, and even from a
  functional perspective the recovery completed successfully, as
  the short-cut test always failed.

  A recent unrelated TCP change - commit d5fed5addb2b ("tcp: reorganize
  tcp_sock fast path variables") - exposed the issue, as the tcp field
  reorganization makes the mptcp code always skip the re-inection.

  Fix the issue dropping the bogus call: we are on a slow path, the early
  optimization proved once again to be evil.
impacted_packages: []
severities:
  - score: Track
    scoring_system: ssvc
    scoring_elements: SSVCv2/E:N/A:N/T:P/P:M/B:A/M:M/D:T/2024-09-10T15:49:00Z/
    published_at: None
    url:
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/624902eab7abcb8731b333ec73f206d38d839cd8
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/6673d9f1c2cd984390550dbdf7d5ae07b20abbf8
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/6f95120f898b40d13fd441225ef511307853c9c2
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/b609c783c535493aa3fca22c7e40a120370b1ca5
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/b6c620dc43ccb4e802894e54b651cf81495e9598
    reference_type:
    reference_id:
