advisory_id: CVE-2025-22059
datasource_id: vulnrichment_importer_v2/CVE-2025-22059
datasource_url: https://github.com/cisagov/vulnrichment/blob/develop/2025/22xxx/CVE-2025-22059.json
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  udp: Fix multiple wraparounds of sk->sk_rmem_alloc.

  __udp_enqueue_schedule_skb() has the following condition:

    if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)
            goto drop;

  sk->sk_rcvbuf is initialised by net.core.rmem_default and later can
  be configured by SO_RCVBUF, which is limited by net.core.rmem_max,
  or SO_RCVBUFFORCE.

  If we set INT_MAX to sk->sk_rcvbuf, the condition is always false
  as sk->sk_rmem_alloc is also signed int.

  Then, the size of the incoming skb is added to sk->sk_rmem_alloc
  unconditionally.

  This results in integer overflow (possibly multiple times) on
  sk->sk_rmem_alloc and allows a single socket to have skb up to
  net.core.udp_mem[1].

  For example, if we set a large value to udp_mem[1] and INT_MAX to
  sk->sk_rcvbuf and flood packets to the socket, we can see multiple
  overflows:

    # cat /proc/net/sockstat | grep UDP:
    UDP: inuse 3 mem 7956736  <-- (7956736 << 12) bytes > INT_MAX * 15
                                               ^- PAGE_SHIFT
    # ss -uam
    State  Recv-Q      ...
    UNCONN -1757018048 ...    <-- flipping the sign repeatedly
           skmem:(r2537949248,rb2147483646,t0,tb212992,f1984,w0,o0,bl0,d0)

  Previously, we had a boundary check for INT_MAX, which was removed by
  commit 6a1f12dd85a8 ("udp: relax atomic operation on sk->sk_rmem_alloc").

  A complete fix would be to revert it and cap the right operand by
  INT_MAX:

    rmem = atomic_add_return(size, &sk->sk_rmem_alloc);
    if (rmem > min(size + (unsigned int)sk->sk_rcvbuf, INT_MAX))
            goto uncharge_drop;

  but we do not want to add the expensive atomic_add_return() back just
  for the corner case.

  Casting rmem to unsigned int prevents multiple wraparounds, but we still
  allow a single wraparound.

    # cat /proc/net/sockstat | grep UDP:
    UDP: inuse 3 mem 524288  <-- (INT_MAX + 1) >> 12

    # ss -uam
    State  Recv-Q      ...
    UNCONN -2147482816 ...   <-- INT_MAX + 831 bytes
           skmem:(r2147484480,rb2147483646,t0,tb212992,f3264,w0,o0,bl0,d14468947)

  So, let's define rmem and rcvbuf as unsigned int and check skb->truesize
  only when rcvbuf is large enough to lower the overflow possibility.

  Note that we still have a small chance to see overflow if multiple skbs
  to the same socket are processed on different core at the same time and
  each size does not exceed the limit but the total size does.

  Note also that we must ignore skb->truesize for a small buffer as
  explained in commit 363dc73acacb ("udp: be less conservative with
  sock rmem accounting").
impacted_packages: []
severities:
  - score: '5.5'
    scoring_system: cvssv3.1
    scoring_elements: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
    published_at: None
    url:
  - score: Track
    scoring_system: ssvc
    scoring_elements: SSVCv2/E:N/A:N/T:P/P:M/B:A/M:M/D:T/2025-10-01T17:41:49Z/
    published_at: None
    url:
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/1f529988efe9870db802cb79d01d8f473099b4d7
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/5a465a0da13ee9fbd7d3cd0b2893309b0fe4b7e3
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/7571aadd20289e9ea10ebfed0986f39ed8b3c16b
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/94d5ad7b41122be33ebc2a6830fe710cba1ecd75
    reference_type:
    reference_id:
