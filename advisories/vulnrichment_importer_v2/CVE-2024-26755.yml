advisory_id: CVE-2024-26755
datasource_id: vulnrichment_importer_v2/CVE-2024-26755
datasource_url: https://github.com/cisagov/vulnrichment/blob/develop/2024/26xxx/CVE-2024-26755.json
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  md: Don't suspend the array for interrupted reshape

  md_start_sync() will suspend the array if there are spares that can be
  added or removed from conf, however, if reshape is still in progress,
  this won't happen at all or data will be corrupted(remove_and_add_spares
  won't be called from md_choose_sync_action for reshape), hence there is
  no need to suspend the array if reshape is not done yet.

  Meanwhile, there is a potential deadlock for raid456:

  1) reshape is interrupted;

  2) set one of the disk WantReplacement, and add a new disk to the array,
     however, recovery won't start until the reshape is finished;

  3) then issue an IO across reshpae position, this IO will wait for
     reshape to make progress;

  4) continue to reshape, then md_start_sync() found there is a spare disk
     that can be added to conf, mddev_suspend() is called;

  Step 4 and step 3 is waiting for each other, deadlock triggered. Noted
  this problem is found by code review, and it's not reporduced yet.

  Fix this porblem by don't suspend the array for interrupted reshape,
  this is safe because conf won't be changed until reshape is done.
impacted_packages: []
severities:
  - score: '5.3'
    scoring_system: cvssv3.1
    scoring_elements: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L
    published_at: None
    url:
  - score: Track
    scoring_system: ssvc
    scoring_elements: SSVCv2/E:N/A:N/T:P/P:M/B:A/M:M/D:T/2024-04-03T18:11:19Z/
    published_at: None
    url:
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/60d6130d0ac1d883ed93c2a1e10aadb60967fd48
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/9e46c70e829bddc24e04f963471e9983a11598b7
    reference_type:
    reference_id:
