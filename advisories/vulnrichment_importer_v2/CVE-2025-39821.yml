advisory_id: CVE-2025-39821
datasource_id: vulnrichment_importer_v2/CVE-2025-39821
datasource_url: https://github.com/cisagov/vulnrichment/blob/develop/2025/39xxx/CVE-2025-39821.json
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  perf: Avoid undefined behavior from stopping/starting inactive events

  Calling pmu->start()/stop() on perf events in PERF_EVENT_STATE_OFF can
  leave event->hw.idx at -1. When PMU drivers later attempt to use this
  negative index as a shift exponent in bitwise operations, it leads to UBSAN
  shift-out-of-bounds reports.

  The issue is a logical flaw in how event groups handle throttling when some
  members are intentionally disabled. Based on the analysis and the
  reproducer provided by Mark Rutland (this issue on both arm64 and x86-64).

  The scenario unfolds as follows:

   1. A group leader event is configured with a very aggressive sampling
      period (e.g., sample_period = 1). This causes frequent interrupts and
      triggers the throttling mechanism.
   2. A child event in the same group is created in a disabled state
      (.disabled = 1). This event remains in PERF_EVENT_STATE_OFF.
      Since it hasn't been scheduled onto the PMU, its event->hw.idx remains
      initialized at -1.
   3. When throttling occurs, perf_event_throttle_group() and later
      perf_event_unthrottle_group() iterate through all siblings, including
      the disabled child event.
   4. perf_event_throttle()/unthrottle() are called on this inactive child
      event, which then call event->pmu->start()/stop().
   5. The PMU driver receives the event with hw.idx == -1 and attempts to
      use it as a shift exponent. e.g., in macros like PMCNTENSET(idx),
      leading to the UBSAN report.

  The throttling mechanism attempts to start/stop events that are not
  actively scheduled on the hardware.

  Move the state check into perf_event_throttle()/perf_event_unthrottle() so
  that inactive events are skipped entirely. This ensures only active events
  with a valid hw.idx are processed, preventing undefined behavior and
  silencing UBSAN warnings. The corrected check ensures true before
  proceeding with PMU operations.

  The problem can be reproduced with the syzkaller reproducer:
impacted_packages: []
severities:
  - score: '7.8'
    scoring_system: cvssv3.1
    scoring_elements: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
    published_at: None
    url:
  - score: Track
    scoring_system: ssvc
    scoring_elements: SSVCv2/E:N/A:N/T:T/P:M/B:A/M:M/D:T/2026-01-14T18:16:47Z/
    published_at: None
    url:
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/b64fdd422a85025b5e91ead794db9d3ef970e369
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/d689135aa9c5e4e0eab5a92bbe35dab0c8d6677f
    reference_type:
    reference_id:
