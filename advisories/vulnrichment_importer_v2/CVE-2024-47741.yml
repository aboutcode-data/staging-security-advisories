advisory_id: CVE-2024-47741
datasource_id: vulnrichment_importer_v2/CVE-2024-47741
datasource_url: https://github.com/cisagov/vulnrichment/blob/develop/2024/47xxx/CVE-2024-47741.json
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  btrfs: fix race setting file private on concurrent lseek using same fd

  When doing concurrent lseek(2) system calls against the same file
  descriptor, using multiple threads belonging to the same process, we have
  a short time window where a race happens and can result in a memory leak.

  The race happens like this:

  1) A program opens a file descriptor for a file and then spawns two
     threads (with the pthreads library for example), lets call them
     task A and task B;

  2) Task A calls lseek with SEEK_DATA or SEEK_HOLE and ends up at
     file.c:find_desired_extent() while holding a read lock on the inode;

  3) At the start of find_desired_extent(), it extracts the file's
     private_data pointer into a local variable named 'private', which has
     a value of NULL;

  4) Task B also calls lseek with SEEK_DATA or SEEK_HOLE, locks the inode
     in shared mode and enters file.c:find_desired_extent(), where it also
     extracts file->private_data into its local variable 'private', which
     has a NULL value;

  5) Because it saw a NULL file private, task A allocates a private
     structure and assigns to the file structure;

  6) Task B also saw a NULL file private so it also allocates its own file
     private and then assigns it to the same file structure, since both
     tasks are using the same file descriptor.

     At this point we leak the private structure allocated by task A.

  Besides the memory leak, there's also the detail that both tasks end up
  using the same cached state record in the private structure (struct
  btrfs_file_private::llseek_cached_state), which can result in a
  use-after-free problem since one task can free it while the other is
  still using it (only one task took a reference count on it). Also, sharing
  the cached state is not a good idea since it could result in incorrect
  results in the future - right now it should not be a problem because it
  end ups being used only in extent-io-tree.c:count_range_bits() where we do
  range validation before using the cached state.

  Fix this by protecting the private assignment and check of a file while
  holding the inode's spinlock and keep track of the task that allocated
  the private, so that it's used only by that task in order to prevent
  user-after-free issues with the cached state record as well as potentially
  using it incorrectly in the future.
impacted_packages: []
severities:
  - score: Track
    scoring_system: ssvc
    scoring_elements: SSVCv2/E:N/A:N/T:P/P:M/B:A/M:M/D:T/2024-10-21T12:59:11Z/
    published_at: None
    url:
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/33d1310d4496e904123dab9c28b2d8d2c1800f97
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/7ee85f5515e86a4e2a2f51969795920733912bad
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/a412ca489ac27b9d0e603499315b7139c948130d
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/f56a6d9c267ec7fa558ede7755551c047b1034cd
    reference_type:
    reference_id:
