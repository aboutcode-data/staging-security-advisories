advisory_id: CVE-2022-48727
datasource_id: vulnrichment_importer_v2/CVE-2022-48727
datasource_url: https://github.com/cisagov/vulnrichment/blob/develop/2022/48xxx/CVE-2022-48727.json
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  KVM: arm64: Avoid consuming a stale esr value when SError occur

  When any exception other than an IRQ occurs, the CPU updates the ESR_EL2
  register with the exception syndrome. An SError may also become pending,
  and will be synchronised by KVM. KVM notes the exception type, and whether
  an SError was synchronised in exit_code.

  When an exception other than an IRQ occurs, fixup_guest_exit() updates
  vcpu->arch.fault.esr_el2 from the hardware register. When an SError was
  synchronised, the vcpu esr value is used to determine if the exception
  was due to an HVC. If so, ELR_EL2 is moved back one instruction. This
  is so that KVM can process the SError first, and re-execute the HVC if
  the guest survives the SError.

  But if an IRQ synchronises an SError, the vcpu's esr value is stale.
  If the previous non-IRQ exception was an HVC, KVM will corrupt ELR_EL2,
  causing an unrelated guest instruction to be executed twice.

  Check ARM_EXCEPTION_CODE() before messing with ELR_EL2, IRQs don't
  update this register so don't need to check.
impacted_packages: []
severities:
  - score: Track
    scoring_system: ssvc
    scoring_elements: SSVCv2/E:N/A:N/T:P/P:M/B:A/M:M/D:T/2024-06-20T16:20:44Z/
    published_at: None
    url:
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/1c71dbc8a179d99dd9bb7e7fc1888db613cf85de
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/57e2986c3b25092691a6e3d6ee9168caf8978932
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/e1e852746997500f1873f60b954da5f02cc2dba3
    reference_type:
    reference_id:
