advisory_id: CVE-2023-52476
datasource_id: vulnrichment_importer_v2/CVE-2023-52476
datasource_url: https://github.com/cisagov/vulnrichment/blob/develop/2023/52xxx/CVE-2023-52476.json
aliases: []
summary: |
  In the Linux kernel, the following vulnerability has been resolved:

  perf/x86/lbr: Filter vsyscall addresses

  We found that a panic can occur when a vsyscall is made while LBR sampling
  is active. If the vsyscall is interrupted (NMI) for perf sampling, this
  call sequence can occur (most recent at top):

      __insn_get_emulate_prefix()
      insn_get_emulate_prefix()
      insn_get_prefixes()
      insn_get_opcode()
      decode_branch_type()
      get_branch_type()
      intel_pmu_lbr_filter()
      intel_pmu_handle_irq()
      perf_event_nmi_handler()

  Within __insn_get_emulate_prefix() at frame 0, a macro is called:

      peek_nbyte_next(insn_byte_t, insn, i)

  Within this macro, this dereference occurs:

      (insn)->next_byte

  Inspecting registers at this point, the value of the next_byte field is the
  address of the vsyscall made, for example the location of the vsyscall
  version of gettimeofday() at 0xffffffffff600000. The access to an address
  in the vsyscall region will trigger an oops due to an unhandled page fault.

  To fix the bug, filtering for vsyscalls can be done when
  determining the branch type. This patch will return
  a "none" branch if a kernel address if found to lie in the
  vsyscall region.
impacted_packages: []
severities:
  - score: Track
    scoring_system: ssvc
    scoring_elements: SSVCv2/E:N/A:N/T:P/P:M/B:A/M:M/D:T/2024-03-06T16:50:56Z/
    published_at: None
    url:
weaknesses: []
references:
  - url: https://git.kernel.org/stable/c/3863989497652488a50f00e96de4331e5efabc6c
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/e53899771a02f798d436655efbd9d4b46c0f9265
    reference_type:
    reference_id:
  - url: https://git.kernel.org/stable/c/f71edacbd4f99c0e12fe4a4007ab4d687d0688db
    reference_type:
    reference_id:
