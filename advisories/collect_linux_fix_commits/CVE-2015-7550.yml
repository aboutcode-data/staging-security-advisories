advisory_id: CVE-2015-7550
datasource_id: collect_linux_fix_commits/CVE-2015-7550
datasource_url: https://github.com/torvalds/linux
aliases: []
summary: "b4a1b4f5047e4f54e194681125c74c0aa64d637d:KEYS: Fix race between read and revoke\n\n\
  This fixes CVE-2015-7550.\n\nThere's a race between keyctl_read() and keyctl_revoke().  If\
  \ the revoke\nhappens between keyctl_read() checking the validity of a key and the key's\n\
  semaphore being taken, then the key type read method will see a revoked key.\n\nThis causes\
  \ a problem for the user-defined key type because it assumes in\nits read method that there\
  \ will always be a payload in a non-revoked key\nand doesn't check for a NULL pointer.\n\n\
  Fix this by making keyctl_read() check the validity of a key after taking\nsemaphore instead\
  \ of before.\n\nI think the bug was introduced with the original keyrings code.\n\nThis was\
  \ discovered by a multithreaded test program generated by syzkaller\n(http://github.com/google/syzkaller).\
  \  Here's a cleaned up version:\n\n\t#include <sys/types.h>\n\t#include <keyutils.h>\n\t#include\
  \ <pthread.h>\n\tvoid *thr0(void *arg)\n\t{\n\t\tkey_serial_t key = (unsigned long)arg;\n\t\
  \tkeyctl_revoke(key);\n\t\treturn 0;\n\t}\n\tvoid *thr1(void *arg)\n\t{\n\t\tkey_serial_t\
  \ key = (unsigned long)arg;\n\t\tchar buffer[16];\n\t\tkeyctl_read(key, buffer, 16);\n\t\t\
  return 0;\n\t}\n\tint main()\n\t{\n\t\tkey_serial_t key = add_key(\"user\", \"%\", \"foo\"\
  , 3, KEY_SPEC_USER_KEYRING);\n\t\tpthread_t th[5];\n\t\tpthread_create(&th[0], 0, thr0, (void\
  \ *)(unsigned long)key);\n\t\tpthread_create(&th[1], 0, thr1, (void *)(unsigned long)key);\n\
  \t\tpthread_create(&th[2], 0, thr0, (void *)(unsigned long)key);\n\t\tpthread_create(&th[3],\
  \ 0, thr1, (void *)(unsigned long)key);\n\t\tpthread_join(th[0], 0);\n\t\tpthread_join(th[1],\
  \ 0);\n\t\tpthread_join(th[2], 0);\n\t\tpthread_join(th[3], 0);\n\t\treturn 0;\n\t}\n\nBuild\
  \ as:\n\n\tcc -o keyctl-race keyctl-race.c -lkeyutils -lpthread\n\nRun as:\n\n\twhile keyctl-race;\
  \ do :; done\n\nas it may need several iterations to crash the kernel.  The crash can be\n\
  summarised as:\n\n\tBUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n\
  \tIP: [<ffffffff81279b08>] user_read+0x56/0xa3\n\t...\n\tCall Trace:\n\t [<ffffffff81276aa9>]\
  \ keyctl_read_key+0xb6/0xd7\n\t [<ffffffff81277815>] SyS_keyctl+0x83/0xe0\n\t [<ffffffff815dbb97>]\
  \ entry_SYSCALL_64_fastpath+0x12/0x6f\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\n\
  Signed-off-by: David Howells <dhowells@redhat.com>\nTested-by: Dmitry Vyukov <dvyukov@google.com>\n\
  Cc: stable@vger.kernel.org\nSigned-off-by: James Morris <james.l.morris@oracle.com>"
impacted_packages:
  - purl: pkg:github/torvalds/linux
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/torvalds/linux
        commit: b4a1b4f5047e4f54e194681125c74c0aa64d637d
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/torvalds/linux/tree/b4a1b4f5047e4f54e194681125c74c0aa64d637d
    reference_type: commit
    reference_id: b4a1b4f5047e4f54e194681125c74c0aa64d637d
