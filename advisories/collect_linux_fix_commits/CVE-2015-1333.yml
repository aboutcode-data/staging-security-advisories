advisory_id: CVE-2015-1333
datasource_id: collect_linux_fix_commits/CVE-2015-1333
datasource_url: https://github.com/torvalds/linux
aliases: []
summary: |
  ca4da5dd1f99fe9c59f1709fb43e818b18ad20e0:KEYS: ensure we free the assoc array edit if edit is valid

  __key_link_end is not freeing the associated array edit structure
  and this leads to a 512 byte memory leak each time an identical
  existing key is added with add_key().

  The reason the add_key() system call returns okay is that
  key_create_or_update() calls __key_link_begin() before checking to see
  whether it can update a key directly rather than adding/replacing - which
  it turns out it can.  Thus __key_link() is not called through
  __key_instantiate_and_link() and __key_link_end() must cancel the edit.

  CVE-2015-1333

  Signed-off-by: Colin Ian King <colin.king@canonical.com>
  Signed-off-by: David Howells <dhowells@redhat.com>
  Signed-off-by: James Morris <james.l.morris@oracle.com>
impacted_packages:
  - purl: pkg:github/torvalds/linux
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/torvalds/linux
        commit: ca4da5dd1f99fe9c59f1709fb43e818b18ad20e0
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/torvalds/linux/tree/ca4da5dd1f99fe9c59f1709fb43e818b18ad20e0
    reference_type: commit
    reference_id: ca4da5dd1f99fe9c59f1709fb43e818b18ad20e0
