advisory_id: CVE-2019-5736
datasource_id: collect_linux_fix_commits/CVE-2019-5736
datasource_url: https://github.com/torvalds/linux
aliases: []
summary: |
  2a010c41285345da60cece35575b4e0af7e7bf44:fs: don't block i_writecount during exec

  Back in 2021 we already discussed removing deny_write_access() for
  executables. Back then I was hesistant because I thought that this might
  cause issues in userspace. But even back then I had started taking some
  notes on what could potentially depend on this and I didn't come up with
  a lot so I've changed my mind and I would like to try this.

  Here are some of the notes that I took:

  (1) The deny_write_access() mechanism is causing really pointless issues
      such as [1]. If a thread in a thread-group opens a file writable,
      then writes some stuff, then closing the file descriptor and then
      calling execve() they can fail the execve() with ETXTBUSY because
      another thread in the thread-group could have concurrently called
      fork(). Multi-threaded libraries such as go suffer from this.

  (2) There are userspace attacks that rely on overwriting the binary of a
      running process. These attacks are _mitigated_ but _not at all
      prevented_ from ocurring by the deny_write_access() mechanism.

      I'll go over some details. The clearest example of such attacks was
      the attack against runC in CVE-2019-5736 (cf. [3]).

      An attack could compromise the runC host binary from inside a
      _privileged_ runC container. The malicious binary could then be used
      to take over the host.

      (It is crucial to note that this attack is _not_ possible with
       unprivileged containers. IOW, the setup here is already insecure.)

      The attack can be made when attaching to a running container or when
      starting a container running a specially crafted image. For example,
      when runC attaches to a container the attacker can trick it into
      executing itself.

      This could be done by replacing the target binary inside the
      container with a custom binary pointing back at the runC binary
      itself. As an example, if the target binary was /bin/bash, this
      could be replaced with an executable script specifying the
      interpreter path #!/proc/self/exe.

      As such when /bin/bash is executed inside the container, instead the
      target of /proc/self/exe will be executed. That magic link will
      point to the runc binary on the host. The attacker can then proceed
      to write to the target of /proc/self/exe to try and overwrite the
      runC binary on the host.

      However, this will not succeed because of deny_write_access(). Now,
      one might think that this would prevent the attack but it doesn't.

      To overcome this, the attacker has multiple ways:
      * Open a file descriptor to /proc/self/exe using the O_PATH flag and
        then proceed to reopen the binary as O_WRONLY through
        /proc/self/fd/<nr> and try to write to it in a busy loop from a
        separate process. Ultimately it will succeed when the runC binary
        exits. After this the runC binary is compromised and can be used
        to attack other containers or the host itself.
      * Use a malicious shared library annotating a function in there with
        the constructor attribute making the malicious function run as an
        initializor. The malicious library will then open /proc/self/exe
        for creating a new entry under /proc/self/fd/<nr>. It'll then call
        exec to a) force runC to exit and b) hand the file descriptor off
        to a program that then reopens /proc/self/fd/<nr> for writing
        (which is now possible because runC has exited) and overwriting
        that binary.

      To sum up: the deny_write_access() mechanism doesn't prevent such
      attacks in insecure setups. It just makes them minimally harder.
      That's all.

      The only way back then to prevent this is to create a temporary copy
      of the calling binary itself when it starts or attaches to
      containers. So what I did back then for LXC (and Aleksa for runC)
      was to create an anonymous, in-memory file using the memfd_create()
      system call and to copy itself into the temporary in-memory file,
      which is then sealed to prevent further modifications. This sealed,
      in-memory file copy is then executed instead of the original on-disk
      binary.

      Any compromising write operations from a privileged container to the
      host binary will then write to the temporary in-memory binary and
      not to the host binary on-disk, preserving the integrity of the host
      binary. Also as the temporary, in-memory binary is sealed, writes to
      this will also fail.

      The point is that deny_write_access() is uselss to prevent these
      attacks.

  (3) Denying write access to an inode because it's currently used in an
      exec path could easily be done on an LSM level. It might need an
      additional hook but that should be about it.

  (4) The MAP_DENYWRITE flag for mmap() has been deprecated a long time
      ago so while we do protect the main executable the bigger portion of
      the things you'd think need protecting such as the shared libraries
      aren't. IOW, we let anyone happily overwrite shared libraries.

  (5) We removed all remaining uses of VM_DENYWRITE in [2]. That means:
      (5.1) We removed the legacy uselib() protection for preventing
            overwriting of shared libraries. Nobody cared in 3 years.
      (5.2) We allow write access to the elf interpreter after exec
            completed treating it on a par with shared libraries.

  Yes, someone in userspace could potentially be relying on this. It's not
  completely out of the realm of possibility but let's find out if that's
  actually the case and not guess.

  Link: https://github.com/golang/go/issues/22315 [1]
  Link: 49624efa65ac ("Merge tag 'denywrite-for-5.15' of git://github.com/davidhildenbrand/linux") [2]
  Link: https://unit42.paloaltonetworks.com/breaking-docker-via-runc-explaining-cve-2019-5736 [3]
  Link: https://lwn.net/Articles/866493
  Link: https://github.com/golang/go/issues/22220
  Link: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/work/buildid.go#L724
  Link: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/work/exec.go#L1493
  Link: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/script/cmds.go#L457
  Link: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/test/test.go#L1557
  Link: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/os/exec/lp_linux_test.go#L61
  Link: https://github.com/buildkite/agent/pull/2736
  Link: https://github.com/rust-lang/rust/issues/114554
  Link: https://bugs.openjdk.org/browse/JDK-8068370
  Link: https://github.com/dotnet/runtime/issues/58964
  Link: https://lore.kernel.org/r/20240531-vfs-i_writecount-v1-1-a17bea7ee36b@kernel.org
  Reviewed-by: Josef Bacik <josef@toxicpanda.com>
  Signed-off-by: Christian Brauner <brauner@kernel.org>
  6aee4badd8126f3a2b6d31c5e2db2439d316374f:Merge branch 'work.openat2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs

  Pull openat2 support from Al Viro:
   "This is the openat2() series from Aleksa Sarai.

    I'm afraid that the rest of namei stuff will have to wait - it got
    zero review the last time I'd posted #work.namei, and there had been a
    leak in the posted series I'd caught only last weekend. I was going to
    repost it on Monday, but the window opened and the odds of getting any
    review during that... Oh, well.

    Anyway, openat2 part should be ready; that _did_ get sane amount of
    review and public testing, so here it comes"

  From Aleksa's description of the series:
   "For a very long time, extending openat(2) with new features has been
    incredibly frustrating. This stems from the fact that openat(2) is
    possibly the most famous counter-example to the mantra "don't silently
    accept garbage from userspace" -- it doesn't check whether unknown
    flags are present[1].

    This means that (generally) the addition of new flags to openat(2) has
    been fraught with backwards-compatibility issues (O_TMPFILE has to be
    defined as __O_TMPFILE|O_DIRECTORY|[O_RDWR or O_WRONLY] to ensure old
    kernels gave errors, since it's insecure to silently ignore the
    flag[2]). All new security-related flags therefore have a tough road
    to being added to openat(2).

    Furthermore, the need for some sort of control over VFS's path
    resolution (to avoid malicious paths resulting in inadvertent
    breakouts) has been a very long-standing desire of many userspace
    applications.

    This patchset is a revival of Al Viro's old AT_NO_JUMPS[3] patchset
    (which was a variant of David Drysdale's O_BENEATH patchset[4] which
    was a spin-off of the Capsicum project[5]) with a few additions and
    changes made based on the previous discussion within [6] as well as
    others I felt were useful.

    In line with the conclusions of the original discussion of
    AT_NO_JUMPS, the flag has been split up into separate flags. However,
    instead of being an openat(2) flag it is provided through a new
    syscall openat2(2) which provides several other improvements to the
    openat(2) interface (see the patch description for more details). The
    following new LOOKUP_* flags are added:

    LOOKUP_NO_XDEV:

       Blocks all mountpoint crossings (upwards, downwards, or through
       absolute links). Absolute pathnames alone in openat(2) do not
       trigger this. Magic-link traversal which implies a vfsmount jump is
       also blocked (though magic-link jumps on the same vfsmount are
       permitted).

    LOOKUP_NO_MAGICLINKS:

       Blocks resolution through /proc/$pid/fd-style links. This is done
       by blocking the usage of nd_jump_link() during resolution in a
       filesystem. The term "magic-links" is used to match with the only
       reference to these links in Documentation/, but I'm happy to change
       the name.

       It should be noted that this is different to the scope of
       ~LOOKUP_FOLLOW in that it applies to all path components. However,
       you can do openat2(NO_FOLLOW|NO_MAGICLINKS) on a magic-link and it
       will *not* fail (assuming that no parent component was a
       magic-link), and you will have an fd for the magic-link.

       In order to correctly detect magic-links, the introduction of a new
       LOOKUP_MAGICLINK_JUMPED state flag was required.

    LOOKUP_BENEATH:

       Disallows escapes to outside the starting dirfd's
       tree, using techniques such as ".." or absolute links. Absolute
       paths in openat(2) are also disallowed.

       Conceptually this flag is to ensure you "stay below" a certain
       point in the filesystem tree -- but this requires some additional
       to protect against various races that would allow escape using
       "..".

       Currently LOOKUP_BENEATH implies LOOKUP_NO_MAGICLINKS, because it
       can trivially beam you around the filesystem (breaking the
       protection). In future, there might be similar safety checks done
       as in LOOKUP_IN_ROOT, but that requires more discussion.

    In addition, two new flags are added that expand on the above ideas:

    LOOKUP_NO_SYMLINKS:

       Does what it says on the tin. No symlink resolution is allowed at
       all, including magic-links. Just as with LOOKUP_NO_MAGICLINKS this
       can still be used with NOFOLLOW to open an fd for the symlink as
       long as no parent path had a symlink component.

    LOOKUP_IN_ROOT:

       This is an extension of LOOKUP_BENEATH that, rather than blocking
       attempts to move past the root, forces all such movements to be
       scoped to the starting point. This provides chroot(2)-like
       protection but without the cost of a chroot(2) for each filesystem
       operation, as well as being safe against race attacks that
       chroot(2) is not.

       If a race is detected (as with LOOKUP_BENEATH) then an error is
       generated, and similar to LOOKUP_BENEATH it is not permitted to
       cross magic-links with LOOKUP_IN_ROOT.

       The primary need for this is from container runtimes, which
       currently need to do symlink scoping in userspace[7] when opening
       paths in a potentially malicious container.

       There is a long list of CVEs that could have bene mitigated by
       having RESOLVE_THIS_ROOT (such as CVE-2017-1002101,
       CVE-2017-1002102, CVE-2018-15664, and CVE-2019-5736, just to name a
       few).

    In order to make all of the above more usable, I'm working on
    libpathrs[8] which is a C-friendly library for safe path resolution.
    It features a userspace-emulated backend if the kernel doesn't support
    openat2(2). Hopefully we can get userspace to switch to using it, and
    thus get openat2(2) support for free once it's ready.

    Future work would include implementing things like
    RESOLVE_NO_AUTOMOUNT and possibly a RESOLVE_NO_REMOTE (to allow
    programs to be sure they don't hit DoSes though stale NFS handles)"

  * 'work.openat2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
    Documentation: path-lookup: include new LOOKUP flags
    selftests: add openat2(2) selftests
    open: introduce openat2(2) syscall
    namei: LOOKUP_{IN_ROOT,BENEATH}: permit limited ".." resolution
    namei: LOOKUP_IN_ROOT: chroot-like scoped resolution
    namei: LOOKUP_BENEATH: O_BENEATH-like scoped resolution
    namei: LOOKUP_NO_XDEV: block mountpoint crossing
    namei: LOOKUP_NO_MAGICLINKS: block magic-link resolution
    namei: LOOKUP_NO_SYMLINKS: block symlink resolution
    namei: allow set_root() to produce errors
    namei: allow nd_jump_link() to produce errors
    nsfs: clean-up ns_get_path() signature to return int
    namei: only return -ECHILD from follow_dotdot_rcu()
impacted_packages:
  - purl: pkg:github/torvalds/linux
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/torvalds/linux
        commit: 6aee4badd8126f3a2b6d31c5e2db2439d316374f
    introduced_in_commits: []
  - purl: pkg:github/torvalds/linux
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/torvalds/linux
        commit: 2a010c41285345da60cece35575b4e0af7e7bf44
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/torvalds/linux/tree/2a010c41285345da60cece35575b4e0af7e7bf44
    reference_type: commit
    reference_id: 2a010c41285345da60cece35575b4e0af7e7bf44
  - url: https://github.com/torvalds/linux/tree/6aee4badd8126f3a2b6d31c5e2db2439d316374f
    reference_type: commit
    reference_id: 6aee4badd8126f3a2b6d31c5e2db2439d316374f
