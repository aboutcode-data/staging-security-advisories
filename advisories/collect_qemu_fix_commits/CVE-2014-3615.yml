advisory_id: CVE-2014-3615
datasource_id: collect_qemu_fix_commits/CVE-2014-3615
datasource_url: https://gitlab.com/qemu-project/qemu
aliases: []
summary: |
  1aa87d3689cc2388a74c9db1dd728c6f4673836e:spice: make sure we don't overflow ssd->buf

  Related spice-only bug.  We have a fixed 16 MB buffer here, being
  presented to the spice-server as qxl video memory in case spice is
  used with a non-qxl card.  It's also used with qxl in vga mode.

  When using display resolutions requiring more than 16 MB of memory we
  are going to overflow that buffer.  In theory the guest can write,
  indirectly via spice-server.  The spice-server clears the memory after
  setting a new video mode though, triggering a segfault in the overflow
  case, so qemu crashes before the guest has a chance to do something
  evil.

  Fix that by switching to dynamic allocation for the buffer.

  CVE-2014-3615

  Cc: qemu-stable@nongnu.org
  Cc: secalert@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  Reviewed-by: Laszlo Ersek <lersek@redhat.com>
  (cherry picked from commit ab9509cceabef28071e41bdfa073083859c949a7)
  Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  7fe5418d9ff335f860a6a44aafae30445052db86:vbe: rework sanity checks

  Plug a bunch of holes in the bochs dispi interface parameter checking.
  Add a function doing verification on all registers.  Call that
  unconditionally on every register write.  That way we should catch
  everything, even changing one register affecting the valid range of
  another register.

  Some of the holes have been added by commit
  e9c6149f6ae6873f14a12eea554925b6aa4c4dec.  Before that commit the
  maximum possible framebuffer (VBE_DISPI_MAX_XRES * VBE_DISPI_MAX_YRES *
  32 bpp) has been smaller than the qemu vga memory (8MB) and the checking
  for VBE_DISPI_MAX_XRES + VBE_DISPI_MAX_YRES + VBE_DISPI_MAX_BPP was ok.

  Some of the holes have been there forever, such as
  VBE_DISPI_INDEX_X_OFFSET and VBE_DISPI_INDEX_Y_OFFSET register writes
  lacking any verification.

  Security impact:

  (1) Guest can make the ui (gtk/vnc/...) use memory rages outside the vga
  frame buffer as source  ->  host memory leak.  Memory isn't leaked to
  the guest but to the vnc client though.

  (2) Qemu will segfault in case the memory range happens to include
  unmapped areas  ->  Guest can DoS itself.

  The guest can not modify host memory, so I don't think this can be used
  by the guest to escape.

  CVE-2014-3615

  Cc: qemu-stable@nongnu.org
  Cc: secalert@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  Reviewed-by: Laszlo Ersek <lersek@redhat.com>
  (cherry picked from commit c1b886c45dc70f247300f549dce9833f3fa2def5)
  Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  5fd7fc8db92adea953ecf5917168989a28e8871f:Merge remote-tracking branch 'remotes/kraxel/tags/pull-cve-2014-3615-20140905-1' into staging

  CVE-2014-3615: fix sanity checks in vbe (bochs dispi) and spice.

  # gpg: Signature made Fri 05 Sep 2014 12:18:04 BST using RSA key ID D3E87138
  # gpg: Good signature from "Gerd Hoffmann (work) <kraxel@redhat.com>"
  # gpg:                 aka "Gerd Hoffmann <gerd@kraxel.org>"
  # gpg:                 aka "Gerd Hoffmann (private) <kraxel@gmail.com>"

  * remotes/kraxel/tags/pull-cve-2014-3615-20140905-1:
    spice: make sure we don't overflow ssd->buf
    vbe: rework sanity checks
    vbe: make bochs dispi interface return the correct memory size with qxl

  Signed-off-by: Peter Maydell <peter.maydell@linaro.org>
  ab9509cceabef28071e41bdfa073083859c949a7:spice: make sure we don't overflow ssd->buf

  Related spice-only bug.  We have a fixed 16 MB buffer here, being
  presented to the spice-server as qxl video memory in case spice is
  used with a non-qxl card.  It's also used with qxl in vga mode.

  When using display resolutions requiring more than 16 MB of memory we
  are going to overflow that buffer.  In theory the guest can write,
  indirectly via spice-server.  The spice-server clears the memory after
  setting a new video mode though, triggering a segfault in the overflow
  case, so qemu crashes before the guest has a chance to do something
  evil.

  Fix that by switching to dynamic allocation for the buffer.

  CVE-2014-3615

  Cc: qemu-stable@nongnu.org
  Cc: secalert@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  Reviewed-by: Laszlo Ersek <lersek@redhat.com>
  c1b886c45dc70f247300f549dce9833f3fa2def5:vbe: rework sanity checks

  Plug a bunch of holes in the bochs dispi interface parameter checking.
  Add a function doing verification on all registers.  Call that
  unconditionally on every register write.  That way we should catch
  everything, even changing one register affecting the valid range of
  another register.

  Some of the holes have been added by commit
  e9c6149f6ae6873f14a12eea554925b6aa4c4dec.  Before that commit the
  maximum possible framebuffer (VBE_DISPI_MAX_XRES * VBE_DISPI_MAX_YRES *
  32 bpp) has been smaller than the qemu vga memory (8MB) and the checking
  for VBE_DISPI_MAX_XRES + VBE_DISPI_MAX_YRES + VBE_DISPI_MAX_BPP was ok.

  Some of the holes have been there forever, such as
  VBE_DISPI_INDEX_X_OFFSET and VBE_DISPI_INDEX_Y_OFFSET register writes
  lacking any verification.

  Security impact:

  (1) Guest can make the ui (gtk/vnc/...) use memory rages outside the vga
  frame buffer as source  ->  host memory leak.  Memory isn't leaked to
  the guest but to the vnc client though.

  (2) Qemu will segfault in case the memory range happens to include
  unmapped areas  ->  Guest can DoS itself.

  The guest can not modify host memory, so I don't think this can be used
  by the guest to escape.

  CVE-2014-3615

  Cc: qemu-stable@nongnu.org
  Cc: secalert@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  Reviewed-by: Laszlo Ersek <lersek@redhat.com>
impacted_packages:
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 5fd7fc8db92adea953ecf5917168989a28e8871f
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 7fe5418d9ff335f860a6a44aafae30445052db86
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: c1b886c45dc70f247300f549dce9833f3fa2def5
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 1aa87d3689cc2388a74c9db1dd728c6f4673836e
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: ab9509cceabef28071e41bdfa073083859c949a7
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://gitlab.com/qemu-project/qemu
    reference_type: commit
    reference_id: 91c6438caffc880e999a7312825479685d659b44
