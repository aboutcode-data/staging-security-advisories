advisory_id: CVE-2017-15268
datasource_id: collect_qemu_fix_commits/CVE-2017-15268
datasource_url: https://gitlab.com/qemu-project/qemu
aliases: []
summary: |
  f9e53c77ea3bfe92ddc8c755935e7521dd3ed08e:ui: fix VNC client throttling when forced update is requested

  The VNC server must throttle data sent to the client to prevent the 'output'
  buffer size growing without bound, if the client stops reading data off the
  socket (either maliciously or due to stalled/slow network connection).

  The current throttling is very crude because it simply checks whether the
  output buffer offset is zero. This check is disabled if the client has requested
  a forced update, because we want to send these as soon as possible.

  As a result, the VNC client can cause QEMU to allocate arbitrary amounts of RAM.
  They can first start something in the guest that triggers lots of framebuffer
  updates eg play a youtube video. Then repeatedly send full framebuffer update
  requests, but never read data back from the server. This can easily make QEMU's
  VNC server send buffer consume 100MB of RAM per second, until the OOM killer
  starts reaping processes (hopefully the rogue QEMU process, but it might pick
  others...).

  To address this we make the throttling more intelligent, so we can throttle
  full updates. When we get a forced update request, we keep track of exactly how
  much data we put on the output buffer. We will not process a subsequent forced
  update request until this data has been fully sent on the wire. We always allow
  one forced update request to be in flight, regardless of what data is queued
  for incremental updates or audio data. The slight complication is that we do
  not initially know how much data an update will send, as this is done in the
  background by the VNC job thread. So we must track the fact that the job thread
  has an update pending, and not process any further updates until this job is
  has been completed & put data on the output buffer.

  This unbounded memory growth affects all VNC server configurations supported by
  QEMU, with no workaround possible. The mitigating factor is that it can only be
  triggered by a client that has authenticated with the VNC server, and who is
  able to trigger a large quantity of framebuffer updates or audio samples from
  the guest OS. Mostly they'll just succeed in getting the OOM killer to kill
  their own QEMU process, but its possible other processes can get taken out as
  collateral damage.

  This is a more general variant of the similar unbounded memory usage flaw in
  the websockets server, that was previously assigned CVE-2017-15268, and fixed
  in 2.11 by:

    commit a7b20a8efa28e5f22c26c06cd06c2f12bc863493
    Author: Daniel P. Berrange <berrange@redhat.com>
    Date:   Mon Oct 9 14:43:42 2017 +0100

      io: monitor encoutput buffer size from websocket GSource

  This new general memory usage flaw has been assigned CVE-2017-15124, and is
  partially fixed by this patch.

  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
  Reviewed-by: Darren Kenny <darren.kenny@oracle.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-id: 20171218191228.31018-11-berrange@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  (cherry picked from commit ada8d2e4369ea49677d8672ac81bce73eefd5b54)
  Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  f9c8767828aa44441681ea683f53cef8135050cd:ui: fix VNC client throttling when audio capture is active

  The VNC server must throttle data sent to the client to prevent the 'output'
  buffer size growing without bound, if the client stops reading data off the
  socket (either maliciously or due to stalled/slow network connection).

  The current throttling is very crude because it simply checks whether the
  output buffer offset is zero. This check must be disabled if audio capture is
  enabled, because when streaming audio the output buffer offset will rarely be
  zero due to queued audio data, and so this would starve framebuffer updates.

  As a result, the VNC client can cause QEMU to allocate arbitrary amounts of RAM.
  They can first start something in the guest that triggers lots of framebuffer
  updates eg play a youtube video. Then enable audio capture, and simply never
  read data back from the server. This can easily make QEMU's VNC server send
  buffer consume 100MB of RAM per second, until the OOM killer starts reaping
  processes (hopefully the rogue QEMU process, but it might pick others...).

  To address this we make the throttling more intelligent, so we can throttle
  when audio capture is active too. To determine how to throttle incremental
  updates or audio data, we calculate a size threshold. Normally the threshold is
  the approximate number of bytes associated with a single complete framebuffer
  update. ie width * height * bytes per pixel. We'll send incremental updates
  until we hit this threshold, at which point we'll stop sending updates until
  data has been written to the wire, causing the output buffer offset to fall
  back below the threshold.

  If audio capture is enabled, we increase the size of the threshold to also
  allow for upto 1 seconds worth of audio data samples. ie nchannels * bytes
  per sample * frequency. This allows the output buffer to have a mixture of
  incremental framebuffer updates and audio data queued, but once the threshold
  is exceeded, audio data will be dropped and incremental updates will be
  throttled.

  This unbounded memory growth affects all VNC server configurations supported by
  QEMU, with no workaround possible. The mitigating factor is that it can only be
  triggered by a client that has authenticated with the VNC server, and who is
  able to trigger a large quantity of framebuffer updates or audio samples from
  the guest OS. Mostly they'll just succeed in getting the OOM killer to kill
  their own QEMU process, but its possible other processes can get taken out as
  collateral damage.

  This is a more general variant of the similar unbounded memory usage flaw in
  the websockets server, that was previously assigned CVE-2017-15268, and fixed
  in 2.11 by:

    commit a7b20a8efa28e5f22c26c06cd06c2f12bc863493
    Author: Daniel P. Berrange <berrange@redhat.com>
    Date:   Mon Oct 9 14:43:42 2017 +0100

      io: monitor encoutput buffer size from websocket GSource

  This new general memory usage flaw has been assigned CVE-2017-15124, and is
  partially fixed by this patch.

  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
  Reviewed-by: Darren Kenny <darren.kenny@oracle.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-id: 20171218191228.31018-10-berrange@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  (cherry picked from commit e2b72cb6e0443d90d7ab037858cb6834b6cca852)
  Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  ada8d2e4369ea49677d8672ac81bce73eefd5b54:ui: fix VNC client throttling when forced update is requested

  The VNC server must throttle data sent to the client to prevent the 'output'
  buffer size growing without bound, if the client stops reading data off the
  socket (either maliciously or due to stalled/slow network connection).

  The current throttling is very crude because it simply checks whether the
  output buffer offset is zero. This check is disabled if the client has requested
  a forced update, because we want to send these as soon as possible.

  As a result, the VNC client can cause QEMU to allocate arbitrary amounts of RAM.
  They can first start something in the guest that triggers lots of framebuffer
  updates eg play a youtube video. Then repeatedly send full framebuffer update
  requests, but never read data back from the server. This can easily make QEMU's
  VNC server send buffer consume 100MB of RAM per second, until the OOM killer
  starts reaping processes (hopefully the rogue QEMU process, but it might pick
  others...).

  To address this we make the throttling more intelligent, so we can throttle
  full updates. When we get a forced update request, we keep track of exactly how
  much data we put on the output buffer. We will not process a subsequent forced
  update request until this data has been fully sent on the wire. We always allow
  one forced update request to be in flight, regardless of what data is queued
  for incremental updates or audio data. The slight complication is that we do
  not initially know how much data an update will send, as this is done in the
  background by the VNC job thread. So we must track the fact that the job thread
  has an update pending, and not process any further updates until this job is
  has been completed & put data on the output buffer.

  This unbounded memory growth affects all VNC server configurations supported by
  QEMU, with no workaround possible. The mitigating factor is that it can only be
  triggered by a client that has authenticated with the VNC server, and who is
  able to trigger a large quantity of framebuffer updates or audio samples from
  the guest OS. Mostly they'll just succeed in getting the OOM killer to kill
  their own QEMU process, but its possible other processes can get taken out as
  collateral damage.

  This is a more general variant of the similar unbounded memory usage flaw in
  the websockets server, that was previously assigned CVE-2017-15268, and fixed
  in 2.11 by:

    commit a7b20a8efa28e5f22c26c06cd06c2f12bc863493
    Author: Daniel P. Berrange <berrange@redhat.com>
    Date:   Mon Oct 9 14:43:42 2017 +0100

      io: monitor encoutput buffer size from websocket GSource

  This new general memory usage flaw has been assigned CVE-2017-15124, and is
  partially fixed by this patch.

  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
  Reviewed-by: Darren Kenny <darren.kenny@oracle.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-id: 20171218191228.31018-11-berrange@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  e2b72cb6e0443d90d7ab037858cb6834b6cca852:ui: fix VNC client throttling when audio capture is active

  The VNC server must throttle data sent to the client to prevent the 'output'
  buffer size growing without bound, if the client stops reading data off the
  socket (either maliciously or due to stalled/slow network connection).

  The current throttling is very crude because it simply checks whether the
  output buffer offset is zero. This check must be disabled if audio capture is
  enabled, because when streaming audio the output buffer offset will rarely be
  zero due to queued audio data, and so this would starve framebuffer updates.

  As a result, the VNC client can cause QEMU to allocate arbitrary amounts of RAM.
  They can first start something in the guest that triggers lots of framebuffer
  updates eg play a youtube video. Then enable audio capture, and simply never
  read data back from the server. This can easily make QEMU's VNC server send
  buffer consume 100MB of RAM per second, until the OOM killer starts reaping
  processes (hopefully the rogue QEMU process, but it might pick others...).

  To address this we make the throttling more intelligent, so we can throttle
  when audio capture is active too. To determine how to throttle incremental
  updates or audio data, we calculate a size threshold. Normally the threshold is
  the approximate number of bytes associated with a single complete framebuffer
  update. ie width * height * bytes per pixel. We'll send incremental updates
  until we hit this threshold, at which point we'll stop sending updates until
  data has been written to the wire, causing the output buffer offset to fall
  back below the threshold.

  If audio capture is enabled, we increase the size of the threshold to also
  allow for upto 1 seconds worth of audio data samples. ie nchannels * bytes
  per sample * frequency. This allows the output buffer to have a mixture of
  incremental framebuffer updates and audio data queued, but once the threshold
  is exceeded, audio data will be dropped and incremental updates will be
  throttled.

  This unbounded memory growth affects all VNC server configurations supported by
  QEMU, with no workaround possible. The mitigating factor is that it can only be
  triggered by a client that has authenticated with the VNC server, and who is
  able to trigger a large quantity of framebuffer updates or audio samples from
  the guest OS. Mostly they'll just succeed in getting the OOM killer to kill
  their own QEMU process, but its possible other processes can get taken out as
  collateral damage.

  This is a more general variant of the similar unbounded memory usage flaw in
  the websockets server, that was previously assigned CVE-2017-15268, and fixed
  in 2.11 by:

    commit a7b20a8efa28e5f22c26c06cd06c2f12bc863493
    Author: Daniel P. Berrange <berrange@redhat.com>
    Date:   Mon Oct 9 14:43:42 2017 +0100

      io: monitor encoutput buffer size from websocket GSource

  This new general memory usage flaw has been assigned CVE-2017-15124, and is
  partially fixed by this patch.

  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
  Reviewed-by: Darren Kenny <darren.kenny@oracle.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-id: 20171218191228.31018-10-berrange@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  e0809fcc4b03b51435eabc8ad84ecd61acd83d31:io: monitor encoutput buffer size from websocket GSource

  The websocket GSource is monitoring the size of the rawoutput
  buffer to determine if the channel can accepts more writes.
  The rawoutput buffer, however, is merely a temporary staging
  buffer before data is copied into the encoutput buffer. Thus
  its size will always be zero when the GSource runs.

  This flaw causes the encoutput buffer to grow without bound
  if the other end of the underlying data channel doesn't
  read data being sent. This can be seen with VNC if a client
  is on a slow WAN link and the guest OS is sending many screen
  updates. A malicious VNC client can act like it is on a slow
  link by playing a video in the guest and then reading data
  very slowly, causing QEMU host memory to expand arbitrarily.

  This issue is assigned CVE-2017-15268, publically reported in

    https://bugs.launchpad.net/qemu/+bug/1718964

  (cherry picked from commit a7b20a8efa28e5f22c26c06cd06c2f12bc863493)

  Reviewed-by: Eric Blake <eblake@redhat.com>

  [Dan: Added extra checks to deal with code refactored in master but
   not stable 2.10]

  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
  Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  a7b20a8efa28e5f22c26c06cd06c2f12bc863493:io: monitor encoutput buffer size from websocket GSource

  The websocket GSource is monitoring the size of the rawoutput
  buffer to determine if the channel can accepts more writes.
  The rawoutput buffer, however, is merely a temporary staging
  buffer before data is copied into the encoutput buffer. Thus
  its size will always be zero when the GSource runs.

  This flaw causes the encoutput buffer to grow without bound
  if the other end of the underlying data channel doesn't
  read data being sent. This can be seen with VNC if a client
  is on a slow WAN link and the guest OS is sending many screen
  updates. A malicious VNC client can act like it is on a slow
  link by playing a video in the guest and then reading data
  very slowly, causing QEMU host memory to expand arbitrarily.

  This issue is assigned CVE-2017-15268, publically reported in

    https://bugs.launchpad.net/qemu/+bug/1718964

  Reviewed-by: Eric Blake <eblake@redhat.com>
  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
impacted_packages:
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: a7b20a8efa28e5f22c26c06cd06c2f12bc863493
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: e0809fcc4b03b51435eabc8ad84ecd61acd83d31
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: e2b72cb6e0443d90d7ab037858cb6834b6cca852
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: ada8d2e4369ea49677d8672ac81bce73eefd5b54
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: f9c8767828aa44441681ea683f53cef8135050cd
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: f9e53c77ea3bfe92ddc8c755935e7521dd3ed08e
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://gitlab.com/qemu-project/qemu
    reference_type: commit
    reference_id: 91c6438caffc880e999a7312825479685d659b44
