advisory_id: CVE-2017-15124
datasource_id: collect_qemu_fix_commits/CVE-2017-15124
datasource_url: https://gitlab.com/qemu-project/qemu
aliases: []
summary: |
  0c85a40e710d4b71656b28f1f5e1ae5e3780d369:ui: place a hard cap on VNC server output buffer size

  The previous patches fix problems with throttling of forced framebuffer updates
  and audio data capture that would cause the QEMU output buffer size to grow
  without bound. Those fixes are graceful in that once the client catches up with
  reading data from the server, everything continues operating normally.

  There is some data which the server sends to the client that is impractical to
  throttle. Specifically there are various pseudo framebuffer update encodings to
  inform the client of things like desktop resizes, pointer changes, audio
  playback start/stop, LED state and so on. These generally only involve sending
  a very small amount of data to the client, but a malicious guest might be able
  to do things that trigger these changes at a very high rate. Throttling them is
  not practical as missed or delayed events would cause broken behaviour for the
  client.

  This patch thus takes a more forceful approach of setting an absolute upper
  bound on the amount of data we permit to be present in the output buffer at
  any time. The previous patch set a threshold for throttling the output buffer
  by allowing an amount of data equivalent to one complete framebuffer update and
  one seconds worth of audio data. On top of this it allowed for one further
  forced framebuffer update to be queued.

  To be conservative, we thus take that throttling threshold and multiply it by
  5 to form an absolute upper bound. If this bound is hit during vnc_write() we
  forceably disconnect the client, refusing to queue further data. This limit is
  high enough that it should never be hit unless a malicious client is trying to
  exploit the sever, or the network is completely saturated preventing any sending
  of data on the socket.

  This completes the fix for CVE-2017-15124 started in the previous patches.

  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
  Reviewed-by: Darren Kenny <darren.kenny@oracle.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-id: 20171218191228.31018-12-berrange@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  (cherry picked from commit f887cf165db20f405cb8805c716bd363aaadf815)
  Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  f9e53c77ea3bfe92ddc8c755935e7521dd3ed08e:ui: fix VNC client throttling when forced update is requested

  The VNC server must throttle data sent to the client to prevent the 'output'
  buffer size growing without bound, if the client stops reading data off the
  socket (either maliciously or due to stalled/slow network connection).

  The current throttling is very crude because it simply checks whether the
  output buffer offset is zero. This check is disabled if the client has requested
  a forced update, because we want to send these as soon as possible.

  As a result, the VNC client can cause QEMU to allocate arbitrary amounts of RAM.
  They can first start something in the guest that triggers lots of framebuffer
  updates eg play a youtube video. Then repeatedly send full framebuffer update
  requests, but never read data back from the server. This can easily make QEMU's
  VNC server send buffer consume 100MB of RAM per second, until the OOM killer
  starts reaping processes (hopefully the rogue QEMU process, but it might pick
  others...).

  To address this we make the throttling more intelligent, so we can throttle
  full updates. When we get a forced update request, we keep track of exactly how
  much data we put on the output buffer. We will not process a subsequent forced
  update request until this data has been fully sent on the wire. We always allow
  one forced update request to be in flight, regardless of what data is queued
  for incremental updates or audio data. The slight complication is that we do
  not initially know how much data an update will send, as this is done in the
  background by the VNC job thread. So we must track the fact that the job thread
  has an update pending, and not process any further updates until this job is
  has been completed & put data on the output buffer.

  This unbounded memory growth affects all VNC server configurations supported by
  QEMU, with no workaround possible. The mitigating factor is that it can only be
  triggered by a client that has authenticated with the VNC server, and who is
  able to trigger a large quantity of framebuffer updates or audio samples from
  the guest OS. Mostly they'll just succeed in getting the OOM killer to kill
  their own QEMU process, but its possible other processes can get taken out as
  collateral damage.

  This is a more general variant of the similar unbounded memory usage flaw in
  the websockets server, that was previously assigned CVE-2017-15268, and fixed
  in 2.11 by:

    commit a7b20a8efa28e5f22c26c06cd06c2f12bc863493
    Author: Daniel P. Berrange <berrange@redhat.com>
    Date:   Mon Oct 9 14:43:42 2017 +0100

      io: monitor encoutput buffer size from websocket GSource

  This new general memory usage flaw has been assigned CVE-2017-15124, and is
  partially fixed by this patch.

  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
  Reviewed-by: Darren Kenny <darren.kenny@oracle.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-id: 20171218191228.31018-11-berrange@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  (cherry picked from commit ada8d2e4369ea49677d8672ac81bce73eefd5b54)
  Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  f9c8767828aa44441681ea683f53cef8135050cd:ui: fix VNC client throttling when audio capture is active

  The VNC server must throttle data sent to the client to prevent the 'output'
  buffer size growing without bound, if the client stops reading data off the
  socket (either maliciously or due to stalled/slow network connection).

  The current throttling is very crude because it simply checks whether the
  output buffer offset is zero. This check must be disabled if audio capture is
  enabled, because when streaming audio the output buffer offset will rarely be
  zero due to queued audio data, and so this would starve framebuffer updates.

  As a result, the VNC client can cause QEMU to allocate arbitrary amounts of RAM.
  They can first start something in the guest that triggers lots of framebuffer
  updates eg play a youtube video. Then enable audio capture, and simply never
  read data back from the server. This can easily make QEMU's VNC server send
  buffer consume 100MB of RAM per second, until the OOM killer starts reaping
  processes (hopefully the rogue QEMU process, but it might pick others...).

  To address this we make the throttling more intelligent, so we can throttle
  when audio capture is active too. To determine how to throttle incremental
  updates or audio data, we calculate a size threshold. Normally the threshold is
  the approximate number of bytes associated with a single complete framebuffer
  update. ie width * height * bytes per pixel. We'll send incremental updates
  until we hit this threshold, at which point we'll stop sending updates until
  data has been written to the wire, causing the output buffer offset to fall
  back below the threshold.

  If audio capture is enabled, we increase the size of the threshold to also
  allow for upto 1 seconds worth of audio data samples. ie nchannels * bytes
  per sample * frequency. This allows the output buffer to have a mixture of
  incremental framebuffer updates and audio data queued, but once the threshold
  is exceeded, audio data will be dropped and incremental updates will be
  throttled.

  This unbounded memory growth affects all VNC server configurations supported by
  QEMU, with no workaround possible. The mitigating factor is that it can only be
  triggered by a client that has authenticated with the VNC server, and who is
  able to trigger a large quantity of framebuffer updates or audio samples from
  the guest OS. Mostly they'll just succeed in getting the OOM killer to kill
  their own QEMU process, but its possible other processes can get taken out as
  collateral damage.

  This is a more general variant of the similar unbounded memory usage flaw in
  the websockets server, that was previously assigned CVE-2017-15268, and fixed
  in 2.11 by:

    commit a7b20a8efa28e5f22c26c06cd06c2f12bc863493
    Author: Daniel P. Berrange <berrange@redhat.com>
    Date:   Mon Oct 9 14:43:42 2017 +0100

      io: monitor encoutput buffer size from websocket GSource

  This new general memory usage flaw has been assigned CVE-2017-15124, and is
  partially fixed by this patch.

  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
  Reviewed-by: Darren Kenny <darren.kenny@oracle.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-id: 20171218191228.31018-10-berrange@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  (cherry picked from commit e2b72cb6e0443d90d7ab037858cb6834b6cca852)
  Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  7398166ddf7c6dbbc9cae6ac69bb2feda14b40ac:Merge remote-tracking branch 'remotes/kraxel/tags/vnc-20180112-pull-request' into staging

  vnc: limit memory usage (CVE-2017-15124)

  # gpg: Signature made Fri 12 Jan 2018 12:57:22 GMT
  # gpg:                using RSA key 0x4CB6D8EED3E87138
  # gpg: Good signature from "Gerd Hoffmann (work) <kraxel@redhat.com>"
  # gpg:                 aka "Gerd Hoffmann <gerd@kraxel.org>"
  # gpg:                 aka "Gerd Hoffmann (private) <kraxel@gmail.com>"
  # Primary key fingerprint: A032 8CFF B93A 17A7 9901  FE7D 4CB6 D8EE D3E8 7138

  * remotes/kraxel/tags/vnc-20180112-pull-request:
    ui: mix misleading comments & return types of VNC I/O helper methods
    ui: add trace events related to VNC client throttling
    ui: place a hard cap on VNC server output buffer size
    ui: fix VNC client throttling when forced update is requested
    ui: fix VNC client throttling when audio capture is active
    ui: refactor code for determining if an update should be sent to the client
    ui: correctly reset framebuffer update state after processing dirty regions
    ui: introduce enum to track VNC client framebuffer update request state
    ui: track how much decoded data we consumed when doing SASL encoding
    ui: avoid pointless VNC updates if framebuffer isn't dirty
    ui: remove redundant indentation in vnc_client_update
    ui: remove unreachable code in vnc_update_client
    ui: remove 'sync' parameter from vnc_update_client
    vnc: fix debug spelling

  Signed-off-by: Peter Maydell <peter.maydell@linaro.org>
  f887cf165db20f405cb8805c716bd363aaadf815:ui: place a hard cap on VNC server output buffer size

  The previous patches fix problems with throttling of forced framebuffer updates
  and audio data capture that would cause the QEMU output buffer size to grow
  without bound. Those fixes are graceful in that once the client catches up with
  reading data from the server, everything continues operating normally.

  There is some data which the server sends to the client that is impractical to
  throttle. Specifically there are various pseudo framebuffer update encodings to
  inform the client of things like desktop resizes, pointer changes, audio
  playback start/stop, LED state and so on. These generally only involve sending
  a very small amount of data to the client, but a malicious guest might be able
  to do things that trigger these changes at a very high rate. Throttling them is
  not practical as missed or delayed events would cause broken behaviour for the
  client.

  This patch thus takes a more forceful approach of setting an absolute upper
  bound on the amount of data we permit to be present in the output buffer at
  any time. The previous patch set a threshold for throttling the output buffer
  by allowing an amount of data equivalent to one complete framebuffer update and
  one seconds worth of audio data. On top of this it allowed for one further
  forced framebuffer update to be queued.

  To be conservative, we thus take that throttling threshold and multiply it by
  5 to form an absolute upper bound. If this bound is hit during vnc_write() we
  forceably disconnect the client, refusing to queue further data. This limit is
  high enough that it should never be hit unless a malicious client is trying to
  exploit the sever, or the network is completely saturated preventing any sending
  of data on the socket.

  This completes the fix for CVE-2017-15124 started in the previous patches.

  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
  Reviewed-by: Darren Kenny <darren.kenny@oracle.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-id: 20171218191228.31018-12-berrange@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  ada8d2e4369ea49677d8672ac81bce73eefd5b54:ui: fix VNC client throttling when forced update is requested

  The VNC server must throttle data sent to the client to prevent the 'output'
  buffer size growing without bound, if the client stops reading data off the
  socket (either maliciously or due to stalled/slow network connection).

  The current throttling is very crude because it simply checks whether the
  output buffer offset is zero. This check is disabled if the client has requested
  a forced update, because we want to send these as soon as possible.

  As a result, the VNC client can cause QEMU to allocate arbitrary amounts of RAM.
  They can first start something in the guest that triggers lots of framebuffer
  updates eg play a youtube video. Then repeatedly send full framebuffer update
  requests, but never read data back from the server. This can easily make QEMU's
  VNC server send buffer consume 100MB of RAM per second, until the OOM killer
  starts reaping processes (hopefully the rogue QEMU process, but it might pick
  others...).

  To address this we make the throttling more intelligent, so we can throttle
  full updates. When we get a forced update request, we keep track of exactly how
  much data we put on the output buffer. We will not process a subsequent forced
  update request until this data has been fully sent on the wire. We always allow
  one forced update request to be in flight, regardless of what data is queued
  for incremental updates or audio data. The slight complication is that we do
  not initially know how much data an update will send, as this is done in the
  background by the VNC job thread. So we must track the fact that the job thread
  has an update pending, and not process any further updates until this job is
  has been completed & put data on the output buffer.

  This unbounded memory growth affects all VNC server configurations supported by
  QEMU, with no workaround possible. The mitigating factor is that it can only be
  triggered by a client that has authenticated with the VNC server, and who is
  able to trigger a large quantity of framebuffer updates or audio samples from
  the guest OS. Mostly they'll just succeed in getting the OOM killer to kill
  their own QEMU process, but its possible other processes can get taken out as
  collateral damage.

  This is a more general variant of the similar unbounded memory usage flaw in
  the websockets server, that was previously assigned CVE-2017-15268, and fixed
  in 2.11 by:

    commit a7b20a8efa28e5f22c26c06cd06c2f12bc863493
    Author: Daniel P. Berrange <berrange@redhat.com>
    Date:   Mon Oct 9 14:43:42 2017 +0100

      io: monitor encoutput buffer size from websocket GSource

  This new general memory usage flaw has been assigned CVE-2017-15124, and is
  partially fixed by this patch.

  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
  Reviewed-by: Darren Kenny <darren.kenny@oracle.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-id: 20171218191228.31018-11-berrange@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
  e2b72cb6e0443d90d7ab037858cb6834b6cca852:ui: fix VNC client throttling when audio capture is active

  The VNC server must throttle data sent to the client to prevent the 'output'
  buffer size growing without bound, if the client stops reading data off the
  socket (either maliciously or due to stalled/slow network connection).

  The current throttling is very crude because it simply checks whether the
  output buffer offset is zero. This check must be disabled if audio capture is
  enabled, because when streaming audio the output buffer offset will rarely be
  zero due to queued audio data, and so this would starve framebuffer updates.

  As a result, the VNC client can cause QEMU to allocate arbitrary amounts of RAM.
  They can first start something in the guest that triggers lots of framebuffer
  updates eg play a youtube video. Then enable audio capture, and simply never
  read data back from the server. This can easily make QEMU's VNC server send
  buffer consume 100MB of RAM per second, until the OOM killer starts reaping
  processes (hopefully the rogue QEMU process, but it might pick others...).

  To address this we make the throttling more intelligent, so we can throttle
  when audio capture is active too. To determine how to throttle incremental
  updates or audio data, we calculate a size threshold. Normally the threshold is
  the approximate number of bytes associated with a single complete framebuffer
  update. ie width * height * bytes per pixel. We'll send incremental updates
  until we hit this threshold, at which point we'll stop sending updates until
  data has been written to the wire, causing the output buffer offset to fall
  back below the threshold.

  If audio capture is enabled, we increase the size of the threshold to also
  allow for upto 1 seconds worth of audio data samples. ie nchannels * bytes
  per sample * frequency. This allows the output buffer to have a mixture of
  incremental framebuffer updates and audio data queued, but once the threshold
  is exceeded, audio data will be dropped and incremental updates will be
  throttled.

  This unbounded memory growth affects all VNC server configurations supported by
  QEMU, with no workaround possible. The mitigating factor is that it can only be
  triggered by a client that has authenticated with the VNC server, and who is
  able to trigger a large quantity of framebuffer updates or audio samples from
  the guest OS. Mostly they'll just succeed in getting the OOM killer to kill
  their own QEMU process, but its possible other processes can get taken out as
  collateral damage.

  This is a more general variant of the similar unbounded memory usage flaw in
  the websockets server, that was previously assigned CVE-2017-15268, and fixed
  in 2.11 by:

    commit a7b20a8efa28e5f22c26c06cd06c2f12bc863493
    Author: Daniel P. Berrange <berrange@redhat.com>
    Date:   Mon Oct 9 14:43:42 2017 +0100

      io: monitor encoutput buffer size from websocket GSource

  This new general memory usage flaw has been assigned CVE-2017-15124, and is
  partially fixed by this patch.

  Signed-off-by: Daniel P. Berrange <berrange@redhat.com>
  Reviewed-by: Darren Kenny <darren.kenny@oracle.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-id: 20171218191228.31018-10-berrange@redhat.com
  Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
impacted_packages:
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: e2b72cb6e0443d90d7ab037858cb6834b6cca852
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: f887cf165db20f405cb8805c716bd363aaadf815
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: ada8d2e4369ea49677d8672ac81bce73eefd5b54
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: f9c8767828aa44441681ea683f53cef8135050cd
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: f9e53c77ea3bfe92ddc8c755935e7521dd3ed08e
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 7398166ddf7c6dbbc9cae6ac69bb2feda14b40ac
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 0c85a40e710d4b71656b28f1f5e1ae5e3780d369
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://gitlab.com/qemu-project/qemu
    reference_type: commit
    reference_id: 91c6438caffc880e999a7312825479685d659b44
