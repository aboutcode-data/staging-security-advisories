advisory_id: CVE-2013-4149
datasource_id: collect_qemu_fix_commits/CVE-2013-4149
datasource_url: https://gitlab.com/qemu-project/qemu
aliases: []
summary: |
  331c549b2d78f7792ded44abe9ad30a7e9531cba:virtio-net: out-of-bounds buffer write on load

  CVE-2013-4149 QEMU 1.3.0 out-of-bounds buffer write in
  virtio_net_load()@hw/net/virtio-net.c

  >         } else if (n->mac_table.in_use) {
  >             uint8_t *buf = g_malloc0(n->mac_table.in_use);

  We are allocating buffer of size n->mac_table.in_use

  >             qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);

  and read to the n->mac_table.in_use size buffer n->mac_table.in_use *
  ETH_ALEN bytes, corrupting memory.

  If adversary controls state then memory written there is controlled
  by adversary.

  Reviewed-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
  Signed-off-by: Juan Quintela <quintela@redhat.com>
  (cherry picked from commit 98f93ddd84800f207889491e0b5d851386b459cf)
  Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  7b6444a2e4f5e777d05142277c842a3f3465beb3:virtio-net: out-of-bounds buffer write on load

  CVE-2013-4149 QEMU 1.3.0 out-of-bounds buffer write in
  virtio_net_load()@hw/net/virtio-net.c

  >         } else if (n->mac_table.in_use) {
  >             uint8_t *buf = g_malloc0(n->mac_table.in_use);

  We are allocating buffer of size n->mac_table.in_use

  >             qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);

  and read to the n->mac_table.in_use size buffer n->mac_table.in_use *
  ETH_ALEN bytes, corrupting memory.

  If adversary controls state then memory written there is controlled
  by adversary.

  Reviewed-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
  Signed-off-by: Juan Quintela <quintela@redhat.com>
  (cherry picked from commit 98f93ddd84800f207889491e0b5d851386b459cf)
  Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  98f93ddd84800f207889491e0b5d851386b459cf:virtio-net: out-of-bounds buffer write on load

  CVE-2013-4149 QEMU 1.3.0 out-of-bounds buffer write in
  virtio_net_load()@hw/net/virtio-net.c

  >         } else if (n->mac_table.in_use) {
  >             uint8_t *buf = g_malloc0(n->mac_table.in_use);

  We are allocating buffer of size n->mac_table.in_use

  >             qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);

  and read to the n->mac_table.in_use size buffer n->mac_table.in_use *
  ETH_ALEN bytes, corrupting memory.

  If adversary controls state then memory written there is controlled
  by adversary.

  Reviewed-by: Michael Roth <mdroth@linux.vnet.ibm.com>
  Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
  Signed-off-by: Juan Quintela <quintela@redhat.com>
impacted_packages:
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 331c549b2d78f7792ded44abe9ad30a7e9531cba
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 98f93ddd84800f207889491e0b5d851386b459cf
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 7b6444a2e4f5e777d05142277c842a3f3465beb3
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://gitlab.com/qemu-project/qemu
    reference_type: commit
    reference_id: 91c6438caffc880e999a7312825479685d659b44
