advisory_id: CVE-2024-7409
datasource_id: collect_qemu_fix_commits/CVE-2024-7409
datasource_url: https://gitlab.com/qemu-project/qemu
aliases: []
summary: |
  3066a540b52fc3e1e223c9e2b344b047500bc37e:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  (cherry picked from commit 3874f5f73c441c52f1c699c848d463b0eda01e4c)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  3066a540b52fc3e1e223c9e2b344b047500bc37e:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  (cherry picked from commit 3874f5f73c441c52f1c699c848d463b0eda01e4c)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  3066a540b52fc3e1e223c9e2b344b047500bc37e:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  (cherry picked from commit 3874f5f73c441c52f1c699c848d463b0eda01e4c)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  73a5a92259962ea7a1bea7c3105438712e88851c:nbd/server: CVE-2024-7409: Close stray clients at server-stop

  A malicious client can attempt to connect to an NBD server, and then
  intentionally delay progress in the handshake, including if it does
  not know the TLS secrets.  Although the previous two patches reduce
  this behavior by capping the default max-connections parameter and
  killing slow clients, they did not eliminate the possibility of a
  client waiting to close the socket until after the QMP nbd-server-stop
  command is executed, at which point qemu would SEGV when trying to
  dereference the NULL nbd_server global which is no longer present.
  This amounts to a denial of service attack.  Worse, if another NBD
  server is started before the malicious client disconnects, I cannot
  rule out additional adverse effects when the old client interferes
  with the connection count of the new server (although the most likely
  is a crash due to an assertion failure when checking
  nbd_server->connections > 0).

  For environments without this patch, the CVE can be mitigated by
  ensuring (such as via a firewall) that only trusted clients can
  connect to an NBD server.  Note that using frameworks like libvirt
  that ensure that TLS is used and that nbd-server-stop is not executed
  while any trusted clients are still connected will only help if there
  is also no possibility for an untrusted client to open a connection
  but then stall on the NBD handshake.

  Given the previous patches, it would be possible to guarantee that no
  clients remain connected by having nbd-server-stop sleep for longer
  than the default handshake deadline before finally freeing the global
  nbd_server object, but that could make QMP non-responsive for a long
  time.  So intead, this patch fixes the problem by tracking all client
  sockets opened while the server is running, and forcefully closing any
  such sockets remaining without a completed handshake at the time of
  nbd-server-stop, then waiting until the coroutines servicing those
  sockets notice the state change.  nbd-server-stop now has a second
  AIO_WAIT_WHILE_UNLOCKED (the first is indirectly through the
  blk_exp_close_all_type() that disconnects all clients that completed
  handshakes), but forced socket shutdown is enough to progress the
  coroutines and quickly tear down all clients before the server is
  freed, thus finally fixing the CVE.

  This patch relies heavily on the fact that nbd/server.c guarantees
  that it only calls nbd_blockdev_client_closed() from the main loop
  (see the assertion in nbd_client_put() and the hoops used in
  nbd_client_put_nonzero() to achieve that); if we did not have that
  guarantee, we would also need a mutex protecting our accesses of the
  list of connections to survive re-entrancy from independent iothreads.

  Although I did not actually try to test old builds, it looks like this
  problem has existed since at least commit 862172f45c (v2.12.0, 2017) -
  even back when that patch started using a QIONetListener to handle
  listening on multiple sockets, nbd_server_free() was already unaware
  that the nbd_blockdev_client_closed callback can be reached later by a
  client thread that has not completed handshakes (and therefore the
  client's socket never got added to the list closed in
  nbd_export_close_all), despite that patch intentionally tearing down
  the QIONetListener to prevent new clients.

  Reported-by: Alexander Ivanov <alexander.ivanov@virtuozzo.com>
  Fixes: CVE-2024-7409
  CC: qemu-stable@nongnu.org
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-14-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  (cherry picked from commit 3e7ef738c8462c45043a1d39f702a0990406a3b3)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  73a5a92259962ea7a1bea7c3105438712e88851c:nbd/server: CVE-2024-7409: Close stray clients at server-stop

  A malicious client can attempt to connect to an NBD server, and then
  intentionally delay progress in the handshake, including if it does
  not know the TLS secrets.  Although the previous two patches reduce
  this behavior by capping the default max-connections parameter and
  killing slow clients, they did not eliminate the possibility of a
  client waiting to close the socket until after the QMP nbd-server-stop
  command is executed, at which point qemu would SEGV when trying to
  dereference the NULL nbd_server global which is no longer present.
  This amounts to a denial of service attack.  Worse, if another NBD
  server is started before the malicious client disconnects, I cannot
  rule out additional adverse effects when the old client interferes
  with the connection count of the new server (although the most likely
  is a crash due to an assertion failure when checking
  nbd_server->connections > 0).

  For environments without this patch, the CVE can be mitigated by
  ensuring (such as via a firewall) that only trusted clients can
  connect to an NBD server.  Note that using frameworks like libvirt
  that ensure that TLS is used and that nbd-server-stop is not executed
  while any trusted clients are still connected will only help if there
  is also no possibility for an untrusted client to open a connection
  but then stall on the NBD handshake.

  Given the previous patches, it would be possible to guarantee that no
  clients remain connected by having nbd-server-stop sleep for longer
  than the default handshake deadline before finally freeing the global
  nbd_server object, but that could make QMP non-responsive for a long
  time.  So intead, this patch fixes the problem by tracking all client
  sockets opened while the server is running, and forcefully closing any
  such sockets remaining without a completed handshake at the time of
  nbd-server-stop, then waiting until the coroutines servicing those
  sockets notice the state change.  nbd-server-stop now has a second
  AIO_WAIT_WHILE_UNLOCKED (the first is indirectly through the
  blk_exp_close_all_type() that disconnects all clients that completed
  handshakes), but forced socket shutdown is enough to progress the
  coroutines and quickly tear down all clients before the server is
  freed, thus finally fixing the CVE.

  This patch relies heavily on the fact that nbd/server.c guarantees
  that it only calls nbd_blockdev_client_closed() from the main loop
  (see the assertion in nbd_client_put() and the hoops used in
  nbd_client_put_nonzero() to achieve that); if we did not have that
  guarantee, we would also need a mutex protecting our accesses of the
  list of connections to survive re-entrancy from independent iothreads.

  Although I did not actually try to test old builds, it looks like this
  problem has existed since at least commit 862172f45c (v2.12.0, 2017) -
  even back when that patch started using a QIONetListener to handle
  listening on multiple sockets, nbd_server_free() was already unaware
  that the nbd_blockdev_client_closed callback can be reached later by a
  client thread that has not completed handshakes (and therefore the
  client's socket never got added to the list closed in
  nbd_export_close_all), despite that patch intentionally tearing down
  the QIONetListener to prevent new clients.

  Reported-by: Alexander Ivanov <alexander.ivanov@virtuozzo.com>
  Fixes: CVE-2024-7409
  CC: qemu-stable@nongnu.org
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-14-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  (cherry picked from commit 3e7ef738c8462c45043a1d39f702a0990406a3b3)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  f4c1adb228e5d60e6e372c3efd6442c3a69aeb81:nbd/server: CVE-2024-7409: Drop non-negotiating clients

  A client that opens a socket but does not negotiate is merely hogging
  qemu's resources (an open fd and a small amount of memory); and a
  malicious client that can access the port where NBD is listening can
  attempt a denial of service attack by intentionally opening and
  abandoning lots of unfinished connections.  The previous patch put a
  default bound on the number of such ongoing connections, but once that
  limit is hit, no more clients can connect (including legitimate ones).
  The solution is to insist that clients complete handshake within a
  reasonable time limit, defaulting to 10 seconds.  A client that has
  not successfully completed NBD_OPT_GO by then (including the case of
  where the client didn't know TLS credentials to even reach the point
  of NBD_OPT_GO) is wasting our time and does not deserve to stay
  connected.  Later patches will allow fine-tuning the limit away from
  the default value (including disabling it for doing integration
  testing of the handshake process itself).

  Note that this patch in isolation actually makes it more likely to see
  qemu SEGV after nbd-server-stop, as any client socket still connected
  when the server shuts down will now be closed after 10 seconds rather
  than at the client's whims.  That will be addressed in the next patch.

  For a demo of this patch in action:
  $ qemu-nbd -f raw -r -t -e 10 file &
  $ nbdsh --opt-mode -c '
  H = list()
  for i in range(20):
    print(i)
    H.insert(i, nbd.NBD())
    H[i].set_opt_mode(True)
    H[i].connect_uri("nbd://localhost")
  '
  $ kill $!

  where later connections get to start progressing once earlier ones are
  forcefully dropped for taking too long, rather than hanging.

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-13-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [eblake: rebase to changes earlier in series, reduce scope of timer]
  Signed-off-by: Eric Blake <eblake@redhat.com>
  (cherry picked from commit b9b72cb3ce15b693148bd09cef7e50110566d8a0)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  9bdb40b2d474950d9f08b106c0968474bd5f0c30:nbd/server: CVE-2024-7409: Cap default max-connections to 100

  Allowing an unlimited number of clients to any web service is a recipe
  for a rudimentary denial of service attack: the client merely needs to
  open lots of sockets without closing them, until qemu no longer has
  any more fds available to allocate.

  For qemu-nbd, we default to allowing only 1 connection unless more are
  explicitly asked for (-e or --shared); this was historically picked as
  a nice default (without an explicit -t, a non-persistent qemu-nbd goes
  away after a client disconnects, without needing any additional
  follow-up commands), and we are not going to change that interface now
  (besides, someday we want to point people towards qemu-storage-daemon
  instead of qemu-nbd).

  But for qemu proper, and the newer qemu-storage-daemon, the QMP
  nbd-server-start command has historically had a default of unlimited
  number of connections, in part because unlike qemu-nbd it is
  inherently persistent until nbd-server-stop.  Allowing multiple client
  sockets is particularly useful for clients that can take advantage of
  MULTI_CONN (creating parallel sockets to increase throughput),
  although known clients that do so (such as libnbd's nbdcopy) typically
  use only 8 or 16 connections (the benefits of scaling diminish once
  more sockets are competing for kernel attention).  Picking a number
  large enough for typical use cases, but not unlimited, makes it
  slightly harder for a malicious client to perform a denial of service
  merely by opening lots of connections withot progressing through the
  handshake.

  This change does not eliminate CVE-2024-7409 on its own, but reduces
  the chance for fd exhaustion or unlimited memory usage as an attack
  surface.  On the other hand, by itself, it makes it more obvious that
  with a finite limit, we have the problem of an unauthenticated client
  holding 100 fds opened as a way to block out a legitimate client from
  being able to connect; thus, later patches will further add timeouts
  to reject clients that are not making progress.

  This is an INTENTIONAL change in behavior, and will break any client
  of nbd-server-start that was not passing an explicit max-connections
  parameter, yet expects more than 100 simultaneous connections.  We are
  not aware of any such client (as stated above, most clients aware of
  MULTI_CONN get by just fine on 8 or 16 connections, and probably cope
  with later connections failing by relying on the earlier connections;
  libvirt has not yet been passing max-connections, but generally
  creates NBD servers with the intent for a single client for the sake
  of live storage migration; meanwhile, the KubeSAN project anticipates
  a large cluster sharing multiple clients [up to 8 per node, and up to
  100 nodes in a cluster], but it currently uses qemu-nbd with an
  explicit --shared=0 rather than qemu-storage-daemon with
  nbd-server-start).

  We considered using a deprecation period (declare that omitting
  max-parameters is deprecated, and make it mandatory in 3 releases -
  then we don't need to pick an arbitrary default); that has zero risk
  of breaking any apps that accidentally depended on more than 100
  connections, and where such breakage might not be noticed under unit
  testing but only under the larger loads of production usage.  But it
  does not close the denial-of-service hole until far into the future,
  and requires all apps to change to add the parameter even if 100 was
  good enough.  It also has a drawback that any app (like libvirt) that
  is accidentally relying on an unlimited default should seriously
  consider their own CVE now, at which point they are going to change to
  pass explicit max-connections sooner than waiting for 3 qemu releases.
  Finally, if our changed default breaks an app, that app can always
  pass in an explicit max-parameters with a larger value.

  It is also intentional that the HMP interface to nbd-server-start is
  not changed to expose max-connections (any client needing to fine-tune
  things should be using QMP).

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-12-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [ericb: Expand commit message to summarize Dan's argument for why we
  break corner-case back-compat behavior without a deprecation period]
  Signed-off-by: Eric Blake <eblake@redhat.com>
  (cherry picked from commit c8a76dbd90c2f48df89b75bef74917f90a59b623)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  9bdb40b2d474950d9f08b106c0968474bd5f0c30:nbd/server: CVE-2024-7409: Cap default max-connections to 100

  Allowing an unlimited number of clients to any web service is a recipe
  for a rudimentary denial of service attack: the client merely needs to
  open lots of sockets without closing them, until qemu no longer has
  any more fds available to allocate.

  For qemu-nbd, we default to allowing only 1 connection unless more are
  explicitly asked for (-e or --shared); this was historically picked as
  a nice default (without an explicit -t, a non-persistent qemu-nbd goes
  away after a client disconnects, without needing any additional
  follow-up commands), and we are not going to change that interface now
  (besides, someday we want to point people towards qemu-storage-daemon
  instead of qemu-nbd).

  But for qemu proper, and the newer qemu-storage-daemon, the QMP
  nbd-server-start command has historically had a default of unlimited
  number of connections, in part because unlike qemu-nbd it is
  inherently persistent until nbd-server-stop.  Allowing multiple client
  sockets is particularly useful for clients that can take advantage of
  MULTI_CONN (creating parallel sockets to increase throughput),
  although known clients that do so (such as libnbd's nbdcopy) typically
  use only 8 or 16 connections (the benefits of scaling diminish once
  more sockets are competing for kernel attention).  Picking a number
  large enough for typical use cases, but not unlimited, makes it
  slightly harder for a malicious client to perform a denial of service
  merely by opening lots of connections withot progressing through the
  handshake.

  This change does not eliminate CVE-2024-7409 on its own, but reduces
  the chance for fd exhaustion or unlimited memory usage as an attack
  surface.  On the other hand, by itself, it makes it more obvious that
  with a finite limit, we have the problem of an unauthenticated client
  holding 100 fds opened as a way to block out a legitimate client from
  being able to connect; thus, later patches will further add timeouts
  to reject clients that are not making progress.

  This is an INTENTIONAL change in behavior, and will break any client
  of nbd-server-start that was not passing an explicit max-connections
  parameter, yet expects more than 100 simultaneous connections.  We are
  not aware of any such client (as stated above, most clients aware of
  MULTI_CONN get by just fine on 8 or 16 connections, and probably cope
  with later connections failing by relying on the earlier connections;
  libvirt has not yet been passing max-connections, but generally
  creates NBD servers with the intent for a single client for the sake
  of live storage migration; meanwhile, the KubeSAN project anticipates
  a large cluster sharing multiple clients [up to 8 per node, and up to
  100 nodes in a cluster], but it currently uses qemu-nbd with an
  explicit --shared=0 rather than qemu-storage-daemon with
  nbd-server-start).

  We considered using a deprecation period (declare that omitting
  max-parameters is deprecated, and make it mandatory in 3 releases -
  then we don't need to pick an arbitrary default); that has zero risk
  of breaking any apps that accidentally depended on more than 100
  connections, and where such breakage might not be noticed under unit
  testing but only under the larger loads of production usage.  But it
  does not close the denial-of-service hole until far into the future,
  and requires all apps to change to add the parameter even if 100 was
  good enough.  It also has a drawback that any app (like libvirt) that
  is accidentally relying on an unlimited default should seriously
  consider their own CVE now, at which point they are going to change to
  pass explicit max-connections sooner than waiting for 3 qemu releases.
  Finally, if our changed default breaks an app, that app can always
  pass in an explicit max-parameters with a larger value.

  It is also intentional that the HMP interface to nbd-server-start is
  not changed to expose max-connections (any client needing to fine-tune
  things should be using QMP).

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-12-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [ericb: Expand commit message to summarize Dan's argument for why we
  break corner-case back-compat behavior without a deprecation period]
  Signed-off-by: Eric Blake <eblake@redhat.com>
  (cherry picked from commit c8a76dbd90c2f48df89b75bef74917f90a59b623)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  0fe466df932d23fd8881bba1ab2c1798c09884c1:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  (cherry picked from commit 3874f5f73c441c52f1c699c848d463b0eda01e4c)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  0fe466df932d23fd8881bba1ab2c1798c09884c1:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  (cherry picked from commit 3874f5f73c441c52f1c699c848d463b0eda01e4c)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  0fe466df932d23fd8881bba1ab2c1798c09884c1:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  (cherry picked from commit 3874f5f73c441c52f1c699c848d463b0eda01e4c)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  e2e6520689b0ebbce43ce9bfd723e98872ff9b3d:nbd/server: CVE-2024-7409: Close stray clients at server-stop

  A malicious client can attempt to connect to an NBD server, and then
  intentionally delay progress in the handshake, including if it does
  not know the TLS secrets.  Although the previous two patches reduce
  this behavior by capping the default max-connections parameter and
  killing slow clients, they did not eliminate the possibility of a
  client waiting to close the socket until after the QMP nbd-server-stop
  command is executed, at which point qemu would SEGV when trying to
  dereference the NULL nbd_server global which is no longer present.
  This amounts to a denial of service attack.  Worse, if another NBD
  server is started before the malicious client disconnects, I cannot
  rule out additional adverse effects when the old client interferes
  with the connection count of the new server (although the most likely
  is a crash due to an assertion failure when checking
  nbd_server->connections > 0).

  For environments without this patch, the CVE can be mitigated by
  ensuring (such as via a firewall) that only trusted clients can
  connect to an NBD server.  Note that using frameworks like libvirt
  that ensure that TLS is used and that nbd-server-stop is not executed
  while any trusted clients are still connected will only help if there
  is also no possibility for an untrusted client to open a connection
  but then stall on the NBD handshake.

  Given the previous patches, it would be possible to guarantee that no
  clients remain connected by having nbd-server-stop sleep for longer
  than the default handshake deadline before finally freeing the global
  nbd_server object, but that could make QMP non-responsive for a long
  time.  So intead, this patch fixes the problem by tracking all client
  sockets opened while the server is running, and forcefully closing any
  such sockets remaining without a completed handshake at the time of
  nbd-server-stop, then waiting until the coroutines servicing those
  sockets notice the state change.  nbd-server-stop now has a second
  AIO_WAIT_WHILE_UNLOCKED (the first is indirectly through the
  blk_exp_close_all_type() that disconnects all clients that completed
  handshakes), but forced socket shutdown is enough to progress the
  coroutines and quickly tear down all clients before the server is
  freed, thus finally fixing the CVE.

  This patch relies heavily on the fact that nbd/server.c guarantees
  that it only calls nbd_blockdev_client_closed() from the main loop
  (see the assertion in nbd_client_put() and the hoops used in
  nbd_client_put_nonzero() to achieve that); if we did not have that
  guarantee, we would also need a mutex protecting our accesses of the
  list of connections to survive re-entrancy from independent iothreads.

  Although I did not actually try to test old builds, it looks like this
  problem has existed since at least commit 862172f45c (v2.12.0, 2017) -
  even back when that patch started using a QIONetListener to handle
  listening on multiple sockets, nbd_server_free() was already unaware
  that the nbd_blockdev_client_closed callback can be reached later by a
  client thread that has not completed handshakes (and therefore the
  client's socket never got added to the list closed in
  nbd_export_close_all), despite that patch intentionally tearing down
  the QIONetListener to prevent new clients.

  Reported-by: Alexander Ivanov <alexander.ivanov@virtuozzo.com>
  Fixes: CVE-2024-7409
  CC: qemu-stable@nongnu.org
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-14-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  (cherry picked from commit 3e7ef738c8462c45043a1d39f702a0990406a3b3)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  e2e6520689b0ebbce43ce9bfd723e98872ff9b3d:nbd/server: CVE-2024-7409: Close stray clients at server-stop

  A malicious client can attempt to connect to an NBD server, and then
  intentionally delay progress in the handshake, including if it does
  not know the TLS secrets.  Although the previous two patches reduce
  this behavior by capping the default max-connections parameter and
  killing slow clients, they did not eliminate the possibility of a
  client waiting to close the socket until after the QMP nbd-server-stop
  command is executed, at which point qemu would SEGV when trying to
  dereference the NULL nbd_server global which is no longer present.
  This amounts to a denial of service attack.  Worse, if another NBD
  server is started before the malicious client disconnects, I cannot
  rule out additional adverse effects when the old client interferes
  with the connection count of the new server (although the most likely
  is a crash due to an assertion failure when checking
  nbd_server->connections > 0).

  For environments without this patch, the CVE can be mitigated by
  ensuring (such as via a firewall) that only trusted clients can
  connect to an NBD server.  Note that using frameworks like libvirt
  that ensure that TLS is used and that nbd-server-stop is not executed
  while any trusted clients are still connected will only help if there
  is also no possibility for an untrusted client to open a connection
  but then stall on the NBD handshake.

  Given the previous patches, it would be possible to guarantee that no
  clients remain connected by having nbd-server-stop sleep for longer
  than the default handshake deadline before finally freeing the global
  nbd_server object, but that could make QMP non-responsive for a long
  time.  So intead, this patch fixes the problem by tracking all client
  sockets opened while the server is running, and forcefully closing any
  such sockets remaining without a completed handshake at the time of
  nbd-server-stop, then waiting until the coroutines servicing those
  sockets notice the state change.  nbd-server-stop now has a second
  AIO_WAIT_WHILE_UNLOCKED (the first is indirectly through the
  blk_exp_close_all_type() that disconnects all clients that completed
  handshakes), but forced socket shutdown is enough to progress the
  coroutines and quickly tear down all clients before the server is
  freed, thus finally fixing the CVE.

  This patch relies heavily on the fact that nbd/server.c guarantees
  that it only calls nbd_blockdev_client_closed() from the main loop
  (see the assertion in nbd_client_put() and the hoops used in
  nbd_client_put_nonzero() to achieve that); if we did not have that
  guarantee, we would also need a mutex protecting our accesses of the
  list of connections to survive re-entrancy from independent iothreads.

  Although I did not actually try to test old builds, it looks like this
  problem has existed since at least commit 862172f45c (v2.12.0, 2017) -
  even back when that patch started using a QIONetListener to handle
  listening on multiple sockets, nbd_server_free() was already unaware
  that the nbd_blockdev_client_closed callback can be reached later by a
  client thread that has not completed handshakes (and therefore the
  client's socket never got added to the list closed in
  nbd_export_close_all), despite that patch intentionally tearing down
  the QIONetListener to prevent new clients.

  Reported-by: Alexander Ivanov <alexander.ivanov@virtuozzo.com>
  Fixes: CVE-2024-7409
  CC: qemu-stable@nongnu.org
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-14-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  (cherry picked from commit 3e7ef738c8462c45043a1d39f702a0990406a3b3)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  420c6c29801a6f161195bed6d156aad91ee23650:nbd/server: CVE-2024-7409: Drop non-negotiating clients

  A client that opens a socket but does not negotiate is merely hogging
  qemu's resources (an open fd and a small amount of memory); and a
  malicious client that can access the port where NBD is listening can
  attempt a denial of service attack by intentionally opening and
  abandoning lots of unfinished connections.  The previous patch put a
  default bound on the number of such ongoing connections, but once that
  limit is hit, no more clients can connect (including legitimate ones).
  The solution is to insist that clients complete handshake within a
  reasonable time limit, defaulting to 10 seconds.  A client that has
  not successfully completed NBD_OPT_GO by then (including the case of
  where the client didn't know TLS credentials to even reach the point
  of NBD_OPT_GO) is wasting our time and does not deserve to stay
  connected.  Later patches will allow fine-tuning the limit away from
  the default value (including disabling it for doing integration
  testing of the handshake process itself).

  Note that this patch in isolation actually makes it more likely to see
  qemu SEGV after nbd-server-stop, as any client socket still connected
  when the server shuts down will now be closed after 10 seconds rather
  than at the client's whims.  That will be addressed in the next patch.

  For a demo of this patch in action:
  $ qemu-nbd -f raw -r -t -e 10 file &
  $ nbdsh --opt-mode -c '
  H = list()
  for i in range(20):
    print(i)
    H.insert(i, nbd.NBD())
    H[i].set_opt_mode(True)
    H[i].connect_uri("nbd://localhost")
  '
  $ kill $!

  where later connections get to start progressing once earlier ones are
  forcefully dropped for taking too long, rather than hanging.

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-13-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [eblake: rebase to changes earlier in series, reduce scope of timer]
  Signed-off-by: Eric Blake <eblake@redhat.com>
  (cherry picked from commit b9b72cb3ce15b693148bd09cef7e50110566d8a0)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  bb0356daf0e3275f762179f22031dcdc27daa46e:nbd/server: CVE-2024-7409: Cap default max-connections to 100

  Allowing an unlimited number of clients to any web service is a recipe
  for a rudimentary denial of service attack: the client merely needs to
  open lots of sockets without closing them, until qemu no longer has
  any more fds available to allocate.

  For qemu-nbd, we default to allowing only 1 connection unless more are
  explicitly asked for (-e or --shared); this was historically picked as
  a nice default (without an explicit -t, a non-persistent qemu-nbd goes
  away after a client disconnects, without needing any additional
  follow-up commands), and we are not going to change that interface now
  (besides, someday we want to point people towards qemu-storage-daemon
  instead of qemu-nbd).

  But for qemu proper, and the newer qemu-storage-daemon, the QMP
  nbd-server-start command has historically had a default of unlimited
  number of connections, in part because unlike qemu-nbd it is
  inherently persistent until nbd-server-stop.  Allowing multiple client
  sockets is particularly useful for clients that can take advantage of
  MULTI_CONN (creating parallel sockets to increase throughput),
  although known clients that do so (such as libnbd's nbdcopy) typically
  use only 8 or 16 connections (the benefits of scaling diminish once
  more sockets are competing for kernel attention).  Picking a number
  large enough for typical use cases, but not unlimited, makes it
  slightly harder for a malicious client to perform a denial of service
  merely by opening lots of connections withot progressing through the
  handshake.

  This change does not eliminate CVE-2024-7409 on its own, but reduces
  the chance for fd exhaustion or unlimited memory usage as an attack
  surface.  On the other hand, by itself, it makes it more obvious that
  with a finite limit, we have the problem of an unauthenticated client
  holding 100 fds opened as a way to block out a legitimate client from
  being able to connect; thus, later patches will further add timeouts
  to reject clients that are not making progress.

  This is an INTENTIONAL change in behavior, and will break any client
  of nbd-server-start that was not passing an explicit max-connections
  parameter, yet expects more than 100 simultaneous connections.  We are
  not aware of any such client (as stated above, most clients aware of
  MULTI_CONN get by just fine on 8 or 16 connections, and probably cope
  with later connections failing by relying on the earlier connections;
  libvirt has not yet been passing max-connections, but generally
  creates NBD servers with the intent for a single client for the sake
  of live storage migration; meanwhile, the KubeSAN project anticipates
  a large cluster sharing multiple clients [up to 8 per node, and up to
  100 nodes in a cluster], but it currently uses qemu-nbd with an
  explicit --shared=0 rather than qemu-storage-daemon with
  nbd-server-start).

  We considered using a deprecation period (declare that omitting
  max-parameters is deprecated, and make it mandatory in 3 releases -
  then we don't need to pick an arbitrary default); that has zero risk
  of breaking any apps that accidentally depended on more than 100
  connections, and where such breakage might not be noticed under unit
  testing but only under the larger loads of production usage.  But it
  does not close the denial-of-service hole until far into the future,
  and requires all apps to change to add the parameter even if 100 was
  good enough.  It also has a drawback that any app (like libvirt) that
  is accidentally relying on an unlimited default should seriously
  consider their own CVE now, at which point they are going to change to
  pass explicit max-connections sooner than waiting for 3 qemu releases.
  Finally, if our changed default breaks an app, that app can always
  pass in an explicit max-parameters with a larger value.

  It is also intentional that the HMP interface to nbd-server-start is
  not changed to expose max-connections (any client needing to fine-tune
  things should be using QMP).

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-12-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [ericb: Expand commit message to summarize Dan's argument for why we
  break corner-case back-compat behavior without a deprecation period]
  Signed-off-by: Eric Blake <eblake@redhat.com>
  (cherry picked from commit c8a76dbd90c2f48df89b75bef74917f90a59b623)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  bb0356daf0e3275f762179f22031dcdc27daa46e:nbd/server: CVE-2024-7409: Cap default max-connections to 100

  Allowing an unlimited number of clients to any web service is a recipe
  for a rudimentary denial of service attack: the client merely needs to
  open lots of sockets without closing them, until qemu no longer has
  any more fds available to allocate.

  For qemu-nbd, we default to allowing only 1 connection unless more are
  explicitly asked for (-e or --shared); this was historically picked as
  a nice default (without an explicit -t, a non-persistent qemu-nbd goes
  away after a client disconnects, without needing any additional
  follow-up commands), and we are not going to change that interface now
  (besides, someday we want to point people towards qemu-storage-daemon
  instead of qemu-nbd).

  But for qemu proper, and the newer qemu-storage-daemon, the QMP
  nbd-server-start command has historically had a default of unlimited
  number of connections, in part because unlike qemu-nbd it is
  inherently persistent until nbd-server-stop.  Allowing multiple client
  sockets is particularly useful for clients that can take advantage of
  MULTI_CONN (creating parallel sockets to increase throughput),
  although known clients that do so (such as libnbd's nbdcopy) typically
  use only 8 or 16 connections (the benefits of scaling diminish once
  more sockets are competing for kernel attention).  Picking a number
  large enough for typical use cases, but not unlimited, makes it
  slightly harder for a malicious client to perform a denial of service
  merely by opening lots of connections withot progressing through the
  handshake.

  This change does not eliminate CVE-2024-7409 on its own, but reduces
  the chance for fd exhaustion or unlimited memory usage as an attack
  surface.  On the other hand, by itself, it makes it more obvious that
  with a finite limit, we have the problem of an unauthenticated client
  holding 100 fds opened as a way to block out a legitimate client from
  being able to connect; thus, later patches will further add timeouts
  to reject clients that are not making progress.

  This is an INTENTIONAL change in behavior, and will break any client
  of nbd-server-start that was not passing an explicit max-connections
  parameter, yet expects more than 100 simultaneous connections.  We are
  not aware of any such client (as stated above, most clients aware of
  MULTI_CONN get by just fine on 8 or 16 connections, and probably cope
  with later connections failing by relying on the earlier connections;
  libvirt has not yet been passing max-connections, but generally
  creates NBD servers with the intent for a single client for the sake
  of live storage migration; meanwhile, the KubeSAN project anticipates
  a large cluster sharing multiple clients [up to 8 per node, and up to
  100 nodes in a cluster], but it currently uses qemu-nbd with an
  explicit --shared=0 rather than qemu-storage-daemon with
  nbd-server-start).

  We considered using a deprecation period (declare that omitting
  max-parameters is deprecated, and make it mandatory in 3 releases -
  then we don't need to pick an arbitrary default); that has zero risk
  of breaking any apps that accidentally depended on more than 100
  connections, and where such breakage might not be noticed under unit
  testing but only under the larger loads of production usage.  But it
  does not close the denial-of-service hole until far into the future,
  and requires all apps to change to add the parameter even if 100 was
  good enough.  It also has a drawback that any app (like libvirt) that
  is accidentally relying on an unlimited default should seriously
  consider their own CVE now, at which point they are going to change to
  pass explicit max-connections sooner than waiting for 3 qemu releases.
  Finally, if our changed default breaks an app, that app can always
  pass in an explicit max-parameters with a larger value.

  It is also intentional that the HMP interface to nbd-server-start is
  not changed to expose max-connections (any client needing to fine-tune
  things should be using QMP).

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-12-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [ericb: Expand commit message to summarize Dan's argument for why we
  break corner-case back-compat behavior without a deprecation period]
  Signed-off-by: Eric Blake <eblake@redhat.com>
  (cherry picked from commit c8a76dbd90c2f48df89b75bef74917f90a59b623)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  fe547837bf9d227a1abc737ffd7aee4caa0e405d:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  (cherry picked from commit 3874f5f73c441c52f1c699c848d463b0eda01e4c)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  fe547837bf9d227a1abc737ffd7aee4caa0e405d:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  (cherry picked from commit 3874f5f73c441c52f1c699c848d463b0eda01e4c)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  fe547837bf9d227a1abc737ffd7aee4caa0e405d:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  (cherry picked from commit 3874f5f73c441c52f1c699c848d463b0eda01e4c)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  afaee42f777bc359db95f692804f7fc7e12c0c02:Merge tag 'pull-nbd-2024-08-26' of https://repo.or.cz/qemu/ericb into staging

  NBD patches for 2024-08-26

  - One more patch for CVE-2024-7409 (use-after-free on nbd-server-stop)

  # -----BEGIN PGP SIGNATURE-----
  #
  # iQEzBAABCAAdFiEEccLMIrHEYCkn0vOqp6FrSiUnQ2oFAmbMh9MACgkQp6FrSiUn
  # Q2ovfAf/TyHYtJUwSAQ3dgn4PlTym4FqN8CXa+EJQR9xSLJ5jAX3QgLBieUiIT31
  # AFr9W6eqWNz4NksbeoHdwZVqUlkGJFsfiyTOK93k4/fYQdTbqSHPwo2FYlOXqdJB
  # bZN10zEvd7YRMrxTjGyPxNFCm2iIMZy8uEerOrY9hV1PVULHg6u3Pu8a6El4BK8k
  # k5S0SwluTkUkBLbqtEC6fHjdfFFr/dC8IB11Ly8FdxKHixIaUTVsZ20guNM0Q5Ca
  # kU2em2PcroDq3B0x3linD3xh3pVmlHdb4H+9runmGPnpJj5wjPL35aDzlU7GCT3B
  # kEGX5VzOJOJUXoHVyYrvJCD4I7YgMw==
  # =ZDYx
  # -----END PGP SIGNATURE-----
  # gpg: Signature made Mon 26 Aug 2024 11:49:07 PM AEST
  # gpg:                using RSA key 71C2CC22B1C4602927D2F3AAA7A16B4A2527436A
  # gpg: Good signature from "Eric Blake <eblake@redhat.com>" [full]
  # gpg:                 aka "Eric Blake (Free Software Programmer) <ebb9@byu.net>" [full]
  # gpg:                 aka "[jpeg image of size 6874]" [full]

  * tag 'pull-nbd-2024-08-26' of https://repo.or.cz/qemu/ericb:
    nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Signed-off-by: Richard Henderson <richard.henderson@linaro.org>
  afaee42f777bc359db95f692804f7fc7e12c0c02:Merge tag 'pull-nbd-2024-08-26' of https://repo.or.cz/qemu/ericb into staging

  NBD patches for 2024-08-26

  - One more patch for CVE-2024-7409 (use-after-free on nbd-server-stop)

  # -----BEGIN PGP SIGNATURE-----
  #
  # iQEzBAABCAAdFiEEccLMIrHEYCkn0vOqp6FrSiUnQ2oFAmbMh9MACgkQp6FrSiUn
  # Q2ovfAf/TyHYtJUwSAQ3dgn4PlTym4FqN8CXa+EJQR9xSLJ5jAX3QgLBieUiIT31
  # AFr9W6eqWNz4NksbeoHdwZVqUlkGJFsfiyTOK93k4/fYQdTbqSHPwo2FYlOXqdJB
  # bZN10zEvd7YRMrxTjGyPxNFCm2iIMZy8uEerOrY9hV1PVULHg6u3Pu8a6El4BK8k
  # k5S0SwluTkUkBLbqtEC6fHjdfFFr/dC8IB11Ly8FdxKHixIaUTVsZ20guNM0Q5Ca
  # kU2em2PcroDq3B0x3linD3xh3pVmlHdb4H+9runmGPnpJj5wjPL35aDzlU7GCT3B
  # kEGX5VzOJOJUXoHVyYrvJCD4I7YgMw==
  # =ZDYx
  # -----END PGP SIGNATURE-----
  # gpg: Signature made Mon 26 Aug 2024 11:49:07 PM AEST
  # gpg:                using RSA key 71C2CC22B1C4602927D2F3AAA7A16B4A2527436A
  # gpg: Good signature from "Eric Blake <eblake@redhat.com>" [full]
  # gpg:                 aka "Eric Blake (Free Software Programmer) <ebb9@byu.net>" [full]
  # gpg:                 aka "[jpeg image of size 6874]" [full]

  * tag 'pull-nbd-2024-08-26' of https://repo.or.cz/qemu/ericb:
    nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Signed-off-by: Richard Henderson <richard.henderson@linaro.org>
  3874f5f73c441c52f1c699c848d463b0eda01e4c:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  3874f5f73c441c52f1c699c848d463b0eda01e4c:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  3874f5f73c441c52f1c699c848d463b0eda01e4c:nbd/server: CVE-2024-7409: Avoid use-after-free when closing server

  Commit 3e7ef738 plugged the use-after-free of the global nbd_server
  object, but overlooked a use-after-free of nbd_server->listener.
  Although this race is harder to hit, notice that our shutdown path
  first drops the reference count of nbd_server->listener, then triggers
  actions that can result in a pending client reaching the
  nbd_blockdev_client_closed() callback, which in turn calls
  qio_net_listener_set_client_func on a potentially stale object.

  If we know we don't want any more clients to connect, and have already
  told the listener socket to shut down, then we should not be trying to
  update the listener socket's associated function.

  Reproducer:

  > #!/usr/bin/python3
  >
  > import os
  > from threading import Thread
  >
  > def start_stop():
  >     while 1:
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-start",
  +"arguments":{"addr":{"type":"unix","data":{"path":"/tmp/nbd-sock"}}}}\'')
  >         os.system('virsh qemu-monitor-command VM \'{"execute": "nbd-server-stop"}\'')
  >
  > def nbd_list():
  >     while 1:
  >         os.system('/path/to/build/qemu-nbd -L -k /tmp/nbd-sock')
  >
  > def test():
  >     sst = Thread(target=start_stop)
  >     sst.start()
  >     nlt = Thread(target=nbd_list)
  >     nlt.start()
  >
  >     sst.join()
  >     nlt.join()
  >
  > test()

  Fixes: CVE-2024-7409
  Fixes: 3e7ef738c8 ("nbd/server: CVE-2024-7409: Close stray clients at server-stop")
  CC: qemu-stable@nongnu.org
  Reported-by: Andrey Drobyshev <andrey.drobyshev@virtuozzo.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240822143617.800419-2-eblake@redhat.com>
  Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
  9df5c133c9435e3653c6f82e34f891959089f219:nbd/server: CVE-2024-7409: Close stray clients at server-stop

  A malicious client can attempt to connect to an NBD server, and then
  intentionally delay progress in the handshake, including if it does
  not know the TLS secrets.  Although the previous two patches reduce
  this behavior by capping the default max-connections parameter and
  killing slow clients, they did not eliminate the possibility of a
  client waiting to close the socket until after the QMP nbd-server-stop
  command is executed, at which point qemu would SEGV when trying to
  dereference the NULL nbd_server global which is no longer present.
  This amounts to a denial of service attack.  Worse, if another NBD
  server is started before the malicious client disconnects, I cannot
  rule out additional adverse effects when the old client interferes
  with the connection count of the new server (although the most likely
  is a crash due to an assertion failure when checking
  nbd_server->connections > 0).

  For environments without this patch, the CVE can be mitigated by
  ensuring (such as via a firewall) that only trusted clients can
  connect to an NBD server.  Note that using frameworks like libvirt
  that ensure that TLS is used and that nbd-server-stop is not executed
  while any trusted clients are still connected will only help if there
  is also no possibility for an untrusted client to open a connection
  but then stall on the NBD handshake.

  Given the previous patches, it would be possible to guarantee that no
  clients remain connected by having nbd-server-stop sleep for longer
  than the default handshake deadline before finally freeing the global
  nbd_server object, but that could make QMP non-responsive for a long
  time.  So intead, this patch fixes the problem by tracking all client
  sockets opened while the server is running, and forcefully closing any
  such sockets remaining without a completed handshake at the time of
  nbd-server-stop, then waiting until the coroutines servicing those
  sockets notice the state change.  nbd-server-stop now has a second
  AIO_WAIT_WHILE_UNLOCKED (the first is indirectly through the
  blk_exp_close_all_type() that disconnects all clients that completed
  handshakes), but forced socket shutdown is enough to progress the
  coroutines and quickly tear down all clients before the server is
  freed, thus finally fixing the CVE.

  This patch relies heavily on the fact that nbd/server.c guarantees
  that it only calls nbd_blockdev_client_closed() from the main loop
  (see the assertion in nbd_client_put() and the hoops used in
  nbd_client_put_nonzero() to achieve that); if we did not have that
  guarantee, we would also need a mutex protecting our accesses of the
  list of connections to survive re-entrancy from independent iothreads.

  Although I did not actually try to test old builds, it looks like this
  problem has existed since at least commit 862172f45c (v2.12.0, 2017) -
  even back when that patch started using a QIONetListener to handle
  listening on multiple sockets, nbd_server_free() was already unaware
  that the nbd_blockdev_client_closed callback can be reached later by a
  client thread that has not completed handshakes (and therefore the
  client's socket never got added to the list closed in
  nbd_export_close_all), despite that patch intentionally tearing down
  the QIONetListener to prevent new clients.

  Reported-by: Alexander Ivanov <alexander.ivanov@virtuozzo.com>
  Fixes: CVE-2024-7409
  CC: qemu-stable@nongnu.org
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-14-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  (cherry picked from commit 3e7ef738c8462c45043a1d39f702a0990406a3b3)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  9df5c133c9435e3653c6f82e34f891959089f219:nbd/server: CVE-2024-7409: Close stray clients at server-stop

  A malicious client can attempt to connect to an NBD server, and then
  intentionally delay progress in the handshake, including if it does
  not know the TLS secrets.  Although the previous two patches reduce
  this behavior by capping the default max-connections parameter and
  killing slow clients, they did not eliminate the possibility of a
  client waiting to close the socket until after the QMP nbd-server-stop
  command is executed, at which point qemu would SEGV when trying to
  dereference the NULL nbd_server global which is no longer present.
  This amounts to a denial of service attack.  Worse, if another NBD
  server is started before the malicious client disconnects, I cannot
  rule out additional adverse effects when the old client interferes
  with the connection count of the new server (although the most likely
  is a crash due to an assertion failure when checking
  nbd_server->connections > 0).

  For environments without this patch, the CVE can be mitigated by
  ensuring (such as via a firewall) that only trusted clients can
  connect to an NBD server.  Note that using frameworks like libvirt
  that ensure that TLS is used and that nbd-server-stop is not executed
  while any trusted clients are still connected will only help if there
  is also no possibility for an untrusted client to open a connection
  but then stall on the NBD handshake.

  Given the previous patches, it would be possible to guarantee that no
  clients remain connected by having nbd-server-stop sleep for longer
  than the default handshake deadline before finally freeing the global
  nbd_server object, but that could make QMP non-responsive for a long
  time.  So intead, this patch fixes the problem by tracking all client
  sockets opened while the server is running, and forcefully closing any
  such sockets remaining without a completed handshake at the time of
  nbd-server-stop, then waiting until the coroutines servicing those
  sockets notice the state change.  nbd-server-stop now has a second
  AIO_WAIT_WHILE_UNLOCKED (the first is indirectly through the
  blk_exp_close_all_type() that disconnects all clients that completed
  handshakes), but forced socket shutdown is enough to progress the
  coroutines and quickly tear down all clients before the server is
  freed, thus finally fixing the CVE.

  This patch relies heavily on the fact that nbd/server.c guarantees
  that it only calls nbd_blockdev_client_closed() from the main loop
  (see the assertion in nbd_client_put() and the hoops used in
  nbd_client_put_nonzero() to achieve that); if we did not have that
  guarantee, we would also need a mutex protecting our accesses of the
  list of connections to survive re-entrancy from independent iothreads.

  Although I did not actually try to test old builds, it looks like this
  problem has existed since at least commit 862172f45c (v2.12.0, 2017) -
  even back when that patch started using a QIONetListener to handle
  listening on multiple sockets, nbd_server_free() was already unaware
  that the nbd_blockdev_client_closed callback can be reached later by a
  client thread that has not completed handshakes (and therefore the
  client's socket never got added to the list closed in
  nbd_export_close_all), despite that patch intentionally tearing down
  the QIONetListener to prevent new clients.

  Reported-by: Alexander Ivanov <alexander.ivanov@virtuozzo.com>
  Fixes: CVE-2024-7409
  CC: qemu-stable@nongnu.org
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-14-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  (cherry picked from commit 3e7ef738c8462c45043a1d39f702a0990406a3b3)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  7d31776d7f747cbfb83ecf0366878896f659361e:nbd/server: CVE-2024-7409: Drop non-negotiating clients

  A client that opens a socket but does not negotiate is merely hogging
  qemu's resources (an open fd and a small amount of memory); and a
  malicious client that can access the port where NBD is listening can
  attempt a denial of service attack by intentionally opening and
  abandoning lots of unfinished connections.  The previous patch put a
  default bound on the number of such ongoing connections, but once that
  limit is hit, no more clients can connect (including legitimate ones).
  The solution is to insist that clients complete handshake within a
  reasonable time limit, defaulting to 10 seconds.  A client that has
  not successfully completed NBD_OPT_GO by then (including the case of
  where the client didn't know TLS credentials to even reach the point
  of NBD_OPT_GO) is wasting our time and does not deserve to stay
  connected.  Later patches will allow fine-tuning the limit away from
  the default value (including disabling it for doing integration
  testing of the handshake process itself).

  Note that this patch in isolation actually makes it more likely to see
  qemu SEGV after nbd-server-stop, as any client socket still connected
  when the server shuts down will now be closed after 10 seconds rather
  than at the client's whims.  That will be addressed in the next patch.

  For a demo of this patch in action:
  $ qemu-nbd -f raw -r -t -e 10 file &
  $ nbdsh --opt-mode -c '
  H = list()
  for i in range(20):
    print(i)
    H.insert(i, nbd.NBD())
    H[i].set_opt_mode(True)
    H[i].connect_uri("nbd://localhost")
  '
  $ kill $!

  where later connections get to start progressing once earlier ones are
  forcefully dropped for taking too long, rather than hanging.

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-13-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [eblake: rebase to changes earlier in series, reduce scope of timer]
  Signed-off-by: Eric Blake <eblake@redhat.com>
  (cherry picked from commit b9b72cb3ce15b693148bd09cef7e50110566d8a0)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  (Mjt: context fixup in nbd/server.c: lack of WITH_QEMU_LOCK_GUARD in 7.2)
  dbf946c25112f682ff783240a0fb6130805e41c4:nbd/server: CVE-2024-7409: Cap default max-connections to 100

  Allowing an unlimited number of clients to any web service is a recipe
  for a rudimentary denial of service attack: the client merely needs to
  open lots of sockets without closing them, until qemu no longer has
  any more fds available to allocate.

  For qemu-nbd, we default to allowing only 1 connection unless more are
  explicitly asked for (-e or --shared); this was historically picked as
  a nice default (without an explicit -t, a non-persistent qemu-nbd goes
  away after a client disconnects, without needing any additional
  follow-up commands), and we are not going to change that interface now
  (besides, someday we want to point people towards qemu-storage-daemon
  instead of qemu-nbd).

  But for qemu proper, and the newer qemu-storage-daemon, the QMP
  nbd-server-start command has historically had a default of unlimited
  number of connections, in part because unlike qemu-nbd it is
  inherently persistent until nbd-server-stop.  Allowing multiple client
  sockets is particularly useful for clients that can take advantage of
  MULTI_CONN (creating parallel sockets to increase throughput),
  although known clients that do so (such as libnbd's nbdcopy) typically
  use only 8 or 16 connections (the benefits of scaling diminish once
  more sockets are competing for kernel attention).  Picking a number
  large enough for typical use cases, but not unlimited, makes it
  slightly harder for a malicious client to perform a denial of service
  merely by opening lots of connections withot progressing through the
  handshake.

  This change does not eliminate CVE-2024-7409 on its own, but reduces
  the chance for fd exhaustion or unlimited memory usage as an attack
  surface.  On the other hand, by itself, it makes it more obvious that
  with a finite limit, we have the problem of an unauthenticated client
  holding 100 fds opened as a way to block out a legitimate client from
  being able to connect; thus, later patches will further add timeouts
  to reject clients that are not making progress.

  This is an INTENTIONAL change in behavior, and will break any client
  of nbd-server-start that was not passing an explicit max-connections
  parameter, yet expects more than 100 simultaneous connections.  We are
  not aware of any such client (as stated above, most clients aware of
  MULTI_CONN get by just fine on 8 or 16 connections, and probably cope
  with later connections failing by relying on the earlier connections;
  libvirt has not yet been passing max-connections, but generally
  creates NBD servers with the intent for a single client for the sake
  of live storage migration; meanwhile, the KubeSAN project anticipates
  a large cluster sharing multiple clients [up to 8 per node, and up to
  100 nodes in a cluster], but it currently uses qemu-nbd with an
  explicit --shared=0 rather than qemu-storage-daemon with
  nbd-server-start).

  We considered using a deprecation period (declare that omitting
  max-parameters is deprecated, and make it mandatory in 3 releases -
  then we don't need to pick an arbitrary default); that has zero risk
  of breaking any apps that accidentally depended on more than 100
  connections, and where such breakage might not be noticed under unit
  testing but only under the larger loads of production usage.  But it
  does not close the denial-of-service hole until far into the future,
  and requires all apps to change to add the parameter even if 100 was
  good enough.  It also has a drawback that any app (like libvirt) that
  is accidentally relying on an unlimited default should seriously
  consider their own CVE now, at which point they are going to change to
  pass explicit max-connections sooner than waiting for 3 qemu releases.
  Finally, if our changed default breaks an app, that app can always
  pass in an explicit max-parameters with a larger value.

  It is also intentional that the HMP interface to nbd-server-start is
  not changed to expose max-connections (any client needing to fine-tune
  things should be using QMP).

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-12-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [ericb: Expand commit message to summarize Dan's argument for why we
  break corner-case back-compat behavior without a deprecation period]
  Signed-off-by: Eric Blake <eblake@redhat.com>
  (cherry picked from commit c8a76dbd90c2f48df89b75bef74917f90a59b623)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  (Mjt: minor fixups in qapi/block-export.json)
  dbf946c25112f682ff783240a0fb6130805e41c4:nbd/server: CVE-2024-7409: Cap default max-connections to 100

  Allowing an unlimited number of clients to any web service is a recipe
  for a rudimentary denial of service attack: the client merely needs to
  open lots of sockets without closing them, until qemu no longer has
  any more fds available to allocate.

  For qemu-nbd, we default to allowing only 1 connection unless more are
  explicitly asked for (-e or --shared); this was historically picked as
  a nice default (without an explicit -t, a non-persistent qemu-nbd goes
  away after a client disconnects, without needing any additional
  follow-up commands), and we are not going to change that interface now
  (besides, someday we want to point people towards qemu-storage-daemon
  instead of qemu-nbd).

  But for qemu proper, and the newer qemu-storage-daemon, the QMP
  nbd-server-start command has historically had a default of unlimited
  number of connections, in part because unlike qemu-nbd it is
  inherently persistent until nbd-server-stop.  Allowing multiple client
  sockets is particularly useful for clients that can take advantage of
  MULTI_CONN (creating parallel sockets to increase throughput),
  although known clients that do so (such as libnbd's nbdcopy) typically
  use only 8 or 16 connections (the benefits of scaling diminish once
  more sockets are competing for kernel attention).  Picking a number
  large enough for typical use cases, but not unlimited, makes it
  slightly harder for a malicious client to perform a denial of service
  merely by opening lots of connections withot progressing through the
  handshake.

  This change does not eliminate CVE-2024-7409 on its own, but reduces
  the chance for fd exhaustion or unlimited memory usage as an attack
  surface.  On the other hand, by itself, it makes it more obvious that
  with a finite limit, we have the problem of an unauthenticated client
  holding 100 fds opened as a way to block out a legitimate client from
  being able to connect; thus, later patches will further add timeouts
  to reject clients that are not making progress.

  This is an INTENTIONAL change in behavior, and will break any client
  of nbd-server-start that was not passing an explicit max-connections
  parameter, yet expects more than 100 simultaneous connections.  We are
  not aware of any such client (as stated above, most clients aware of
  MULTI_CONN get by just fine on 8 or 16 connections, and probably cope
  with later connections failing by relying on the earlier connections;
  libvirt has not yet been passing max-connections, but generally
  creates NBD servers with the intent for a single client for the sake
  of live storage migration; meanwhile, the KubeSAN project anticipates
  a large cluster sharing multiple clients [up to 8 per node, and up to
  100 nodes in a cluster], but it currently uses qemu-nbd with an
  explicit --shared=0 rather than qemu-storage-daemon with
  nbd-server-start).

  We considered using a deprecation period (declare that omitting
  max-parameters is deprecated, and make it mandatory in 3 releases -
  then we don't need to pick an arbitrary default); that has zero risk
  of breaking any apps that accidentally depended on more than 100
  connections, and where such breakage might not be noticed under unit
  testing but only under the larger loads of production usage.  But it
  does not close the denial-of-service hole until far into the future,
  and requires all apps to change to add the parameter even if 100 was
  good enough.  It also has a drawback that any app (like libvirt) that
  is accidentally relying on an unlimited default should seriously
  consider their own CVE now, at which point they are going to change to
  pass explicit max-connections sooner than waiting for 3 qemu releases.
  Finally, if our changed default breaks an app, that app can always
  pass in an explicit max-parameters with a larger value.

  It is also intentional that the HMP interface to nbd-server-start is
  not changed to expose max-connections (any client needing to fine-tune
  things should be using QMP).

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-12-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [ericb: Expand commit message to summarize Dan's argument for why we
  break corner-case back-compat behavior without a deprecation period]
  Signed-off-by: Eric Blake <eblake@redhat.com>
  (cherry picked from commit c8a76dbd90c2f48df89b75bef74917f90a59b623)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  (Mjt: minor fixups in qapi/block-export.json)
  0f397dcfecc9211d12c2c720c01eb32f0eaa7d23:Merge tag 'pull-nbd-2024-08-08' of https://repo.or.cz/qemu/ericb into staging

  NBD patches for 2024-08-08

  - plug CVE-2024-7409, a DoS attack exploiting nbd-server-stop

  # -----BEGIN PGP SIGNATURE-----
  #
  # iQEzBAABCAAdFiEEccLMIrHEYCkn0vOqp6FrSiUnQ2oFAma1PVEACgkQp6FrSiUn
  # Q2qdHQf/dMydqNcPYnwEI238APyljpNvHNq6p9TYb0l5aVWisXHRlhFWM117hH7T
  # Aq2KUgS5ppiEpw8mxa6/OaDa74VpMGyEPgn9w6o7T1xjVBVzpMxOKp5wFa8uICLj
  # mFMYXtj9i0Rb+z0iZ+X+CqIV2Wy/FyV00Wr9T4HW94IV/9EK1sWvZvfyGWyxYyBZ
  # XKTQV1Co3HYX8gfq7E88SgS064DnHjtRy2no4lwNFkBbVQCSbqwbK63TRPi7kEyC
  # DmSLdHCdsD7Ev9kMZ6uNJS5T/9t7hjO5mWJckLt/cXOjHgL7GkoisLH8/nGjVkyc
  # 3SUGjMn4TlzqMU99STRP+a48TLCVhA==
  # =kDut
  # -----END PGP SIGNATURE-----
  # gpg: Signature made Fri 09 Aug 2024 07:49:05 AM AEST
  # gpg:                using RSA key 71C2CC22B1C4602927D2F3AAA7A16B4A2527436A
  # gpg: Good signature from "Eric Blake <eblake@redhat.com>" [full]
  # gpg:                 aka "Eric Blake (Free Software Programmer) <ebb9@byu.net>" [full]
  # gpg:                 aka "[jpeg image of size 6874]" [full]

  * tag 'pull-nbd-2024-08-08' of https://repo.or.cz/qemu/ericb:
    nbd/server: CVE-2024-7409: Close stray clients at server-stop
    nbd/server: CVE-2024-7409: Drop non-negotiating clients
    nbd/server: CVE-2024-7409: Cap default max-connections to 100
    nbd/server: Plumb in new args to nbd_client_add()
    nbd: Minor style and typo fixes

  Signed-off-by: Richard Henderson <richard.henderson@linaro.org>
  0f397dcfecc9211d12c2c720c01eb32f0eaa7d23:Merge tag 'pull-nbd-2024-08-08' of https://repo.or.cz/qemu/ericb into staging

  NBD patches for 2024-08-08

  - plug CVE-2024-7409, a DoS attack exploiting nbd-server-stop

  # -----BEGIN PGP SIGNATURE-----
  #
  # iQEzBAABCAAdFiEEccLMIrHEYCkn0vOqp6FrSiUnQ2oFAma1PVEACgkQp6FrSiUn
  # Q2qdHQf/dMydqNcPYnwEI238APyljpNvHNq6p9TYb0l5aVWisXHRlhFWM117hH7T
  # Aq2KUgS5ppiEpw8mxa6/OaDa74VpMGyEPgn9w6o7T1xjVBVzpMxOKp5wFa8uICLj
  # mFMYXtj9i0Rb+z0iZ+X+CqIV2Wy/FyV00Wr9T4HW94IV/9EK1sWvZvfyGWyxYyBZ
  # XKTQV1Co3HYX8gfq7E88SgS064DnHjtRy2no4lwNFkBbVQCSbqwbK63TRPi7kEyC
  # DmSLdHCdsD7Ev9kMZ6uNJS5T/9t7hjO5mWJckLt/cXOjHgL7GkoisLH8/nGjVkyc
  # 3SUGjMn4TlzqMU99STRP+a48TLCVhA==
  # =kDut
  # -----END PGP SIGNATURE-----
  # gpg: Signature made Fri 09 Aug 2024 07:49:05 AM AEST
  # gpg:                using RSA key 71C2CC22B1C4602927D2F3AAA7A16B4A2527436A
  # gpg: Good signature from "Eric Blake <eblake@redhat.com>" [full]
  # gpg:                 aka "Eric Blake (Free Software Programmer) <ebb9@byu.net>" [full]
  # gpg:                 aka "[jpeg image of size 6874]" [full]

  * tag 'pull-nbd-2024-08-08' of https://repo.or.cz/qemu/ericb:
    nbd/server: CVE-2024-7409: Close stray clients at server-stop
    nbd/server: CVE-2024-7409: Drop non-negotiating clients
    nbd/server: CVE-2024-7409: Cap default max-connections to 100
    nbd/server: Plumb in new args to nbd_client_add()
    nbd: Minor style and typo fixes

  Signed-off-by: Richard Henderson <richard.henderson@linaro.org>
  0f397dcfecc9211d12c2c720c01eb32f0eaa7d23:Merge tag 'pull-nbd-2024-08-08' of https://repo.or.cz/qemu/ericb into staging

  NBD patches for 2024-08-08

  - plug CVE-2024-7409, a DoS attack exploiting nbd-server-stop

  # -----BEGIN PGP SIGNATURE-----
  #
  # iQEzBAABCAAdFiEEccLMIrHEYCkn0vOqp6FrSiUnQ2oFAma1PVEACgkQp6FrSiUn
  # Q2qdHQf/dMydqNcPYnwEI238APyljpNvHNq6p9TYb0l5aVWisXHRlhFWM117hH7T
  # Aq2KUgS5ppiEpw8mxa6/OaDa74VpMGyEPgn9w6o7T1xjVBVzpMxOKp5wFa8uICLj
  # mFMYXtj9i0Rb+z0iZ+X+CqIV2Wy/FyV00Wr9T4HW94IV/9EK1sWvZvfyGWyxYyBZ
  # XKTQV1Co3HYX8gfq7E88SgS064DnHjtRy2no4lwNFkBbVQCSbqwbK63TRPi7kEyC
  # DmSLdHCdsD7Ev9kMZ6uNJS5T/9t7hjO5mWJckLt/cXOjHgL7GkoisLH8/nGjVkyc
  # 3SUGjMn4TlzqMU99STRP+a48TLCVhA==
  # =kDut
  # -----END PGP SIGNATURE-----
  # gpg: Signature made Fri 09 Aug 2024 07:49:05 AM AEST
  # gpg:                using RSA key 71C2CC22B1C4602927D2F3AAA7A16B4A2527436A
  # gpg: Good signature from "Eric Blake <eblake@redhat.com>" [full]
  # gpg:                 aka "Eric Blake (Free Software Programmer) <ebb9@byu.net>" [full]
  # gpg:                 aka "[jpeg image of size 6874]" [full]

  * tag 'pull-nbd-2024-08-08' of https://repo.or.cz/qemu/ericb:
    nbd/server: CVE-2024-7409: Close stray clients at server-stop
    nbd/server: CVE-2024-7409: Drop non-negotiating clients
    nbd/server: CVE-2024-7409: Cap default max-connections to 100
    nbd/server: Plumb in new args to nbd_client_add()
    nbd: Minor style and typo fixes

  Signed-off-by: Richard Henderson <richard.henderson@linaro.org>
  0f397dcfecc9211d12c2c720c01eb32f0eaa7d23:Merge tag 'pull-nbd-2024-08-08' of https://repo.or.cz/qemu/ericb into staging

  NBD patches for 2024-08-08

  - plug CVE-2024-7409, a DoS attack exploiting nbd-server-stop

  # -----BEGIN PGP SIGNATURE-----
  #
  # iQEzBAABCAAdFiEEccLMIrHEYCkn0vOqp6FrSiUnQ2oFAma1PVEACgkQp6FrSiUn
  # Q2qdHQf/dMydqNcPYnwEI238APyljpNvHNq6p9TYb0l5aVWisXHRlhFWM117hH7T
  # Aq2KUgS5ppiEpw8mxa6/OaDa74VpMGyEPgn9w6o7T1xjVBVzpMxOKp5wFa8uICLj
  # mFMYXtj9i0Rb+z0iZ+X+CqIV2Wy/FyV00Wr9T4HW94IV/9EK1sWvZvfyGWyxYyBZ
  # XKTQV1Co3HYX8gfq7E88SgS064DnHjtRy2no4lwNFkBbVQCSbqwbK63TRPi7kEyC
  # DmSLdHCdsD7Ev9kMZ6uNJS5T/9t7hjO5mWJckLt/cXOjHgL7GkoisLH8/nGjVkyc
  # 3SUGjMn4TlzqMU99STRP+a48TLCVhA==
  # =kDut
  # -----END PGP SIGNATURE-----
  # gpg: Signature made Fri 09 Aug 2024 07:49:05 AM AEST
  # gpg:                using RSA key 71C2CC22B1C4602927D2F3AAA7A16B4A2527436A
  # gpg: Good signature from "Eric Blake <eblake@redhat.com>" [full]
  # gpg:                 aka "Eric Blake (Free Software Programmer) <ebb9@byu.net>" [full]
  # gpg:                 aka "[jpeg image of size 6874]" [full]

  * tag 'pull-nbd-2024-08-08' of https://repo.or.cz/qemu/ericb:
    nbd/server: CVE-2024-7409: Close stray clients at server-stop
    nbd/server: CVE-2024-7409: Drop non-negotiating clients
    nbd/server: CVE-2024-7409: Cap default max-connections to 100
    nbd/server: Plumb in new args to nbd_client_add()
    nbd: Minor style and typo fixes

  Signed-off-by: Richard Henderson <richard.henderson@linaro.org>
  3e7ef738c8462c45043a1d39f702a0990406a3b3:nbd/server: CVE-2024-7409: Close stray clients at server-stop

  A malicious client can attempt to connect to an NBD server, and then
  intentionally delay progress in the handshake, including if it does
  not know the TLS secrets.  Although the previous two patches reduce
  this behavior by capping the default max-connections parameter and
  killing slow clients, they did not eliminate the possibility of a
  client waiting to close the socket until after the QMP nbd-server-stop
  command is executed, at which point qemu would SEGV when trying to
  dereference the NULL nbd_server global which is no longer present.
  This amounts to a denial of service attack.  Worse, if another NBD
  server is started before the malicious client disconnects, I cannot
  rule out additional adverse effects when the old client interferes
  with the connection count of the new server (although the most likely
  is a crash due to an assertion failure when checking
  nbd_server->connections > 0).

  For environments without this patch, the CVE can be mitigated by
  ensuring (such as via a firewall) that only trusted clients can
  connect to an NBD server.  Note that using frameworks like libvirt
  that ensure that TLS is used and that nbd-server-stop is not executed
  while any trusted clients are still connected will only help if there
  is also no possibility for an untrusted client to open a connection
  but then stall on the NBD handshake.

  Given the previous patches, it would be possible to guarantee that no
  clients remain connected by having nbd-server-stop sleep for longer
  than the default handshake deadline before finally freeing the global
  nbd_server object, but that could make QMP non-responsive for a long
  time.  So intead, this patch fixes the problem by tracking all client
  sockets opened while the server is running, and forcefully closing any
  such sockets remaining without a completed handshake at the time of
  nbd-server-stop, then waiting until the coroutines servicing those
  sockets notice the state change.  nbd-server-stop now has a second
  AIO_WAIT_WHILE_UNLOCKED (the first is indirectly through the
  blk_exp_close_all_type() that disconnects all clients that completed
  handshakes), but forced socket shutdown is enough to progress the
  coroutines and quickly tear down all clients before the server is
  freed, thus finally fixing the CVE.

  This patch relies heavily on the fact that nbd/server.c guarantees
  that it only calls nbd_blockdev_client_closed() from the main loop
  (see the assertion in nbd_client_put() and the hoops used in
  nbd_client_put_nonzero() to achieve that); if we did not have that
  guarantee, we would also need a mutex protecting our accesses of the
  list of connections to survive re-entrancy from independent iothreads.

  Although I did not actually try to test old builds, it looks like this
  problem has existed since at least commit 862172f45c (v2.12.0, 2017) -
  even back when that patch started using a QIONetListener to handle
  listening on multiple sockets, nbd_server_free() was already unaware
  that the nbd_blockdev_client_closed callback can be reached later by a
  client thread that has not completed handshakes (and therefore the
  client's socket never got added to the list closed in
  nbd_export_close_all), despite that patch intentionally tearing down
  the QIONetListener to prevent new clients.

  Reported-by: Alexander Ivanov <alexander.ivanov@virtuozzo.com>
  Fixes: CVE-2024-7409
  CC: qemu-stable@nongnu.org
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-14-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  3e7ef738c8462c45043a1d39f702a0990406a3b3:nbd/server: CVE-2024-7409: Close stray clients at server-stop

  A malicious client can attempt to connect to an NBD server, and then
  intentionally delay progress in the handshake, including if it does
  not know the TLS secrets.  Although the previous two patches reduce
  this behavior by capping the default max-connections parameter and
  killing slow clients, they did not eliminate the possibility of a
  client waiting to close the socket until after the QMP nbd-server-stop
  command is executed, at which point qemu would SEGV when trying to
  dereference the NULL nbd_server global which is no longer present.
  This amounts to a denial of service attack.  Worse, if another NBD
  server is started before the malicious client disconnects, I cannot
  rule out additional adverse effects when the old client interferes
  with the connection count of the new server (although the most likely
  is a crash due to an assertion failure when checking
  nbd_server->connections > 0).

  For environments without this patch, the CVE can be mitigated by
  ensuring (such as via a firewall) that only trusted clients can
  connect to an NBD server.  Note that using frameworks like libvirt
  that ensure that TLS is used and that nbd-server-stop is not executed
  while any trusted clients are still connected will only help if there
  is also no possibility for an untrusted client to open a connection
  but then stall on the NBD handshake.

  Given the previous patches, it would be possible to guarantee that no
  clients remain connected by having nbd-server-stop sleep for longer
  than the default handshake deadline before finally freeing the global
  nbd_server object, but that could make QMP non-responsive for a long
  time.  So intead, this patch fixes the problem by tracking all client
  sockets opened while the server is running, and forcefully closing any
  such sockets remaining without a completed handshake at the time of
  nbd-server-stop, then waiting until the coroutines servicing those
  sockets notice the state change.  nbd-server-stop now has a second
  AIO_WAIT_WHILE_UNLOCKED (the first is indirectly through the
  blk_exp_close_all_type() that disconnects all clients that completed
  handshakes), but forced socket shutdown is enough to progress the
  coroutines and quickly tear down all clients before the server is
  freed, thus finally fixing the CVE.

  This patch relies heavily on the fact that nbd/server.c guarantees
  that it only calls nbd_blockdev_client_closed() from the main loop
  (see the assertion in nbd_client_put() and the hoops used in
  nbd_client_put_nonzero() to achieve that); if we did not have that
  guarantee, we would also need a mutex protecting our accesses of the
  list of connections to survive re-entrancy from independent iothreads.

  Although I did not actually try to test old builds, it looks like this
  problem has existed since at least commit 862172f45c (v2.12.0, 2017) -
  even back when that patch started using a QIONetListener to handle
  listening on multiple sockets, nbd_server_free() was already unaware
  that the nbd_blockdev_client_closed callback can be reached later by a
  client thread that has not completed handshakes (and therefore the
  client's socket never got added to the list closed in
  nbd_export_close_all), despite that patch intentionally tearing down
  the QIONetListener to prevent new clients.

  Reported-by: Alexander Ivanov <alexander.ivanov@virtuozzo.com>
  Fixes: CVE-2024-7409
  CC: qemu-stable@nongnu.org
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-14-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  b9b72cb3ce15b693148bd09cef7e50110566d8a0:nbd/server: CVE-2024-7409: Drop non-negotiating clients

  A client that opens a socket but does not negotiate is merely hogging
  qemu's resources (an open fd and a small amount of memory); and a
  malicious client that can access the port where NBD is listening can
  attempt a denial of service attack by intentionally opening and
  abandoning lots of unfinished connections.  The previous patch put a
  default bound on the number of such ongoing connections, but once that
  limit is hit, no more clients can connect (including legitimate ones).
  The solution is to insist that clients complete handshake within a
  reasonable time limit, defaulting to 10 seconds.  A client that has
  not successfully completed NBD_OPT_GO by then (including the case of
  where the client didn't know TLS credentials to even reach the point
  of NBD_OPT_GO) is wasting our time and does not deserve to stay
  connected.  Later patches will allow fine-tuning the limit away from
  the default value (including disabling it for doing integration
  testing of the handshake process itself).

  Note that this patch in isolation actually makes it more likely to see
  qemu SEGV after nbd-server-stop, as any client socket still connected
  when the server shuts down will now be closed after 10 seconds rather
  than at the client's whims.  That will be addressed in the next patch.

  For a demo of this patch in action:
  $ qemu-nbd -f raw -r -t -e 10 file &
  $ nbdsh --opt-mode -c '
  H = list()
  for i in range(20):
    print(i)
    H.insert(i, nbd.NBD())
    H[i].set_opt_mode(True)
    H[i].connect_uri("nbd://localhost")
  '
  $ kill $!

  where later connections get to start progressing once earlier ones are
  forcefully dropped for taking too long, rather than hanging.

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-13-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [eblake: rebase to changes earlier in series, reduce scope of timer]
  Signed-off-by: Eric Blake <eblake@redhat.com>
  c8a76dbd90c2f48df89b75bef74917f90a59b623:nbd/server: CVE-2024-7409: Cap default max-connections to 100

  Allowing an unlimited number of clients to any web service is a recipe
  for a rudimentary denial of service attack: the client merely needs to
  open lots of sockets without closing them, until qemu no longer has
  any more fds available to allocate.

  For qemu-nbd, we default to allowing only 1 connection unless more are
  explicitly asked for (-e or --shared); this was historically picked as
  a nice default (without an explicit -t, a non-persistent qemu-nbd goes
  away after a client disconnects, without needing any additional
  follow-up commands), and we are not going to change that interface now
  (besides, someday we want to point people towards qemu-storage-daemon
  instead of qemu-nbd).

  But for qemu proper, and the newer qemu-storage-daemon, the QMP
  nbd-server-start command has historically had a default of unlimited
  number of connections, in part because unlike qemu-nbd it is
  inherently persistent until nbd-server-stop.  Allowing multiple client
  sockets is particularly useful for clients that can take advantage of
  MULTI_CONN (creating parallel sockets to increase throughput),
  although known clients that do so (such as libnbd's nbdcopy) typically
  use only 8 or 16 connections (the benefits of scaling diminish once
  more sockets are competing for kernel attention).  Picking a number
  large enough for typical use cases, but not unlimited, makes it
  slightly harder for a malicious client to perform a denial of service
  merely by opening lots of connections withot progressing through the
  handshake.

  This change does not eliminate CVE-2024-7409 on its own, but reduces
  the chance for fd exhaustion or unlimited memory usage as an attack
  surface.  On the other hand, by itself, it makes it more obvious that
  with a finite limit, we have the problem of an unauthenticated client
  holding 100 fds opened as a way to block out a legitimate client from
  being able to connect; thus, later patches will further add timeouts
  to reject clients that are not making progress.

  This is an INTENTIONAL change in behavior, and will break any client
  of nbd-server-start that was not passing an explicit max-connections
  parameter, yet expects more than 100 simultaneous connections.  We are
  not aware of any such client (as stated above, most clients aware of
  MULTI_CONN get by just fine on 8 or 16 connections, and probably cope
  with later connections failing by relying on the earlier connections;
  libvirt has not yet been passing max-connections, but generally
  creates NBD servers with the intent for a single client for the sake
  of live storage migration; meanwhile, the KubeSAN project anticipates
  a large cluster sharing multiple clients [up to 8 per node, and up to
  100 nodes in a cluster], but it currently uses qemu-nbd with an
  explicit --shared=0 rather than qemu-storage-daemon with
  nbd-server-start).

  We considered using a deprecation period (declare that omitting
  max-parameters is deprecated, and make it mandatory in 3 releases -
  then we don't need to pick an arbitrary default); that has zero risk
  of breaking any apps that accidentally depended on more than 100
  connections, and where such breakage might not be noticed under unit
  testing but only under the larger loads of production usage.  But it
  does not close the denial-of-service hole until far into the future,
  and requires all apps to change to add the parameter even if 100 was
  good enough.  It also has a drawback that any app (like libvirt) that
  is accidentally relying on an unlimited default should seriously
  consider their own CVE now, at which point they are going to change to
  pass explicit max-connections sooner than waiting for 3 qemu releases.
  Finally, if our changed default breaks an app, that app can always
  pass in an explicit max-parameters with a larger value.

  It is also intentional that the HMP interface to nbd-server-start is
  not changed to expose max-connections (any client needing to fine-tune
  things should be using QMP).

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-12-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [ericb: Expand commit message to summarize Dan's argument for why we
  break corner-case back-compat behavior without a deprecation period]
  Signed-off-by: Eric Blake <eblake@redhat.com>
  c8a76dbd90c2f48df89b75bef74917f90a59b623:nbd/server: CVE-2024-7409: Cap default max-connections to 100

  Allowing an unlimited number of clients to any web service is a recipe
  for a rudimentary denial of service attack: the client merely needs to
  open lots of sockets without closing them, until qemu no longer has
  any more fds available to allocate.

  For qemu-nbd, we default to allowing only 1 connection unless more are
  explicitly asked for (-e or --shared); this was historically picked as
  a nice default (without an explicit -t, a non-persistent qemu-nbd goes
  away after a client disconnects, without needing any additional
  follow-up commands), and we are not going to change that interface now
  (besides, someday we want to point people towards qemu-storage-daemon
  instead of qemu-nbd).

  But for qemu proper, and the newer qemu-storage-daemon, the QMP
  nbd-server-start command has historically had a default of unlimited
  number of connections, in part because unlike qemu-nbd it is
  inherently persistent until nbd-server-stop.  Allowing multiple client
  sockets is particularly useful for clients that can take advantage of
  MULTI_CONN (creating parallel sockets to increase throughput),
  although known clients that do so (such as libnbd's nbdcopy) typically
  use only 8 or 16 connections (the benefits of scaling diminish once
  more sockets are competing for kernel attention).  Picking a number
  large enough for typical use cases, but not unlimited, makes it
  slightly harder for a malicious client to perform a denial of service
  merely by opening lots of connections withot progressing through the
  handshake.

  This change does not eliminate CVE-2024-7409 on its own, but reduces
  the chance for fd exhaustion or unlimited memory usage as an attack
  surface.  On the other hand, by itself, it makes it more obvious that
  with a finite limit, we have the problem of an unauthenticated client
  holding 100 fds opened as a way to block out a legitimate client from
  being able to connect; thus, later patches will further add timeouts
  to reject clients that are not making progress.

  This is an INTENTIONAL change in behavior, and will break any client
  of nbd-server-start that was not passing an explicit max-connections
  parameter, yet expects more than 100 simultaneous connections.  We are
  not aware of any such client (as stated above, most clients aware of
  MULTI_CONN get by just fine on 8 or 16 connections, and probably cope
  with later connections failing by relying on the earlier connections;
  libvirt has not yet been passing max-connections, but generally
  creates NBD servers with the intent for a single client for the sake
  of live storage migration; meanwhile, the KubeSAN project anticipates
  a large cluster sharing multiple clients [up to 8 per node, and up to
  100 nodes in a cluster], but it currently uses qemu-nbd with an
  explicit --shared=0 rather than qemu-storage-daemon with
  nbd-server-start).

  We considered using a deprecation period (declare that omitting
  max-parameters is deprecated, and make it mandatory in 3 releases -
  then we don't need to pick an arbitrary default); that has zero risk
  of breaking any apps that accidentally depended on more than 100
  connections, and where such breakage might not be noticed under unit
  testing but only under the larger loads of production usage.  But it
  does not close the denial-of-service hole until far into the future,
  and requires all apps to change to add the parameter even if 100 was
  good enough.  It also has a drawback that any app (like libvirt) that
  is accidentally relying on an unlimited default should seriously
  consider their own CVE now, at which point they are going to change to
  pass explicit max-connections sooner than waiting for 3 qemu releases.
  Finally, if our changed default breaks an app, that app can always
  pass in an explicit max-parameters with a larger value.

  It is also intentional that the HMP interface to nbd-server-start is
  not changed to expose max-connections (any client needing to fine-tune
  things should be using QMP).

  Suggested-by: Daniel P. Berrangé <berrange@redhat.com>
  Signed-off-by: Eric Blake <eblake@redhat.com>
  Message-ID: <20240807174943.771624-12-eblake@redhat.com>
  Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
  [ericb: Expand commit message to summarize Dan's argument for why we
  break corner-case back-compat behavior without a deprecation period]
  Signed-off-by: Eric Blake <eblake@redhat.com>
impacted_packages:
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 3066a540b52fc3e1e223c9e2b344b047500bc37e
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 420c6c29801a6f161195bed6d156aad91ee23650
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 0fe466df932d23fd8881bba1ab2c1798c09884c1
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 7d31776d7f747cbfb83ecf0366878896f659361e
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: afaee42f777bc359db95f692804f7fc7e12c0c02
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 9bdb40b2d474950d9f08b106c0968474bd5f0c30
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: fe547837bf9d227a1abc737ffd7aee4caa0e405d
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 3874f5f73c441c52f1c699c848d463b0eda01e4c
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 9df5c133c9435e3653c6f82e34f891959089f219
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: dbf946c25112f682ff783240a0fb6130805e41c4
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 0f397dcfecc9211d12c2c720c01eb32f0eaa7d23
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: bb0356daf0e3275f762179f22031dcdc27daa46e
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: f4c1adb228e5d60e6e372c3efd6442c3a69aeb81
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: c8a76dbd90c2f48df89b75bef74917f90a59b623
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: b9b72cb3ce15b693148bd09cef7e50110566d8a0
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 3e7ef738c8462c45043a1d39f702a0990406a3b3
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: e2e6520689b0ebbce43ce9bfd723e98872ff9b3d
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 73a5a92259962ea7a1bea7c3105438712e88851c
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://gitlab.com/qemu-project/qemu
    reference_type: commit
    reference_id: 91c6438caffc880e999a7312825479685d659b44
