advisory_id: CVE-2023-6683
datasource_id: collect_qemu_fix_commits/CVE-2023-6683
datasource_url: https://gitlab.com/qemu-project/qemu
aliases: []
summary: |
  7ff0d4d184a83ac54b917c5af577e7a32e6a6f3e:ui/clipboard: add asserts for update and request

  Should an issue like CVE-2023-6683 ever appear again in the future,
  it will be more obvious which assumption was violated.

  Suggested-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Signed-off-by: Fiona Ebner <f.ebner@proxmox.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-ID: <20240124105749.204610-2-f.ebner@proxmox.com>
  (cherry picked from commit 9c416582611b7495bdddb4c5456c7acb64b78938)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  ee316aafa5f6d4c8fa3ec4e58471e8c02a8696f6:ui/clipboard: add asserts for update and request

  Should an issue like CVE-2023-6683 ever appear again in the future,
  it will be more obvious which assumption was violated.

  Suggested-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Signed-off-by: Fiona Ebner <f.ebner@proxmox.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-ID: <20240124105749.204610-2-f.ebner@proxmox.com>
  (cherry picked from commit 9c416582611b7495bdddb4c5456c7acb64b78938)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  d8d6e6b9043a09f70d914c81dcdd4f8f62cf55f6:ui/clipboard: mark type as not available when there is no data

  With VNC, a client can send a non-extended VNC_MSG_CLIENT_CUT_TEXT
  message with len=0. In qemu_clipboard_set_data(), the clipboard info
  will be updated setting data to NULL (because g_memdup(data, size)
  returns NULL when size is 0). If the client does not set the
  VNC_ENCODING_CLIPBOARD_EXT feature when setting up the encodings, then
  the 'request' callback for the clipboard peer is not initialized.
  Later, because data is NULL, qemu_clipboard_request() can be reached
  via vdagent_chr_write() and vdagent_clipboard_recv_request() and
  there, the clipboard owner's 'request' callback will be attempted to
  be called, but that is a NULL pointer.

  In particular, this can happen when using the KRDC (22.12.3) VNC
  client.

  Another scenario leading to the same issue is with two clients (say
  noVNC and KRDC):

  The noVNC client sets the extension VNC_FEATURE_CLIPBOARD_EXT and
  initializes its cbpeer.

  The KRDC client does not, but triggers a vnc_client_cut_text() (note
  it's not the _ext variant)). There, a new clipboard info with it as
  the 'owner' is created and via qemu_clipboard_set_data() is called,
  which in turn calls qemu_clipboard_update() with that info.

  In qemu_clipboard_update(), the notifier for the noVNC client will be
  called, i.e. vnc_clipboard_notify() and also set vs->cbinfo for the
  noVNC client. The 'owner' in that clipboard info is the clipboard peer
  for the KRDC client, which did not initialize the 'request' function.
  That sounds correct to me, it is the owner of that clipboard info.

  Then when noVNC sends a VNC_MSG_CLIENT_CUT_TEXT message (it did set
  the VNC_FEATURE_CLIPBOARD_EXT feature correctly, so a check for it
  passes), that clipboard info is passed to qemu_clipboard_request() and
  the original segfault still happens.

  Fix the issue by handling updates with size 0 differently. In
  particular, mark in the clipboard info that the type is not available.

  While at it, switch to g_memdup2(), because g_memdup() is deprecated.

  Cc: qemu-stable@nongnu.org
  Fixes: CVE-2023-6683
  Reported-by: Markus Frank <m.frank@proxmox.com>
  Suggested-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Signed-off-by: Fiona Ebner <f.ebner@proxmox.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Tested-by: Markus Frank <m.frank@proxmox.com>
  Message-ID: <20240124105749.204610-1-f.ebner@proxmox.com>
  (cherry picked from commit 405484b29f6548c7b86549b0f961b906337aa68a)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  480a6adc83a7bbc84bfe67229e084603dc061824:ui/clipboard: mark type as not available when there is no data

  With VNC, a client can send a non-extended VNC_MSG_CLIENT_CUT_TEXT
  message with len=0. In qemu_clipboard_set_data(), the clipboard info
  will be updated setting data to NULL (because g_memdup(data, size)
  returns NULL when size is 0). If the client does not set the
  VNC_ENCODING_CLIPBOARD_EXT feature when setting up the encodings, then
  the 'request' callback for the clipboard peer is not initialized.
  Later, because data is NULL, qemu_clipboard_request() can be reached
  via vdagent_chr_write() and vdagent_clipboard_recv_request() and
  there, the clipboard owner's 'request' callback will be attempted to
  be called, but that is a NULL pointer.

  In particular, this can happen when using the KRDC (22.12.3) VNC
  client.

  Another scenario leading to the same issue is with two clients (say
  noVNC and KRDC):

  The noVNC client sets the extension VNC_FEATURE_CLIPBOARD_EXT and
  initializes its cbpeer.

  The KRDC client does not, but triggers a vnc_client_cut_text() (note
  it's not the _ext variant)). There, a new clipboard info with it as
  the 'owner' is created and via qemu_clipboard_set_data() is called,
  which in turn calls qemu_clipboard_update() with that info.

  In qemu_clipboard_update(), the notifier for the noVNC client will be
  called, i.e. vnc_clipboard_notify() and also set vs->cbinfo for the
  noVNC client. The 'owner' in that clipboard info is the clipboard peer
  for the KRDC client, which did not initialize the 'request' function.
  That sounds correct to me, it is the owner of that clipboard info.

  Then when noVNC sends a VNC_MSG_CLIENT_CUT_TEXT message (it did set
  the VNC_FEATURE_CLIPBOARD_EXT feature correctly, so a check for it
  passes), that clipboard info is passed to qemu_clipboard_request() and
  the original segfault still happens.

  Fix the issue by handling updates with size 0 differently. In
  particular, mark in the clipboard info that the type is not available.

  While at it, switch to g_memdup2(), because g_memdup() is deprecated.

  Cc: qemu-stable@nongnu.org
  Fixes: CVE-2023-6683
  Reported-by: Markus Frank <m.frank@proxmox.com>
  Suggested-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Signed-off-by: Fiona Ebner <f.ebner@proxmox.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Tested-by: Markus Frank <m.frank@proxmox.com>
  Message-ID: <20240124105749.204610-1-f.ebner@proxmox.com>
  (cherry picked from commit 405484b29f6548c7b86549b0f961b906337aa68a)
  Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
  9c416582611b7495bdddb4c5456c7acb64b78938:ui/clipboard: add asserts for update and request

  Should an issue like CVE-2023-6683 ever appear again in the future,
  it will be more obvious which assumption was violated.

  Suggested-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Signed-off-by: Fiona Ebner <f.ebner@proxmox.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Message-ID: <20240124105749.204610-2-f.ebner@proxmox.com>
  405484b29f6548c7b86549b0f961b906337aa68a:ui/clipboard: mark type as not available when there is no data

  With VNC, a client can send a non-extended VNC_MSG_CLIENT_CUT_TEXT
  message with len=0. In qemu_clipboard_set_data(), the clipboard info
  will be updated setting data to NULL (because g_memdup(data, size)
  returns NULL when size is 0). If the client does not set the
  VNC_ENCODING_CLIPBOARD_EXT feature when setting up the encodings, then
  the 'request' callback for the clipboard peer is not initialized.
  Later, because data is NULL, qemu_clipboard_request() can be reached
  via vdagent_chr_write() and vdagent_clipboard_recv_request() and
  there, the clipboard owner's 'request' callback will be attempted to
  be called, but that is a NULL pointer.

  In particular, this can happen when using the KRDC (22.12.3) VNC
  client.

  Another scenario leading to the same issue is with two clients (say
  noVNC and KRDC):

  The noVNC client sets the extension VNC_FEATURE_CLIPBOARD_EXT and
  initializes its cbpeer.

  The KRDC client does not, but triggers a vnc_client_cut_text() (note
  it's not the _ext variant)). There, a new clipboard info with it as
  the 'owner' is created and via qemu_clipboard_set_data() is called,
  which in turn calls qemu_clipboard_update() with that info.

  In qemu_clipboard_update(), the notifier for the noVNC client will be
  called, i.e. vnc_clipboard_notify() and also set vs->cbinfo for the
  noVNC client. The 'owner' in that clipboard info is the clipboard peer
  for the KRDC client, which did not initialize the 'request' function.
  That sounds correct to me, it is the owner of that clipboard info.

  Then when noVNC sends a VNC_MSG_CLIENT_CUT_TEXT message (it did set
  the VNC_FEATURE_CLIPBOARD_EXT feature correctly, so a check for it
  passes), that clipboard info is passed to qemu_clipboard_request() and
  the original segfault still happens.

  Fix the issue by handling updates with size 0 differently. In
  particular, mark in the clipboard info that the type is not available.

  While at it, switch to g_memdup2(), because g_memdup() is deprecated.

  Cc: qemu-stable@nongnu.org
  Fixes: CVE-2023-6683
  Reported-by: Markus Frank <m.frank@proxmox.com>
  Suggested-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Signed-off-by: Fiona Ebner <f.ebner@proxmox.com>
  Reviewed-by: Marc-André Lureau <marcandre.lureau@redhat.com>
  Tested-by: Markus Frank <m.frank@proxmox.com>
  Message-ID: <20240124105749.204610-1-f.ebner@proxmox.com>
impacted_packages:
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 7ff0d4d184a83ac54b917c5af577e7a32e6a6f3e
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 9c416582611b7495bdddb4c5456c7acb64b78938
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 480a6adc83a7bbc84bfe67229e084603dc061824
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: ee316aafa5f6d4c8fa3ec4e58471e8c02a8696f6
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: d8d6e6b9043a09f70d914c81dcdd4f8f62cf55f6
    introduced_in_commits: []
  - purl: pkg:gitlab/qemu-project/qemu
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://gitlab.com/qemu-project/qemu
        commit: 405484b29f6548c7b86549b0f961b906337aa68a
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://gitlab.com/qemu-project/qemu
    reference_type: commit
    reference_id: 91c6438caffc880e999a7312825479685d659b44
