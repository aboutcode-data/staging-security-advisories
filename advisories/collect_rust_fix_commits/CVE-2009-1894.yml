advisory_id: CVE-2009-1894
datasource_id: collect_rust_fix_commits/CVE-2009-1894
datasource_url: https://github.com/rust-lang/rust
aliases: []
summary: |
  b16d243cac1a9512c352a78e24cb09088b88428b:Rollup merge of #150828 - sourcefrog:doc-exe-security, r=cuviper

  Improved security section in rustdoc for `current_exe`

  A few improvements to the security section of the docs about `current_exe`

  0. The explanatory link <https://vulners.com/securityvulns/SECURITYVULNS:DOC:22183> is ~~broken~~ not directly very helpful in understanding the risk.
  1. It basically previously says to never trust the result, which is IMO too pessimistic to be helpful. It's worth understanding the behavior but if you have a use case to re-exec the current program, which is not uncommon, this is a reasonable way to do it.
  2. The particular risk is about setuid/setgid processes that shouldn't fully trust the user that spawned them.
  3. IMO the most important risk with this function is that the invoker can control argv and PATH, so I made this more explicit. (Many unixes, including Linux, don't rely on them in the implementation, but some do.)
  4. The previous text about TOCTOU and races is IMO not really coherent: if an attacker can write to the location where you're going to re-exec, they can fundamentally control what program is executed. They don't need to race with your execution of current_exe, and there is no up-front check.
  5. Briefly explain the pattern of CVE-2009-1894: on Linux, depending on system configuration, an attacker who can create hardlinks to the executable can potentially control `/proc/self/exe`. On modern Linux this should normally require permission to write to the executable.

  I did some web research for "argv0 vulnerability" and similar terms and didn't find anything else we should be documenting here. (There are issues about argc=0 but those should be prevented by memory safety in Rust.)

  I found what the link seemed to be pointing to in <https://vulners.com/cve/CVE-2009-1894>, which talks about confusing a setuid program by creating a hardlink to its exe. I think this is in very particular circumstances something people should still be concerned about: a setuid program on a machine with `fs.protected_hardlinks = 0`. I don't think this justifies warning people not to use the function at all.

  cc @mgeisler
  b16d243cac1a9512c352a78e24cb09088b88428b:Rollup merge of #150828 - sourcefrog:doc-exe-security, r=cuviper

  Improved security section in rustdoc for `current_exe`

  A few improvements to the security section of the docs about `current_exe`

  0. The explanatory link <https://vulners.com/securityvulns/SECURITYVULNS:DOC:22183> is ~~broken~~ not directly very helpful in understanding the risk.
  1. It basically previously says to never trust the result, which is IMO too pessimistic to be helpful. It's worth understanding the behavior but if you have a use case to re-exec the current program, which is not uncommon, this is a reasonable way to do it.
  2. The particular risk is about setuid/setgid processes that shouldn't fully trust the user that spawned them.
  3. IMO the most important risk with this function is that the invoker can control argv and PATH, so I made this more explicit. (Many unixes, including Linux, don't rely on them in the implementation, but some do.)
  4. The previous text about TOCTOU and races is IMO not really coherent: if an attacker can write to the location where you're going to re-exec, they can fundamentally control what program is executed. They don't need to race with your execution of current_exe, and there is no up-front check.
  5. Briefly explain the pattern of CVE-2009-1894: on Linux, depending on system configuration, an attacker who can create hardlinks to the executable can potentially control `/proc/self/exe`. On modern Linux this should normally require permission to write to the executable.

  I did some web research for "argv0 vulnerability" and similar terms and didn't find anything else we should be documenting here. (There are issues about argc=0 but those should be prevented by memory safety in Rust.)

  I found what the link seemed to be pointing to in <https://vulners.com/cve/CVE-2009-1894>, which talks about confusing a setuid program by creating a hardlink to its exe. I think this is in very particular circumstances something people should still be concerned about: a setuid program on a machine with `fs.protected_hardlinks = 0`. I don't think this justifies warning people not to use the function at all.

  cc @mgeisler
impacted_packages:
  - purl: pkg:github/rust-lang/rust
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/rust-lang/rust
        commit: b16d243cac1a9512c352a78e24cb09088b88428b
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/rust-lang/rust/tree/b16d243cac1a9512c352a78e24cb09088b88428b
    reference_type: commit
    reference_id: b16d243cac1a9512c352a78e24cb09088b88428b
