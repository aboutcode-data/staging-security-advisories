advisory_id: CVE-2010-2240
datasource_id: collect_rust_fix_commits/CVE-2010-2240
datasource_url: https://github.com/rust-lang/rust
aliases: []
summary: |
  4b6af9704ae183cb76027624f3f8a5d51eb7dc26:Auto merge of #43072 - cuviper:linux-stack-guard, r=alexcrichton

  Skip the main thread's manual stack guard on Linux

  Linux doesn't allocate the whole stack right away, and the kernel has its own stack-guard mechanism to fault when growing too close to an existing mapping.  If we map our own guard, then the kernel starts enforcing a rather large gap above that, rendering much of the possible stack space useless.

  Instead, we'll just note where we expect rlimit to start faulting, so our handler can report "stack overflow", and trust that the kernel's own stack guard will work.

  Fixes #43052.
  r? @alexcrichton

  ### Kernel compatibility:

  Strictly speaking, Rust claims support for Linux kernels >= 2.6.18, and stack guards were only added to mainline in 2.6.36 for [CVE-2010-2240].  But since that vulnerability was so severe, the guards were backported to many stable branches, and Red Hat patched this all the way back to RHEL3's 2.4.21!  I think it's reasonable for us to assume that any *supportable* kernel should have these stack guards.

  At that time, the kernel only enforced one page of padding between the stack and other mappings, but thanks to [Stack Clash] that padding is now much larger, causing #43052.  The kernel side of those fixes are in [CVE-2017-1000364], which Red Hat has backported to at least RHEL5's 2.6.18 so far.

  [CVE-2010-2240]: https://access.redhat.com/security/cve/CVE-2010-2240
  [CVE-2017-1000364]: https://access.redhat.com/security/cve/CVE-2017-1000364
  [Stack Clash]: https://access.redhat.com/security/vulnerabilities/stackguard
  4b6af9704ae183cb76027624f3f8a5d51eb7dc26:Auto merge of #43072 - cuviper:linux-stack-guard, r=alexcrichton

  Skip the main thread's manual stack guard on Linux

  Linux doesn't allocate the whole stack right away, and the kernel has its own stack-guard mechanism to fault when growing too close to an existing mapping.  If we map our own guard, then the kernel starts enforcing a rather large gap above that, rendering much of the possible stack space useless.

  Instead, we'll just note where we expect rlimit to start faulting, so our handler can report "stack overflow", and trust that the kernel's own stack guard will work.

  Fixes #43052.
  r? @alexcrichton

  ### Kernel compatibility:

  Strictly speaking, Rust claims support for Linux kernels >= 2.6.18, and stack guards were only added to mainline in 2.6.36 for [CVE-2010-2240].  But since that vulnerability was so severe, the guards were backported to many stable branches, and Red Hat patched this all the way back to RHEL3's 2.4.21!  I think it's reasonable for us to assume that any *supportable* kernel should have these stack guards.

  At that time, the kernel only enforced one page of padding between the stack and other mappings, but thanks to [Stack Clash] that padding is now much larger, causing #43052.  The kernel side of those fixes are in [CVE-2017-1000364], which Red Hat has backported to at least RHEL5's 2.6.18 so far.

  [CVE-2010-2240]: https://access.redhat.com/security/cve/CVE-2010-2240
  [CVE-2017-1000364]: https://access.redhat.com/security/cve/CVE-2017-1000364
  [Stack Clash]: https://access.redhat.com/security/vulnerabilities/stackguard
  4b6af9704ae183cb76027624f3f8a5d51eb7dc26:Auto merge of #43072 - cuviper:linux-stack-guard, r=alexcrichton

  Skip the main thread's manual stack guard on Linux

  Linux doesn't allocate the whole stack right away, and the kernel has its own stack-guard mechanism to fault when growing too close to an existing mapping.  If we map our own guard, then the kernel starts enforcing a rather large gap above that, rendering much of the possible stack space useless.

  Instead, we'll just note where we expect rlimit to start faulting, so our handler can report "stack overflow", and trust that the kernel's own stack guard will work.

  Fixes #43052.
  r? @alexcrichton

  ### Kernel compatibility:

  Strictly speaking, Rust claims support for Linux kernels >= 2.6.18, and stack guards were only added to mainline in 2.6.36 for [CVE-2010-2240].  But since that vulnerability was so severe, the guards were backported to many stable branches, and Red Hat patched this all the way back to RHEL3's 2.4.21!  I think it's reasonable for us to assume that any *supportable* kernel should have these stack guards.

  At that time, the kernel only enforced one page of padding between the stack and other mappings, but thanks to [Stack Clash] that padding is now much larger, causing #43052.  The kernel side of those fixes are in [CVE-2017-1000364], which Red Hat has backported to at least RHEL5's 2.6.18 so far.

  [CVE-2010-2240]: https://access.redhat.com/security/cve/CVE-2010-2240
  [CVE-2017-1000364]: https://access.redhat.com/security/cve/CVE-2017-1000364
  [Stack Clash]: https://access.redhat.com/security/vulnerabilities/stackguard
impacted_packages:
  - purl: pkg:github/rust-lang/rust
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/rust-lang/rust
        commit: 4b6af9704ae183cb76027624f3f8a5d51eb7dc26
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/rust-lang/rust/tree/4b6af9704ae183cb76027624f3f8a5d51eb7dc26
    reference_type: commit
    reference_id: 4b6af9704ae183cb76027624f3f8a5d51eb7dc26
