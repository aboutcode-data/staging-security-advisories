advisory_id: CVE-2023-24534
datasource_id: collect_docker_moby_fix_commits/CVE-2023-24534
datasource_url: https://github.com/moby/moby
aliases: []
summary: |
  9279c41ea5a8633edde7353c90f0000066f2abec:update go to go1.20.3

  go1.20.3 (released 2023-04-04) includes security fixes to the go/parser,
  html/template, mime/multipart, net/http, and net/textproto packages, as well
  as bug fixes to the compiler, the linker, the runtime, and the time package.
  See the Go 1.20.3 milestone on our issue tracker for details:

  https://github.com/golang/go/issues?q=milestone%3AGo1.20.3+label%3ACherryPickApproved

  full diff: https://github.com/golang/go/compare/go1.20.2...go1.20.3

  Further details from the announcement on the mailing list:

  We have just released Go versions 1.20.3 and 1.19.8, minor point releases.
  These minor releases include 4 security fixes following the security policy:

  - go/parser: infinite loop in parsing

    Calling any of the Parse functions on Go source code which contains `//line`
    directives with very large line numbers can cause an infinite loop due to
    integer overflow.
    Thanks to Philippe Antoine (Catena cyber) for reporting this issue.
    This is CVE-2023-24537 and Go issue https://go.dev/issue/59180.

  - html/template: backticks not treated as string delimiters

    Templates did not properly consider backticks (`) as Javascript string
    delimiters, and as such did not escape them as expected. Backticks are
    used, since ES6, for JS template literals. If a template contained a Go
    template action within a Javascript template literal, the contents of the
    action could be used to terminate the literal, injecting arbitrary Javascript
    code into the Go template.

    As ES6 template literals are rather complex, and themselves can do string
    interpolation, we've decided to simply disallow Go template actions from being
    used inside of them (e.g. "var a = {{.}}"), since there is no obviously safe
    way to allow this behavior. This takes the same approach as
    github.com/google/safehtml. Template.Parse will now return an Error when it
    encounters templates like this, with a currently unexported ErrorCode with a
    value of 12. This ErrorCode will be exported in the next major release.

    Users who rely on this behavior can re-enable it using the GODEBUG flag
    jstmpllitinterp=1, with the caveat that backticks will now be escaped. This
    should be used with caution.

    Thanks to Sohom Datta, Manipal Institute of Technology, for reporting this issue.

    This is CVE-2023-24538 and Go issue https://go.dev/issue/59234.

  - net/http, net/textproto: denial of service from excessive memory allocation

    HTTP and MIME header parsing could allocate large amounts of memory, even when
    parsing small inputs.

    Certain unusual patterns of input data could cause the common function used to
    parse HTTP and MIME headers to allocate substantially more memory than
    required to hold the parsed headers. An attacker can exploit this behavior to
    cause an HTTP server to allocate large amounts of memory from a small request,
    potentially leading to memory exhaustion and a denial of service.
    Header parsing now correctly allocates only the memory required to hold parsed
    headers.

    Thanks to Jakob Ackermann (@das7pad) for discovering this issue.

    This is CVE-2023-24534 and Go issue https://go.dev/issue/58975.

  - net/http, net/textproto, mime/multipart: denial of service from excessive resource consumption

    Multipart form parsing can consume large amounts of CPU and memory when
    processing form inputs containing very large numbers of parts. This stems from
    several causes:

    mime/multipart.Reader.ReadForm limits the total memory a parsed multipart form
    can consume. ReadForm could undercount the amount of memory consumed, leading
    it to accept larger inputs than intended. Limiting total memory does not
    account for increased pressure on the garbage collector from large numbers of
    small allocations in forms with many parts. ReadForm could allocate a large
    number of short-lived buffers, further increasing pressure on the garbage
    collector. The combination of these factors can permit an attacker to cause an
    program that parses multipart forms to consume large amounts of CPU and
    memory, potentially resulting in a denial of service. This affects programs
    that use mime/multipart.Reader.ReadForm, as well as form parsing in the
    net/http package with the Request methods FormFile, FormValue,
    ParseMultipartForm, and PostFormValue.

    ReadForm now does a better job of estimating the memory consumption of parsed
    forms, and performs many fewer short-lived allocations.

    In addition, mime/multipart.Reader now imposes the following limits on the
    size of parsed forms:

    Forms parsed with ReadForm may contain no more than 1000 parts. This limit may
    be adjusted with the environment variable GODEBUG=multipartmaxparts=. Form
    parts parsed with NextPart and NextRawPart may contain no more than 10,000
    header fields. In addition, forms parsed with ReadForm may contain no more
    than 10,000 header fields across all parts. This limit may be adjusted with
    the environment variable GODEBUG=multipartmaxheaders=.

    Thanks to Jakob Ackermann for discovering this issue.

    This is CVE-2023-24536 and Go issue https://go.dev/issue/59153.

  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
  (cherry picked from commit f6cc8e3512e0ef882a6f9e49a034d2544aafcd0c)
  Signed-off-by: Cory Snider <csnider@mirantis.com>
  d3e52936c3da962a9bd5ecec242130d5790ee88e:[23.0] update go to go1.19.8

  go1.19.8 (released 2023-04-04) includes security fixes to the go/parser,
  html/template, mime/multipart, net/http, and net/textproto packages, as well as
  bug fixes to the linker, the runtime, and the time package. See the Go 1.19.8
  milestone on our issue tracker for details:

  https://github.com/golang/go/issues?q=milestone%3AGo1.19.8+label%3ACherryPickApproved

  full diff: https://github.com/golang/go/compare/go1.19.7...go1.19.8

  Further details from the announcement on the mailing list:

  We have just released Go versions 1.20.3 and 1.19.8, minor point releases.
  These minor releases include 4 security fixes following the security policy:

  - go/parser: infinite loop in parsing

    Calling any of the Parse functions on Go source code which contains `//line`
    directives with very large line numbers can cause an infinite loop due to
    integer overflow.
    Thanks to Philippe Antoine (Catena cyber) for reporting this issue.
    This is CVE-2023-24537 and Go issue https://go.dev/issue/59180.

  - html/template: backticks not treated as string delimiters

    Templates did not properly consider backticks (`) as Javascript string
    delimiters, and as such did not escape them as expected. Backticks are
    used, since ES6, for JS template literals. If a template contained a Go
    template action within a Javascript template literal, the contents of the
    action could be used to terminate the literal, injecting arbitrary Javascript
    code into the Go template.

    As ES6 template literals are rather complex, and themselves can do string
    interpolation, we've decided to simply disallow Go template actions from being
    used inside of them (e.g. "var a = {{.}}"), since there is no obviously safe
    way to allow this behavior. This takes the same approach as
    github.com/google/safehtml. Template.Parse will now return an Error when it
    encounters templates like this, with a currently unexported ErrorCode with a
    value of 12. This ErrorCode will be exported in the next major release.

    Users who rely on this behavior can re-enable it using the GODEBUG flag
    jstmpllitinterp=1, with the caveat that backticks will now be escaped. This
    should be used with caution.

    Thanks to Sohom Datta, Manipal Institute of Technology, for reporting this issue.

    This is CVE-2023-24538 and Go issue https://go.dev/issue/59234.

  - net/http, net/textproto: denial of service from excessive memory allocation

    HTTP and MIME header parsing could allocate large amounts of memory, even when
    parsing small inputs.

    Certain unusual patterns of input data could cause the common function used to
    parse HTTP and MIME headers to allocate substantially more memory than
    required to hold the parsed headers. An attacker can exploit this behavior to
    cause an HTTP server to allocate large amounts of memory from a small request,
    potentially leading to memory exhaustion and a denial of service.
    Header parsing now correctly allocates only the memory required to hold parsed
    headers.

    Thanks to Jakob Ackermann (@das7pad) for discovering this issue.

    This is CVE-2023-24534 and Go issue https://go.dev/issue/58975.

  - net/http, net/textproto, mime/multipart: denial of service from excessive resource consumption

    Multipart form parsing can consume large amounts of CPU and memory when
    processing form inputs containing very large numbers of parts. This stems from
    several causes:

    mime/multipart.Reader.ReadForm limits the total memory a parsed multipart form
    can consume. ReadForm could undercount the amount of memory consumed, leading
    it to accept larger inputs than intended. Limiting total memory does not
    account for increased pressure on the garbage collector from large numbers of
    small allocations in forms with many parts. ReadForm could allocate a large
    number of short-lived buffers, further increasing pressure on the garbage
    collector. The combination of these factors can permit an attacker to cause an
    program that parses multipart forms to consume large amounts of CPU and
    memory, potentially resulting in a denial of service. This affects programs
    that use mime/multipart.Reader.ReadForm, as well as form parsing in the
    net/http package with the Request methods FormFile, FormValue,
    ParseMultipartForm, and PostFormValue.

    ReadForm now does a better job of estimating the memory consumption of parsed
    forms, and performs many fewer short-lived allocations.

    In addition, mime/multipart.Reader now imposes the following limits on the
    size of parsed forms:

    Forms parsed with ReadForm may contain no more than 1000 parts. This limit may
    be adjusted with the environment variable GODEBUG=multipartmaxparts=. Form
    parts parsed with NextPart and NextRawPart may contain no more than 10,000
    header fields. In addition, forms parsed with ReadForm may contain no more
    than 10,000 header fields across all parts. This limit may be adjusted with
    the environment variable GODEBUG=multipartmaxheaders=.

    Thanks to Jakob Ackermann for discovering this issue.

    This is CVE-2023-24536 and Go issue https://go.dev/issue/59153.

  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
  a09b3e9cf9de906438a6300760754fcb087f166a:[20.10] update go to go1.19.8

  go1.19.8 (released 2023-04-04) includes security fixes to the go/parser,
  html/template, mime/multipart, net/http, and net/textproto packages, as well as
  bug fixes to the linker, the runtime, and the time package. See the Go 1.19.8
  milestone on our issue tracker for details:

  https://github.com/golang/go/issues?q=milestone%3AGo1.19.8+label%3ACherryPickApproved

  full diff: https://github.com/golang/go/compare/go1.19.7...go1.19.8

  Further details from the announcement on the mailing list:

  We have just released Go versions 1.20.3 and 1.19.8, minor point releases.
  These minor releases include 4 security fixes following the security policy:

  - go/parser: infinite loop in parsing

    Calling any of the Parse functions on Go source code which contains `//line`
    directives with very large line numbers can cause an infinite loop due to
    integer overflow.
    Thanks to Philippe Antoine (Catena cyber) for reporting this issue.
    This is CVE-2023-24537 and Go issue https://go.dev/issue/59180.

  - html/template: backticks not treated as string delimiters

    Templates did not properly consider backticks (`) as Javascript string
    delimiters, and as such did not escape them as expected. Backticks are
    used, since ES6, for JS template literals. If a template contained a Go
    template action within a Javascript template literal, the contents of the
    action could be used to terminate the literal, injecting arbitrary Javascript
    code into the Go template.

    As ES6 template literals are rather complex, and themselves can do string
    interpolation, we've decided to simply disallow Go template actions from being
    used inside of them (e.g. "var a = {{.}}"), since there is no obviously safe
    way to allow this behavior. This takes the same approach as
    github.com/google/safehtml. Template.Parse will now return an Error when it
    encounters templates like this, with a currently unexported ErrorCode with a
    value of 12. This ErrorCode will be exported in the next major release.

    Users who rely on this behavior can re-enable it using the GODEBUG flag
    jstmpllitinterp=1, with the caveat that backticks will now be escaped. This
    should be used with caution.

    Thanks to Sohom Datta, Manipal Institute of Technology, for reporting this issue.

    This is CVE-2023-24538 and Go issue https://go.dev/issue/59234.

  - net/http, net/textproto: denial of service from excessive memory allocation

    HTTP and MIME header parsing could allocate large amounts of memory, even when
    parsing small inputs.

    Certain unusual patterns of input data could cause the common function used to
    parse HTTP and MIME headers to allocate substantially more memory than
    required to hold the parsed headers. An attacker can exploit this behavior to
    cause an HTTP server to allocate large amounts of memory from a small request,
    potentially leading to memory exhaustion and a denial of service.
    Header parsing now correctly allocates only the memory required to hold parsed
    headers.

    Thanks to Jakob Ackermann (@das7pad) for discovering this issue.

    This is CVE-2023-24534 and Go issue https://go.dev/issue/58975.

  - net/http, net/textproto, mime/multipart: denial of service from excessive resource consumption

    Multipart form parsing can consume large amounts of CPU and memory when
    processing form inputs containing very large numbers of parts. This stems from
    several causes:

    mime/multipart.Reader.ReadForm limits the total memory a parsed multipart form
    can consume. ReadForm could undercount the amount of memory consumed, leading
    it to accept larger inputs than intended. Limiting total memory does not
    account for increased pressure on the garbage collector from large numbers of
    small allocations in forms with many parts. ReadForm could allocate a large
    number of short-lived buffers, further increasing pressure on the garbage
    collector. The combination of these factors can permit an attacker to cause an
    program that parses multipart forms to consume large amounts of CPU and
    memory, potentially resulting in a denial of service. This affects programs
    that use mime/multipart.Reader.ReadForm, as well as form parsing in the
    net/http package with the Request methods FormFile, FormValue,
    ParseMultipartForm, and PostFormValue.

    ReadForm now does a better job of estimating the memory consumption of parsed
    forms, and performs many fewer short-lived allocations.

    In addition, mime/multipart.Reader now imposes the following limits on the
    size of parsed forms:

    Forms parsed with ReadForm may contain no more than 1000 parts. This limit may
    be adjusted with the environment variable GODEBUG=multipartmaxparts=. Form
    parts parsed with NextPart and NextRawPart may contain no more than 10,000
    header fields. In addition, forms parsed with ReadForm may contain no more
    than 10,000 header fields across all parts. This limit may be adjusted with
    the environment variable GODEBUG=multipartmaxheaders=.

    Thanks to Jakob Ackermann for discovering this issue.

    This is CVE-2023-24536 and Go issue https://go.dev/issue/59153.

  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
  f6cc8e3512e0ef882a6f9e49a034d2544aafcd0c:update go to go1.20.3

  go1.20.3 (released 2023-04-04) includes security fixes to the go/parser,
  html/template, mime/multipart, net/http, and net/textproto packages, as well
  as bug fixes to the compiler, the linker, the runtime, and the time package.
  See the Go 1.20.3 milestone on our issue tracker for details:

  https://github.com/golang/go/issues?q=milestone%3AGo1.20.3+label%3ACherryPickApproved

  full diff: https://github.com/golang/go/compare/go1.20.2...go1.20.3

  Further details from the announcement on the mailing list:

  We have just released Go versions 1.20.3 and 1.19.8, minor point releases.
  These minor releases include 4 security fixes following the security policy:

  - go/parser: infinite loop in parsing

    Calling any of the Parse functions on Go source code which contains `//line`
    directives with very large line numbers can cause an infinite loop due to
    integer overflow.
    Thanks to Philippe Antoine (Catena cyber) for reporting this issue.
    This is CVE-2023-24537 and Go issue https://go.dev/issue/59180.

  - html/template: backticks not treated as string delimiters

    Templates did not properly consider backticks (`) as Javascript string
    delimiters, and as such did not escape them as expected. Backticks are
    used, since ES6, for JS template literals. If a template contained a Go
    template action within a Javascript template literal, the contents of the
    action could be used to terminate the literal, injecting arbitrary Javascript
    code into the Go template.

    As ES6 template literals are rather complex, and themselves can do string
    interpolation, we've decided to simply disallow Go template actions from being
    used inside of them (e.g. "var a = {{.}}"), since there is no obviously safe
    way to allow this behavior. This takes the same approach as
    github.com/google/safehtml. Template.Parse will now return an Error when it
    encounters templates like this, with a currently unexported ErrorCode with a
    value of 12. This ErrorCode will be exported in the next major release.

    Users who rely on this behavior can re-enable it using the GODEBUG flag
    jstmpllitinterp=1, with the caveat that backticks will now be escaped. This
    should be used with caution.

    Thanks to Sohom Datta, Manipal Institute of Technology, for reporting this issue.

    This is CVE-2023-24538 and Go issue https://go.dev/issue/59234.

  - net/http, net/textproto: denial of service from excessive memory allocation

    HTTP and MIME header parsing could allocate large amounts of memory, even when
    parsing small inputs.

    Certain unusual patterns of input data could cause the common function used to
    parse HTTP and MIME headers to allocate substantially more memory than
    required to hold the parsed headers. An attacker can exploit this behavior to
    cause an HTTP server to allocate large amounts of memory from a small request,
    potentially leading to memory exhaustion and a denial of service.
    Header parsing now correctly allocates only the memory required to hold parsed
    headers.

    Thanks to Jakob Ackermann (@das7pad) for discovering this issue.

    This is CVE-2023-24534 and Go issue https://go.dev/issue/58975.

  - net/http, net/textproto, mime/multipart: denial of service from excessive resource consumption

    Multipart form parsing can consume large amounts of CPU and memory when
    processing form inputs containing very large numbers of parts. This stems from
    several causes:

    mime/multipart.Reader.ReadForm limits the total memory a parsed multipart form
    can consume. ReadForm could undercount the amount of memory consumed, leading
    it to accept larger inputs than intended. Limiting total memory does not
    account for increased pressure on the garbage collector from large numbers of
    small allocations in forms with many parts. ReadForm could allocate a large
    number of short-lived buffers, further increasing pressure on the garbage
    collector. The combination of these factors can permit an attacker to cause an
    program that parses multipart forms to consume large amounts of CPU and
    memory, potentially resulting in a denial of service. This affects programs
    that use mime/multipart.Reader.ReadForm, as well as form parsing in the
    net/http package with the Request methods FormFile, FormValue,
    ParseMultipartForm, and PostFormValue.

    ReadForm now does a better job of estimating the memory consumption of parsed
    forms, and performs many fewer short-lived allocations.

    In addition, mime/multipart.Reader now imposes the following limits on the
    size of parsed forms:

    Forms parsed with ReadForm may contain no more than 1000 parts. This limit may
    be adjusted with the environment variable GODEBUG=multipartmaxparts=. Form
    parts parsed with NextPart and NextRawPart may contain no more than 10,000
    header fields. In addition, forms parsed with ReadForm may contain no more
    than 10,000 header fields across all parts. This limit may be adjusted with
    the environment variable GODEBUG=multipartmaxheaders=.

    Thanks to Jakob Ackermann for discovering this issue.

    This is CVE-2023-24536 and Go issue https://go.dev/issue/59153.

  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
impacted_packages:
  - purl: pkg:github/moby/moby
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/moby/moby
        commit: f6cc8e3512e0ef882a6f9e49a034d2544aafcd0c
    introduced_in_commits: []
  - purl: pkg:github/moby/moby
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/moby/moby
        commit: 9279c41ea5a8633edde7353c90f0000066f2abec
    introduced_in_commits: []
  - purl: pkg:github/moby/moby
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/moby/moby
        commit: a09b3e9cf9de906438a6300760754fcb087f166a
    introduced_in_commits: []
  - purl: pkg:github/moby/moby
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/moby/moby
        commit: d3e52936c3da962a9bd5ecec242130d5790ee88e
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/moby/moby/tree/9279c41ea5a8633edde7353c90f0000066f2abec
    reference_type: commit
    reference_id: 9279c41ea5a8633edde7353c90f0000066f2abec
  - url: https://github.com/moby/moby/tree/a09b3e9cf9de906438a6300760754fcb087f166a
    reference_type: commit
    reference_id: a09b3e9cf9de906438a6300760754fcb087f166a
  - url: https://github.com/moby/moby/tree/d3e52936c3da962a9bd5ecec242130d5790ee88e
    reference_type: commit
    reference_id: d3e52936c3da962a9bd5ecec242130d5790ee88e
  - url: https://github.com/moby/moby/tree/f6cc8e3512e0ef882a6f9e49a034d2544aafcd0c
    reference_type: commit
    reference_id: f6cc8e3512e0ef882a6f9e49a034d2544aafcd0c
