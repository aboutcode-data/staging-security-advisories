advisory_id: CVE-2019-16276
datasource_id: collect_docker_moby_fix_commits/CVE-2019-16276
datasource_url: https://github.com/moby/moby
aliases: []
summary: |
  f8d4276a89a8b978cb5c25c33ab22a62269375f1:bump golang 1.13.1 (CVE-2019-16276)

  full diff: https://github.com/golang/go/compare/go1.13...go1.13.1

  ```
  Hi gophers,

  We have just released Go 1.13.1 and Go 1.12.10 to address a recently reported security issue. We recommend that all affected users update to one of these releases (if you're not sure which, choose Go 1.13.1).

  net/http (through net/textproto) used to accept and normalize invalid HTTP/1.1 headers with a space before the colon, in violation of RFC 7230. If a Go server is used behind an uncommon reverse proxy that accepts and forwards but doesn't normalize such invalid headers, the reverse proxy and the server can interpret the headers differently. This can lead to filter bypasses or request smuggling, the latter if requests from separate clients are multiplexed onto the same upstream connection by the proxy. Such invalid headers are now rejected by Go servers, and passed without normalization to Go client applications.

  The issue is CVE-2019-16276 and Go issue golang.org/issue/34540.

  Thanks to Andrew Stucki, Adam Scarr (99designs.com), and Jan Masarik (masarik.sh) for discovering and reporting this issue.

  Downloads are available at https://golang.org/dl for all supported platforms.

  Alla prossima,
  Filippo on behalf of the Go team
  ```

  From the patch: https://github.com/golang/go/commit/6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8

  ```
  net/textproto: don't normalize headers with spaces before the colon

  RFC 7230 is clear about headers with a space before the colon, like

  X-Answer : 42

  being invalid, but we've been accepting and normalizing them for compatibility
  purposes since CL 5690059 in 2012.

  On the client side, this is harmless and indeed most browsers behave the same
  to this day. On the server side, this becomes a security issue when the
  behavior doesn't match that of a reverse proxy sitting in front of the server.

  For example, if a WAF accepts them without normalizing them, it might be
  possible to bypass its filters, because the Go server would interpret the
  header differently. Worse, if the reverse proxy coalesces requests onto a
  single HTTP/1.1 connection to a Go server, the understanding of the request
  boundaries can get out of sync between them, allowing an attacker to tack an
  arbitrary method and path onto a request by other clients, including
  authentication headers unknown to the attacker.

  This was recently presented at multiple security conferences:
  https://portswigger.net/blog/http-desync-attacks-request-smuggling-reborn

  net/http servers already reject header keys with invalid characters.
  Simply stop normalizing extra spaces in net/textproto, let it return them
  unchanged like it does for other invalid headers, and let net/http enforce
  RFC 7230, which is HTTP specific. This loses us normalization on the client
  side, but there's no right answer on the client side anyway, and hiding the
  issue sounds worse than letting the application decide.
  ```

  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
  (cherry picked from commit 8eb23cde95496c65efacdb6f854bfd819ecb31bc)
  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
  f8d4276a89a8b978cb5c25c33ab22a62269375f1:bump golang 1.13.1 (CVE-2019-16276)

  full diff: https://github.com/golang/go/compare/go1.13...go1.13.1

  ```
  Hi gophers,

  We have just released Go 1.13.1 and Go 1.12.10 to address a recently reported security issue. We recommend that all affected users update to one of these releases (if you're not sure which, choose Go 1.13.1).

  net/http (through net/textproto) used to accept and normalize invalid HTTP/1.1 headers with a space before the colon, in violation of RFC 7230. If a Go server is used behind an uncommon reverse proxy that accepts and forwards but doesn't normalize such invalid headers, the reverse proxy and the server can interpret the headers differently. This can lead to filter bypasses or request smuggling, the latter if requests from separate clients are multiplexed onto the same upstream connection by the proxy. Such invalid headers are now rejected by Go servers, and passed without normalization to Go client applications.

  The issue is CVE-2019-16276 and Go issue golang.org/issue/34540.

  Thanks to Andrew Stucki, Adam Scarr (99designs.com), and Jan Masarik (masarik.sh) for discovering and reporting this issue.

  Downloads are available at https://golang.org/dl for all supported platforms.

  Alla prossima,
  Filippo on behalf of the Go team
  ```

  From the patch: https://github.com/golang/go/commit/6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8

  ```
  net/textproto: don't normalize headers with spaces before the colon

  RFC 7230 is clear about headers with a space before the colon, like

  X-Answer : 42

  being invalid, but we've been accepting and normalizing them for compatibility
  purposes since CL 5690059 in 2012.

  On the client side, this is harmless and indeed most browsers behave the same
  to this day. On the server side, this becomes a security issue when the
  behavior doesn't match that of a reverse proxy sitting in front of the server.

  For example, if a WAF accepts them without normalizing them, it might be
  possible to bypass its filters, because the Go server would interpret the
  header differently. Worse, if the reverse proxy coalesces requests onto a
  single HTTP/1.1 connection to a Go server, the understanding of the request
  boundaries can get out of sync between them, allowing an attacker to tack an
  arbitrary method and path onto a request by other clients, including
  authentication headers unknown to the attacker.

  This was recently presented at multiple security conferences:
  https://portswigger.net/blog/http-desync-attacks-request-smuggling-reborn

  net/http servers already reject header keys with invalid characters.
  Simply stop normalizing extra spaces in net/textproto, let it return them
  unchanged like it does for other invalid headers, and let net/http enforce
  RFC 7230, which is HTTP specific. This loses us normalization on the client
  side, but there's no right answer on the client side anyway, and hiding the
  issue sounds worse than letting the application decide.
  ```

  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
  (cherry picked from commit 8eb23cde95496c65efacdb6f854bfd819ecb31bc)
  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
  fdf46323f4962c4b933f4e28cc19b59753d3b04a:Update Golang 1.12.12 (CVE-2019-17596)

  Golang 1.12.12
  -------------------------------

  full diff: https://github.com/golang/go/compare/go1.12.11...go1.12.12

  go1.12.12 (released 2019/10/17) includes fixes to the go command, runtime,
  syscall and net packages. See the Go 1.12.12 milestone on our issue tracker for
  details.

  https://github.com/golang/go/issues?q=milestone%3AGo1.12.12

  Golang 1.12.11 (CVE-2019-17596)
  -------------------------------

  full diff: https://github.com/golang/go/compare/go1.12.10...go1.12.11

  go1.12.11 (released 2019/10/17) includes security fixes to the crypto/dsa
  package. See the Go 1.12.11 milestone on our issue tracker for details.

  https://github.com/golang/go/issues?q=milestone%3AGo1.12.11

      [security] Go 1.13.2 and Go 1.12.11 are released

      Hi gophers,

      We have just released Go 1.13.2 and Go 1.12.11 to address a recently reported
      security issue. We recommend that all affected users update to one of these
      releases (if you're not sure which, choose Go 1.13.2).

      Invalid DSA public keys can cause a panic in dsa.Verify. In particular, using
      crypto/x509.Verify on a crafted X.509 certificate chain can lead to a panic,
      even if the certificates don't chain to a trusted root. The chain can be
      delivered via a crypto/tls connection to a client, or to a server that accepts
      and verifies client certificates. net/http clients can be made to crash by an
      HTTPS server, while net/http servers that accept client certificates will
      recover the panic and are unaffected.

      Moreover, an application might crash invoking
      crypto/x509.(*CertificateRequest).CheckSignature on an X.509 certificate
      request, parsing a golang.org/x/crypto/openpgp Entity, or during a
      golang.org/x/crypto/otr conversation. Finally, a golang.org/x/crypto/ssh client
      can panic due to a malformed host key, while a server could panic if either
      PublicKeyCallback accepts a malformed public key, or if IsUserAuthority accepts
      a certificate with a malformed public key.

      The issue is CVE-2019-17596 and Go issue golang.org/issue/34960.

      Thanks to Daniel Mandragona for discovering and reporting this issue. We'd also
      like to thank regilero for a previous disclosure of CVE-2019-16276.

  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
  7fe3abf88794f2ebb531d549a3699d8e40c432da:Merge pull request #387 from thaJeztah/19.03_bump_golang_1.12.10

  [19.03] bump golang 1.12.10 (CVE-2019-16276)
  5b57f41241cb0d8df5886a1db3d7920494a9e432:Merge pull request #39999 from thaJeztah/bump_golang_1.13.1

  bump golang 1.13.1 (CVE-2019-16276)
  49e8f7451d6556c4dccaaf4a8646ea4fb463ccc7:bump golang 1.12.10 (CVE-2019-16276)

  full diff: https://github.com/golang/go/compare/go1.12.9...go1.12.10

  ```
  Hi gophers,

  We have just released Go 1.13.1 and Go 1.12.10 to address a recently reported security issue. We recommend that all affected users update to one of these releases (if you're not sure which, choose Go 1.13.1).

  net/http (through net/textproto) used to accept and normalize invalid HTTP/1.1 headers with a space before the colon, in violation of RFC 7230. If a Go server is used behind an uncommon reverse proxy that accepts and forwards but doesn't normalize such invalid headers, the reverse proxy and the server can interpret the headers differently. This can lead to filter bypasses or request smuggling, the latter if requests from separate clients are multiplexed onto the same upstream connection by the proxy. Such invalid headers are now rejected by Go servers, and passed without normalization to Go client applications.

  The issue is CVE-2019-16276 and Go issue golang.org/issue/34540.

  Thanks to Andrew Stucki, Adam Scarr (99designs.com), and Jan Masarik (masarik.sh) for discovering and reporting this issue.

  Downloads are available at https://golang.org/dl for all supported platforms.

  Alla prossima,
  Filippo on behalf of the Go team
  ```

  From the patch: https://github.com/golang/go/commit/6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8

  ```
  net/textproto: don't normalize headers with spaces before the colon

  RFC 7230 is clear about headers with a space before the colon, like

  X-Answer : 42

  being invalid, but we've been accepting and normalizing them for compatibility
  purposes since CL 5690059 in 2012.

  On the client side, this is harmless and indeed most browsers behave the same
  to this day. On the server side, this becomes a security issue when the
  behavior doesn't match that of a reverse proxy sitting in front of the server.

  For example, if a WAF accepts them without normalizing them, it might be
  possible to bypass its filters, because the Go server would interpret the
  header differently. Worse, if the reverse proxy coalesces requests onto a
  single HTTP/1.1 connection to a Go server, the understanding of the request
  boundaries can get out of sync between them, allowing an attacker to tack an
  arbitrary method and path onto a request by other clients, including
  authentication headers unknown to the attacker.

  This was recently presented at multiple security conferences:
  https://portswigger.net/blog/http-desync-attacks-request-smuggling-reborn

  net/http servers already reject header keys with invalid characters.
  Simply stop normalizing extra spaces in net/textproto, let it return them
  unchanged like it does for other invalid headers, and let net/http enforce
  RFC 7230, which is HTTP specific. This loses us normalization on the client
  side, but there's no right answer on the client side anyway, and hiding the
  issue sounds worse than letting the application decide.
  ```

  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
  49e8f7451d6556c4dccaaf4a8646ea4fb463ccc7:bump golang 1.12.10 (CVE-2019-16276)

  full diff: https://github.com/golang/go/compare/go1.12.9...go1.12.10

  ```
  Hi gophers,

  We have just released Go 1.13.1 and Go 1.12.10 to address a recently reported security issue. We recommend that all affected users update to one of these releases (if you're not sure which, choose Go 1.13.1).

  net/http (through net/textproto) used to accept and normalize invalid HTTP/1.1 headers with a space before the colon, in violation of RFC 7230. If a Go server is used behind an uncommon reverse proxy that accepts and forwards but doesn't normalize such invalid headers, the reverse proxy and the server can interpret the headers differently. This can lead to filter bypasses or request smuggling, the latter if requests from separate clients are multiplexed onto the same upstream connection by the proxy. Such invalid headers are now rejected by Go servers, and passed without normalization to Go client applications.

  The issue is CVE-2019-16276 and Go issue golang.org/issue/34540.

  Thanks to Andrew Stucki, Adam Scarr (99designs.com), and Jan Masarik (masarik.sh) for discovering and reporting this issue.

  Downloads are available at https://golang.org/dl for all supported platforms.

  Alla prossima,
  Filippo on behalf of the Go team
  ```

  From the patch: https://github.com/golang/go/commit/6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8

  ```
  net/textproto: don't normalize headers with spaces before the colon

  RFC 7230 is clear about headers with a space before the colon, like

  X-Answer : 42

  being invalid, but we've been accepting and normalizing them for compatibility
  purposes since CL 5690059 in 2012.

  On the client side, this is harmless and indeed most browsers behave the same
  to this day. On the server side, this becomes a security issue when the
  behavior doesn't match that of a reverse proxy sitting in front of the server.

  For example, if a WAF accepts them without normalizing them, it might be
  possible to bypass its filters, because the Go server would interpret the
  header differently. Worse, if the reverse proxy coalesces requests onto a
  single HTTP/1.1 connection to a Go server, the understanding of the request
  boundaries can get out of sync between them, allowing an attacker to tack an
  arbitrary method and path onto a request by other clients, including
  authentication headers unknown to the attacker.

  This was recently presented at multiple security conferences:
  https://portswigger.net/blog/http-desync-attacks-request-smuggling-reborn

  net/http servers already reject header keys with invalid characters.
  Simply stop normalizing extra spaces in net/textproto, let it return them
  unchanged like it does for other invalid headers, and let net/http enforce
  RFC 7230, which is HTTP specific. This loses us normalization on the client
  side, but there's no right answer on the client side anyway, and hiding the
  issue sounds worse than letting the application decide.
  ```

  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
  8eb23cde95496c65efacdb6f854bfd819ecb31bc:bump golang 1.13.1 (CVE-2019-16276)

  full diff: https://github.com/golang/go/compare/go1.13...go1.13.1

  ```
  Hi gophers,

  We have just released Go 1.13.1 and Go 1.12.10 to address a recently reported security issue. We recommend that all affected users update to one of these releases (if you're not sure which, choose Go 1.13.1).

  net/http (through net/textproto) used to accept and normalize invalid HTTP/1.1 headers with a space before the colon, in violation of RFC 7230. If a Go server is used behind an uncommon reverse proxy that accepts and forwards but doesn't normalize such invalid headers, the reverse proxy and the server can interpret the headers differently. This can lead to filter bypasses or request smuggling, the latter if requests from separate clients are multiplexed onto the same upstream connection by the proxy. Such invalid headers are now rejected by Go servers, and passed without normalization to Go client applications.

  The issue is CVE-2019-16276 and Go issue golang.org/issue/34540.

  Thanks to Andrew Stucki, Adam Scarr (99designs.com), and Jan Masarik (masarik.sh) for discovering and reporting this issue.

  Downloads are available at https://golang.org/dl for all supported platforms.

  Alla prossima,
  Filippo on behalf of the Go team
  ```

  From the patch: https://github.com/golang/go/commit/6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8

  ```
  net/textproto: don't normalize headers with spaces before the colon

  RFC 7230 is clear about headers with a space before the colon, like

  X-Answer : 42

  being invalid, but we've been accepting and normalizing them for compatibility
  purposes since CL 5690059 in 2012.

  On the client side, this is harmless and indeed most browsers behave the same
  to this day. On the server side, this becomes a security issue when the
  behavior doesn't match that of a reverse proxy sitting in front of the server.

  For example, if a WAF accepts them without normalizing them, it might be
  possible to bypass its filters, because the Go server would interpret the
  header differently. Worse, if the reverse proxy coalesces requests onto a
  single HTTP/1.1 connection to a Go server, the understanding of the request
  boundaries can get out of sync between them, allowing an attacker to tack an
  arbitrary method and path onto a request by other clients, including
  authentication headers unknown to the attacker.

  This was recently presented at multiple security conferences:
  https://portswigger.net/blog/http-desync-attacks-request-smuggling-reborn

  net/http servers already reject header keys with invalid characters.
  Simply stop normalizing extra spaces in net/textproto, let it return them
  unchanged like it does for other invalid headers, and let net/http enforce
  RFC 7230, which is HTTP specific. This loses us normalization on the client
  side, but there's no right answer on the client side anyway, and hiding the
  issue sounds worse than letting the application decide.
  ```

  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
  8eb23cde95496c65efacdb6f854bfd819ecb31bc:bump golang 1.13.1 (CVE-2019-16276)

  full diff: https://github.com/golang/go/compare/go1.13...go1.13.1

  ```
  Hi gophers,

  We have just released Go 1.13.1 and Go 1.12.10 to address a recently reported security issue. We recommend that all affected users update to one of these releases (if you're not sure which, choose Go 1.13.1).

  net/http (through net/textproto) used to accept and normalize invalid HTTP/1.1 headers with a space before the colon, in violation of RFC 7230. If a Go server is used behind an uncommon reverse proxy that accepts and forwards but doesn't normalize such invalid headers, the reverse proxy and the server can interpret the headers differently. This can lead to filter bypasses or request smuggling, the latter if requests from separate clients are multiplexed onto the same upstream connection by the proxy. Such invalid headers are now rejected by Go servers, and passed without normalization to Go client applications.

  The issue is CVE-2019-16276 and Go issue golang.org/issue/34540.

  Thanks to Andrew Stucki, Adam Scarr (99designs.com), and Jan Masarik (masarik.sh) for discovering and reporting this issue.

  Downloads are available at https://golang.org/dl for all supported platforms.

  Alla prossima,
  Filippo on behalf of the Go team
  ```

  From the patch: https://github.com/golang/go/commit/6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8

  ```
  net/textproto: don't normalize headers with spaces before the colon

  RFC 7230 is clear about headers with a space before the colon, like

  X-Answer : 42

  being invalid, but we've been accepting and normalizing them for compatibility
  purposes since CL 5690059 in 2012.

  On the client side, this is harmless and indeed most browsers behave the same
  to this day. On the server side, this becomes a security issue when the
  behavior doesn't match that of a reverse proxy sitting in front of the server.

  For example, if a WAF accepts them without normalizing them, it might be
  possible to bypass its filters, because the Go server would interpret the
  header differently. Worse, if the reverse proxy coalesces requests onto a
  single HTTP/1.1 connection to a Go server, the understanding of the request
  boundaries can get out of sync between them, allowing an attacker to tack an
  arbitrary method and path onto a request by other clients, including
  authentication headers unknown to the attacker.

  This was recently presented at multiple security conferences:
  https://portswigger.net/blog/http-desync-attacks-request-smuggling-reborn

  net/http servers already reject header keys with invalid characters.
  Simply stop normalizing extra spaces in net/textproto, let it return them
  unchanged like it does for other invalid headers, and let net/http enforce
  RFC 7230, which is HTTP specific. This loses us normalization on the client
  side, but there's no right answer on the client side anyway, and hiding the
  issue sounds worse than letting the application decide.
  ```

  Signed-off-by: Sebastiaan van Stijn <github@gone.nl>
impacted_packages:
  - purl: pkg:github/moby/moby
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/moby/moby
        commit: 8eb23cde95496c65efacdb6f854bfd819ecb31bc
    introduced_in_commits: []
  - purl: pkg:github/moby/moby
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/moby/moby
        commit: 49e8f7451d6556c4dccaaf4a8646ea4fb463ccc7
    introduced_in_commits: []
  - purl: pkg:github/moby/moby
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/moby/moby
        commit: 5b57f41241cb0d8df5886a1db3d7920494a9e432
    introduced_in_commits: []
  - purl: pkg:github/moby/moby
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/moby/moby
        commit: 7fe3abf88794f2ebb531d549a3699d8e40c432da
    introduced_in_commits: []
  - purl: pkg:github/moby/moby
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/moby/moby
        commit: f8d4276a89a8b978cb5c25c33ab22a62269375f1
    introduced_in_commits: []
  - purl: pkg:github/moby/moby
    affected_versions:
    fixed_versions:
    fixed_in_commits:
      - vcs_url: https://github.com/moby/moby
        commit: fdf46323f4962c4b933f4e28cc19b59753d3b04a
    introduced_in_commits: []
severities: []
weaknesses: []
references:
  - url: https://github.com/moby/moby/tree/49e8f7451d6556c4dccaaf4a8646ea4fb463ccc7
    reference_type: commit
    reference_id: 49e8f7451d6556c4dccaaf4a8646ea4fb463ccc7
  - url: https://github.com/moby/moby/tree/5b57f41241cb0d8df5886a1db3d7920494a9e432
    reference_type: commit
    reference_id: 5b57f41241cb0d8df5886a1db3d7920494a9e432
  - url: https://github.com/moby/moby/tree/7fe3abf88794f2ebb531d549a3699d8e40c432da
    reference_type: commit
    reference_id: 7fe3abf88794f2ebb531d549a3699d8e40c432da
  - url: https://github.com/moby/moby/tree/8eb23cde95496c65efacdb6f854bfd819ecb31bc
    reference_type: commit
    reference_id: 8eb23cde95496c65efacdb6f854bfd819ecb31bc
  - url: https://github.com/moby/moby/tree/f8d4276a89a8b978cb5c25c33ab22a62269375f1
    reference_type: commit
    reference_id: f8d4276a89a8b978cb5c25c33ab22a62269375f1
  - url: https://github.com/moby/moby/tree/fdf46323f4962c4b933f4e28cc19b59753d3b04a
    reference_type: commit
    reference_id: fdf46323f4962c4b933f4e28cc19b59753d3b04a
